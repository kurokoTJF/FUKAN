<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>マスクスプライトエディタ（-1/0/1 配列・白黒＋アルファ・可変サイズ）</title>
    <style>
      :root { --scale: 16; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", sans-serif; line-height: 1.45; padding: 16px; }
      h1 { font-size: 18px; margin: 0 0 8px; }
      .bar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-bottom: 8px; }
      button { padding: 6px 10px; border-radius: 10px; border: 1px solid #ccc; background: #fff; box-shadow: 0 1px 0 rgba(0,0,0,.06); cursor: pointer; }
      button.primary { background: #111; color: #fff; border-color: #111; }
      label { font-size: 12px; opacity: .9; }
      input[type="text"], select { padding: 6px 8px; border-radius: 8px; border: 1px solid #ccc; }
      canvas { image-rendering: pixelated; border: 1px solid #ccc; border-radius: 12px; touch-action: none; }
      textarea { width: 100%; height: 160px; padding: 8px; border: 1px solid #ccc; border-radius: 8px; margin-top: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
      .muted { opacity: .75; font-size: 12px; margin: 0 0 8px; }
      details { margin-top: 10px; }
      pre { background: #f5f5f5; padding: 10px; border-radius: 8px; overflow: auto; }
      .sep { width: 1px; height: 26px; background: #ddd; display: inline-block; }
    </style>
  </head>
  <body>
    <h1>マスクスプライトエディタ（-1=透明／0=黒／1=白）</h1>
    <p class="muted">白黒＋アルファ対応。エクスポートは行ごと。サイズは <strong>8×8〜64×64</strong> で切替可能。</p>

    <div class="bar">
      <span>
        <label><input type="radio" name="ink" id="inkWhite" checked> Ink: 白(1)</label>
        <label style="margin-left:8px"><input type="radio" name="ink" id="inkBlack"> 黒(0)</label>
      </span>
      <span class="sep"></span>
      <button id="toolPixel" class="primary">ドット</button>
      <button id="toolLine">直線</button>
      <button id="toolCircle">丸</button>
      <button id="toolErase">消しゴム (-1)</button>
      <label style="margin-left:8px"><input type="checkbox" id="grid" checked> グリッド</label>
    </div>

    <div class="bar">
      <label>サイズ: 
        <select id="sizeSel">
          <option>8</option>
          <option>16</option>
          <option selected>32</option>
          <option>48</option>
          <option>64</option>
        </select>
      </label>
      <button id="applySize">サイズを適用</button>
      <span class="sep"></span>
      <label>変数名: <input id="varName" type="text" value="SPRITE32" size="14" /></label>
      <span class="sep"></span>
      <button id="expflat">Export Flat JS（Nごと改行）</button>
      <button id="imp">Import</button>
      <button id="png">Download PNG</button>
      <button id="clear">Clear (-1)</button>
      <button id="tests">Run Tests</button>
    </div>

    <canvas id="cv" width="512" height="512"></canvas>

    <div style="margin-top:8px">
      <label class="muted">Export Output</label>
      <textarea id="out" placeholder="Export結果がここに出ます（クリップボードにもコピーされます）"></textarea>
    </div>

    <details>
      <summary>Export 仕様</summary>
      <div class="muted">
        <p><strong>JSON NxN</strong>：<code>[[-1,0,1,... N要素], ... N行]</code></p>
        <pre>[
  [1,0,-1, ... N 要素],
  [... N 行 ...]
]</pre>
        <p><strong>Flat JS</strong>：1次元配列だが、可読性のため<strong>Nごとに改行</strong>。</p>
        <pre>const VARNAME = [
  -1,0,0, ... N要素,
  ... N 行 ...
];</pre>
      </div>
    </details>

    <script>
      // ====== Config ======
      let SIZE = 32; // 可変
      const SCALE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--scale')) || 16;

      // ====== State ======
      let instrument = 'pixel'; // 'pixel' | 'line' | 'circle' | 'erase'
      let ink = 1; // 1=白, 0=黒 （消しゴムは -1 固定）
      let buf = new Int8Array(SIZE * SIZE); // -1/0/1
      buf.fill(-1); // 初期は透明
      const idx = (x, y) => y * SIZE + x;

      // ====== DOM ======
      const cv = document.getElementById('cv');
      const ctx = cv.getContext('2d');
      const out = document.getElementById('out');
      const grid = document.getElementById('grid');
      const sizeSel = document.getElementById('sizeSel');
      const applySizeBtn = document.getElementById('applySize');
      const varNameInput = document.getElementById('varName');

      // Toolbar wires
      const inkWhite = document.getElementById('inkWhite');
      const inkBlack = document.getElementById('inkBlack');
      document.getElementById('toolPixel').onclick = () => setInstrument('pixel');
      document.getElementById('toolLine').onclick  = () => setInstrument('line');
      document.getElementById('toolCircle').onclick= () => setInstrument('circle');
      document.getElementById('toolErase').onclick = () => setInstrument('erase');
      inkWhite.onchange = () => { if (inkWhite.checked) ink = 1; };
      inkBlack.onchange = () => { if (inkBlack.checked) ink = 0; };

      function setInstrument(name){
        instrument = name;
        document.getElementById('toolPixel').classList.toggle('primary', name==='pixel');
        document.getElementById('toolLine').classList.toggle('primary', name==='line');
        document.getElementById('toolCircle').classList.toggle('primary', name==='circle');
        document.getElementById('toolErase').classList.toggle('primary', name==='erase');
      }

      function sanitizeVarName(s){
        s = String(s || '').trim();
        if (!s) return `SPRITE${SIZE}`;
        // 先頭は英字/_、以降は英数字/_ のみ許可
        s = s.replace(/[^A-Za-z0-9_]/g, '_');
        if (!/^[A-Za-z_]/.test(s)) s = '_' + s;
        return s;
      }

      function applySize(newSize){
        newSize = Math.max(8, Math.min(64, (newSize|0)));
        if (newSize === SIZE) return;
        if (!confirm(`サイズを ${SIZE}→${newSize} に変更します。現在のドットは消去されます。OK?`)) return;
        SIZE = newSize;
        buf = new Int8Array(SIZE * SIZE);
        buf.fill(-1);
        cv.width = cv.height = SIZE * SCALE;
        varNameInput.value = `SPRITE${SIZE}`;
        redraw();
      }

      applySizeBtn.onclick = () => applySize(parseInt(sizeSel.value, 10));

      // ====== Drawing ======
      function redraw() {
        // 背景（透明をチェッカーで表現）
        const checker = 8;
        for (let y=0; y<SIZE*SCALE; y+=checker) {
          for (let x=0; x<SIZE*SCALE; x+=checker) {
            ctx.fillStyle = ((x+y)/checker % 2 === 0) ? '#dfe3e6' : '#f4f6f8';
            ctx.fillRect(x,y,checker,checker);
          }
        }
        // 0=黒, 1=白 を描画（-1 は透明のまま）
        for (let y=0;y<SIZE;y++) {
          for (let x=0;x<SIZE;x++) {
            const v = buf[idx(x,y)];
            if (v === 0) { ctx.fillStyle = '#000'; ctx.fillRect(x*SCALE, y*SCALE, SCALE, SCALE); }
            else if (v === 1) { ctx.fillStyle = '#fff'; ctx.fillRect(x*SCALE, y*SCALE, SCALE, SCALE); }
          }
        }
        // グリッド
        if (grid.checked) {
          ctx.strokeStyle = 'rgba(0,0,0,0.18)';
          ctx.lineWidth = 1;
          for (let i=0;i<=SIZE;i++) {
            ctx.beginPath();
            ctx.moveTo(i*SCALE + 0.5, 0);
            ctx.lineTo(i*SCALE + 0.5, SIZE*SCALE);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i*SCALE + 0.5);
            ctx.lineTo(SIZE*SCALE, i*SCALE + 0.5);
            ctx.stroke();
          }
        }
      }

      function setPixel(x,y,val){ if (x<0||y<0||x>=SIZE||y>=SIZE) return; buf[idx(x,y)] = val; }

      // Bresenham line
      function drawLine(x0,y0,x1,y1,val, commit=true){
        let dx = Math.abs(x1-x0), sx = x0<x1?1:-1;
        let dy = -Math.abs(y1-y0), sy = y0<y1?1:-1;
        let err = dx+dy, e2;
        const points = [];
        while(true){
          points.push([x0,y0]);
          if (x0===x1 && y0===y1) break;
          e2 = 2*err;
          if (e2 >= dy) { err += dy; x0 += sx; }
          if (e2 <= dx) { err += dx; y0 += sy; }
        }
        if (commit) { points.forEach(p=>setPixel(p[0],p[1],val)); }
        return points;
      }

      // Midpoint circle (outline)
      function drawCircle(cx,cy,r,val, commit=true){
        let x = r, y = 0; let err = 1 - x; const pts=[];
        const plot = (px,py)=>{ pts.push([px,py]); };
        while (x >= y) {
          plot(cx + x, cy + y); plot(cx + y, cy + x);
          plot(cx - y, cy + x); plot(cx - x, cy + y);
          plot(cx - x, cy - y); plot(cx - y, cy - x);
          plot(cx + y, cy - x); plot(cx + x, cy - y);
          y++;
          if (err < 0) { err += 2*y + 1; }
          else { x--; err += 2*(y - x + 1); }
        }
        if (commit) { pts.forEach(p=>setPixel(p[0],p[1],val)); }
        return pts;
      }

      // Preview overlay (no commit)
      function previewShape(from, to){
        redraw();
        if (!from || !to) return;
        ctx.globalAlpha = 0.75;
        const val = (instrument==='erase')? -1 : ink;
        const color = (val===1)? '#fff' : (val===0? '#000' : '#888');
        ctx.fillStyle = color;
        if (instrument==='line') {
          const pts = drawLine(from.x,from.y,to.x,to.y,val,false);
          pts.forEach(([x,y])=> ctx.fillRect(x*SCALE, y*SCALE, SCALE, SCALE));
        } else if (instrument==='circle') {
          const r = Math.round(Math.hypot(to.x-from.x, to.y-from.y));
          const pts = drawCircle(from.x,from.y,r,val,false);
          pts.forEach(([x,y])=> ctx.fillRect(x*SCALE, y*SCALE, SCALE, SCALE));
        }
        ctx.globalAlpha = 1;
      }

      function paintAt(x, y) {
        const val = (instrument==='erase')? -1 : ink;
        setPixel(x,y,val);
        redraw();
      }

      function getXY(e) {
        const r = cv.getBoundingClientRect();
        return {
          x: Math.floor((e.clientX - r.left) / SCALE),
          y: Math.floor((e.clientY - r.top) / SCALE)
        };
      }

      let down = false; let startPt = null;
      cv.addEventListener('pointerdown', e => {
        down = true; const {x,y} = getXY(e); startPt = {x,y};
        if (instrument==='pixel' || instrument==='erase') paintAt(x,y);
      });
      cv.addEventListener('pointermove', e => {
        if (!down) return; const {x,y} = getXY(e);
        if (instrument==='pixel' || instrument==='erase') { paintAt(x,y); }
        else { previewShape(startPt, {x,y}); }
      });
      window.addEventListener('pointerup', e => {
        if (!down) return; down=false; const end = startPt? getXY(e) : null;
        if (!startPt || !end) { startPt=null; redraw(); return; }
        const val = (instrument==='erase')? -1 : ink;
        if (instrument==='line') {
          drawLine(startPt.x, startPt.y, end.x, end.y, val, true);
        } else if (instrument==='circle') {
          const r = Math.round(Math.hypot(end.x-startPt.x, end.y-startPt.y));
          drawCircle(startPt.x, startPt.y, r, val, true);
        }
        startPt = null; redraw();
      });
      cv.addEventListener('contextmenu', e => e.preventDefault());

      // ====== Export / Import ======
      function asMatrix() {
        return Array.from({length: SIZE}, (_, y) => (
          Array.from({length: SIZE}, (_, x) => buf[idx(x,y)])
        ));
      }

      function exportJSONNxN() {
        const s = JSON.stringify(asMatrix());
        try { navigator.clipboard?.writeText(s); } catch {}
        out.value = s;
      }

      function exportFlatJS() {
        const lines = [];
        for (let y=0;y<SIZE;y++) {
          const row = [];
          for (let x=0;x<SIZE;x++) row.push(String(buf[idx(x,y)]));
          lines.push('  ' + row.join(','));
        }
        const name = sanitizeVarName(varNameInput.value) || `SPRITE${SIZE}`;
        const s = `const ${name} = [\n${lines.join(',\n')}\n]`;
        try { navigator.clipboard?.writeText(s); } catch {}
        out.value = s;
      }

      function importAny() {
        const t = prompt(`${SIZE}×${SIZE} の JSON 行列か、長さ ${SIZE*SIZE} のフラット配列（-1/0/1）を貼り付けてください`);
        if (!t) return;
        // Try JSON 2D
        try {
          const m = JSON.parse(t);
          if (Array.isArray(m) && m.length === SIZE && Array.isArray(m[0]) && m[0].length === SIZE) {
            for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++) buf[idx(x,y)] = (m[y][x]|0);
            redraw(); return;
          }
        } catch {}
        // Try flat array via Function
        try {
          const arr = Function('return ('+t+')')();
          if (Array.isArray(arr) && arr.length === SIZE*SIZE) {
            for (let i=0;i<arr.length;i++) buf[i] = (arr[i]|0);
            redraw(); return;
          }
        } catch {}
        alert('不正なデータです');
      }

      function downloadPNG() {
        // 実サイズで出力: -1 は alpha=0、0/1 は alpha=255（0=黒,1=白）
        const c = document.createElement('canvas'); c.width = SIZE; c.height = SIZE;
        const cx = c.getContext('2d');
        const img = cx.createImageData(SIZE, SIZE);
        for (let i=0;i<buf.length;i++) {
          const v = buf[i];
          const o = i*4;
          if (v === -1) { img.data[o]=0; img.data[o+1]=0; img.data[o+2]=0; img.data[o+3]=0; }
          else if (v === 0) { img.data[o]=0; img.data[o+1]=0; img.data[o+2]=0; img.data[o+3]=255; }
          else { img.data[o]=255; img.data[o+1]=255; img.data[o+2]=255; img.data[o+3]=255; }
        }
        cx.putImageData(img,0,0);
        const a = document.createElement('a'); a.href = c.toDataURL('image/png'); a.download = `sprite${SIZE}_mask_alpha.png`; a.click();
      }

      function clearAll(){ buf.fill(-1); redraw(); }

      // ====== Tests (サイズ可変対応) ======
      function runTests() {
        let pass=0, fail=0; const log=[]; const T=(cond,msg)=>{ (cond?pass:fail) && 0; log.push(`${cond?'✅':'❌'} ${msg}`); };

        // 1) 初期状態は -1 で埋まっている
        T(Array.from(buf).every(v=>v===-1), 'initial buffer is -1 (transparent)');

        // 2) ドット描画（白/黒/消しゴム）
        setPixel(0,0,1); setPixel(1,0,0); setPixel(2,0,-1);
        T(buf[idx(0,0)]===1 && buf[idx(1,0)]===0 && buf[idx(2,0)]===-1, 'pixel set values -1/0/1');

        // 3) 直線：端から端まで SIZE に依存
        const before = buf.slice();
        drawLine(0,0,SIZE-1,SIZE-1,1,true);
        T(Array.from(buf).some((v,i)=>v!==before[i]), 'line draw changes buffer');

        // 4) 丸：半径 floor(SIZE/4) で描ける
        const before2 = buf.slice();
        drawCircle(Math.floor(SIZE/2),Math.floor(SIZE/2),Math.floor(SIZE/4),0,true);
        T(Array.from(buf).some((v,i)=>v!==before2[i]), 'circle draw changes buffer');

        // 5) Export 2D は SIZE×SIZE かつ -1/0/1 のみ
        const m = asMatrix();
        T(m.length===SIZE && m.every(r=>Array.isArray(r)&&r.length===SIZE), 'matrix is NxN');
        T(m.every(r=>r.every(v=>v===-1||v===0||v===1)), 'matrix contains only -1/0/1');

        // 6) Flat 出力は SIZE 行
        const lines = [];
        for (let y=0;y<SIZE;y++){ const row=[]; for(let x=0;x<SIZE;x++) row.push(String(buf[idx(x,y)])); lines.push('  '+row.join(',')); }
        T(lines.length===SIZE, 'flat export has N lines');

        alert(`Self-tests: ${pass} passed, ${fail} failed\n\n`+log.join('\n'));
        redraw();
      }

      // ====== Wire up ======
      function exportJSONAlias(){ exportJSONNxN(); }
      document.getElementById('expflat').onclick = exportFlatJS;
      document.getElementById('imp').onclick = importAny;
      document.getElementById('png').onclick = downloadPNG;
      document.getElementById('clear').onclick = clearAll;
      document.getElementById('tests').onclick = runTests;
      grid.onchange = redraw;

      cv.width = cv.height = SIZE * SCALE;
      // 初期の変数名
      varNameInput.value = `SPRITE${SIZE}`;
      redraw();
    </script>
  </body>
</html>
