<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>2D Ray Casting with Variable Heights (Fixed)</title>
    <style>
        body {
            margin: 0;
            background: #bdbdc2;
            display: grid;
            place-items: center;
            height: 80vh;
        }

        canvas {

            image-rendering: pixelated;
            background: #8b8b8b;
        }
    </style>
</head>

<body>
    <p>Find Lily !!</p>
    <canvas id="c" width="480" height="320"></canvas>

    <p>2D preview in canvas coordination</p>


    <canvas id="c0" width="240" height="240"></canvas>

</body>








<script id="Camera2_6 data">
    // ===== Map (16x16) =====
    const worldMap = [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 1, 1, 1, 1,
        1, 0, 0, 0, 0, 3, 3, 1, 0, 0, 2, 0, 1, 1, 1, 1,
        1, 0, 3, 3, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1,
        1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1,
        1, 0, 3, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1,
        1, 0, 3, 3, 3, 0, 3, 3, 3, 0, 2, 0, 0, 1, 1, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        1, 0, 3, 3, 3, 0, 2, 2, 2, 0, 2, 0, 0, 1, 1, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 1, 1, 3,
        1, 0, 3, 3, 3, 0, 2, 2, 2, 0, 4, 0, 0, 1, 1, 3,
        1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    ];
    const floor = [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 4, 0, 0, 1, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    ];

    const ceilMap16 = [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0,
        1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0,
        1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0,
        1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0
    ];

    const checkerTex = [
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,

        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,

        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,

        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,


    ]

    const SPRITE32 = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    ];

    const Monitor16 = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1,
        -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1,
        -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1,
        -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1,
        -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1,
        -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    ];

    const Lily32 = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
        - 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
        - 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 1, 1, 0, 1, 1, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, 1, 1, 1, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 0, 0, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, 0, 0, 0, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 0, 0, 0, 0, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, -1, 1, 1, -1, 1, 1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, 1, 1, -1, 1, 1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, -1, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, -1, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, -1, -1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, -1, -1, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    ];

    const window8 = [
        0, 0, 0, 0, 0, 0, 0, 0,
        0, -1, -1, -1, -1, -1, 0, 0,
        0, -1, -1, -1, -1, -1, 0, 0,
        0, 0, -1, -1, -1, -1, -1, 0,
        0, 0, -1, -1, -1, -1, -1, 0,
        0, -1, -1, -1, -1, -1, -1, 0,
        0, -1, -1, -1, -1, -1, -1, 0,
        0, 0, 0, 0, 0, 0, 0, 0
    ]

    const ceilLight8 = [
        -1, -1, 0, 0, 0, 0, -1, -1,
        -1, 0, 1, 1, 1, 1, 0, -1,
        0, 1, 1, 1, 1, 1, 1, 0,
        -1, 0, 1, 1, 1, 1, 0, -1,
        -1, -1, 1, 1, 1, 1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1
    ]

</script>

<script>
    // ===== Canvas =====
    const canvas = document.getElementById('c');
    const c = canvas.getContext('2d', { alpha: false });
    const w = canvas.width, h = canvas.height;

    const canvas0 = document.getElementById('c0');
    const c2 = canvas0.getContext('2d', { alpha: false });
    const w0 = canvas0.width, h0 = canvas0.height;


    function drawLine(ctx, x0, y0, x1, y1, color = 'red', thickness = 4) {
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness
        ctx.beginPath()
        ctx.moveTo(x0, y0)
        ctx.lineTo(x1, y1)
        ctx.stroke()
    }

    function drawSimpleBG(color) {
        c.fillStyle = color
        c.fillRect(0, 0, w, h)
    }

    function drawGrid(cellSize = 50) {
        const cols = Math.floor(w / cellSize); // 横方向のマス数
        const rows = Math.floor(h / cellSize); // 縦方向のマス数

        c.strokeStyle = 'rgba(0,0,0,0.2)';
        c.lineWidth = 2
        c.fillStyle = 'black'
        c.font = '10px sans-serif' // フォント指定も忘れずに

        for (let i = 0; i <= cols; i++) {
            c.beginPath();
            c.moveTo(i * cellSize, 0);
            c.lineTo(i * cellSize, h);
            c.stroke();
            c.fillText(i * cellSize, i * cellSize, 10)
        }

        for (let j = 0; j <= rows; j++) {
            c.beginPath();
            c.moveTo(0, j * cellSize);
            c.lineTo(w, j * cellSize);
            c.stroke();
            c.fillText(j * cellSize, 0, j * cellSize)
        }
    }
</script>


<script id="equipment & engine & utilities">

    document.addEventListener("keyup", (e) => {
        const action = keyMap[e.key.toLowerCase()]
        if (action) {
            keys[action].pressed = false
            if (onReleasehandlers[action]) {
                if (keys[action].press) {
                    onReleasehandlers[action]()
                    keys[action].press = false
                }
            } else {
                keys[action].press = false

            }
            e.preventDefault()
        }
    })

    document.addEventListener("keydown", (e) => {
        const action = keyMap[e.key.toLowerCase()]
        if (action) {
            keys[action].pressed = true
            if (onPressHandlers[action]) {
                if (!keys[action].press) {
                    onPressHandlers[action]()
                    keys[action].press = true
                }
            } else {
                keys[action].press = true

            }
            e.preventDefault()  // ページスクロールなどを防止
        }
    })



    // html button interface
    keyPress = function (key) {
        keys[key].pressed = true
        keys[key].source = 'button'
    }

    // for (let _key in keys) keys[_key].pressed = false

    // key container
    const keys = new Proxy({}, {
        get(target, prop) {
            if (!(prop in target)) {
                target[prop] = { press: false, pressed: false };
            }
            return target[prop];
        }
    });

    // 画面になにか
    function showHTML(MSG, ID = 0) {
        let el = document.getElementById(ID);

        if (!el) {
            el = document.createElement('div');
            el.id = ID;

            const body = document.body;
            if (body.firstChild) {
                body.insertBefore(el, body.firstChild); // ← 先頭に挿入
            } else {
                body.appendChild(el); // ← 最悪何もないときは普通に追加
            }
        }

        el.innerText = MSG;
    }

    // 正式なState machine Component
    // 外部データが必要なので
    function getStateMachine(target) {
        // 初期化
        const initialState = target.data.state[target.data.initialState]
        target.state = new ImportedState(target.data.initialState, initialState)
        target.state.enter(target)

        target.cst = function (stateName) {
            this.state = new ImportedState(stateName, this.data.state[stateName])

            this.counter.setEnd()
            this.state.enter(this)
        }

        // update state to target's update()
        const _func = target.update
        target.update = function () {
            this.state.update(this)
            _func()
        }

    }

    // render queueと一緒に使う、一気に変換
    function cameraProjection(target, camera) {
        //target.drawPosition.x = target.position.x
        //target.drawPosition.y = target.position.y
        c.save()

        target.drawPosition.x = target.position.x - camera.position.x + w / 2
        target.drawPosition.y = target.position.y - camera.position.y + h / 2

        const scale = 1.5
        c.scale(scale, scale)
        // 左上がスケールの原点
        // 真ん中の点を真ん中に戻せばいい
        // 拡大したら、点の調整もスケールかけるので、最後に/scaleが必要
        target.drawPosition.x -= ((scale - 1) * w / 2) / scale
        target.drawPosition.y -= ((scale - 1) * h / 2) / scale

        target.draw()

        c.restore()


    }

    // 四角い判定ボックスと 予測型コリジョン判定用のやつ
    // updateしないと、drawPositionも更新されない
    function getCollision(target, draw = true, ctx = c) {
        target.position = { x: 0, y: 0 }
        target.deltaPosition = { x: 0, y: 0 }
        target.drawPosition = { x: 0, y: 0 }
        target.accelaration = { x: 0, y: 0 }
        target.width = 32
        target.height = 32
        target.gravity = 1
        target.direction = 1
        target.maxSpeed = { x: 3, y: 10 }

        target.checkSpeed = function () {
            const vx = target.deltaPosition.x;
            const vy = target.deltaPosition.y;
            if (Math.abs(vx) > target.maxSpeed.x) {
                target.deltaPosition.x = Math.sign(vx) * target.maxSpeed.x
            }
            if (Math.abs(vy) > target.maxSpeed.y) {
                target.deltaPosition.y = Math.sign(vy) * target.maxSpeed.y
            }
        }

        const _update = target.update.bind(target)
        target.update = function () {
            _update()
            target.drawPosition.x = target.position.x
            target.drawPosition.y = target.position.y
        }

        target.moveTo = function (x, y) {
            target.position.x = x
            target.position.y = y
        }
        target.updateDir = function () {
            if (target.deltaPosition.x > 0) target.direction = 1
            else if (target.deltaPosition.x < 0) target.direction = -1
        }

        target.drawRect = function (ctx = c) {
            ctx.fillStyle = 'grey'
            ctx.fillRect(target.drawPosition.x, target.drawPosition.y, this.width, this.height)
        }
        addMethodLast(target, 'draw', target, 'drawRect')


        target.initialize = function (x, y, w, h) {
            this.position = { x: x, y: y }
            this.width = w
            this.height = h
        }

        target.swapPosition = function () {
            target.position.x += target.deltaPosition.x
            target.position.y += target.deltaPosition.y
        }

        target.updateGravity = function () {
            target.deltaPosition.y += target.gravity
        }
        target.applyFriction = function () {
            const friction = 0.1;
            const vx = target.deltaPosition.x;

            if (Math.abs(vx) <= friction) {
                target.deltaPosition.x = 0;
            } else {
                target.deltaPosition.x -= Math.sign(vx) * friction;
            }
        }

        target.Ytop = function () {
            return { now: this.position.y, next: this.position.y + this.deltaPosition.y }
        }
        target.Ybottom = function () {
            return { now: this.position.y + this.height, next: this.position.y + this.height + this.deltaPosition.y }

        }
        target.Xleft = function () {
            return { now: this.position.x, next: this.position.x + this.deltaPosition.x }

        }
        target.Xright = function () {
            return { now: this.position.x + this.width, next: this.position.x + this.width + this.deltaPosition.x }

        }

        target.YLandOn = function (_ground) {
            target.position.y = _ground - target.height
            target.deltaPosition.y = 0
        }
        target.centerPosition = function () {
            return { x: this.position.x + this.width / 2, y: this.position.y + this.height / 2 }
        }



    }

    function getHitTester(_target) {
        _target.hitTest = function (target) {
            if (
                target.Ybottom().next > this.Ytop().now &&
                target.Ytop().next < this.Ybottom().now &&
                target.Xright().next > this.Xleft().now &&
                target.Xleft().next < this.Xright().now
            ) {

                const fromAbove = target.Ybottom().now <= this.Ytop().now
                const fromBelow = target.Ytop().now >= this.Ybottom().now
                const fromRight = target.Xleft().now >= this.Xright().now
                const fromLeft = target.Xright().now <= this.Xleft().now
                if (fromAbove) {
                    target.position.y = this.position.y - target.height
                    target.deltaPosition.y = 0
                    if (target.eventQueue) target.pushEvent('land')
                } else if (fromBelow) {
                    target.position.y = this.position.y + this.height + 1
                    target.deltaPosition.y = 0

                } else if (fromRight) {
                    target.position.x = this.position.x + this.width
                    target.deltaPosition.x = 0

                } else if (fromLeft) {
                    target.position.x = this.position.x - target.width
                    target.deltaPosition.x = 0
                } else {
                    console.log('?!')
                    const centerfromAbove = target.centerPosition().y <= this.position.y + this.height / 2;
                    const centerfromBelow = target.centerPosition().y >= this.position.y + this.height / 2;
                    const centerfromRight = target.centerPosition().x >= this.position.x + this.width / 2;
                    const centerfromLeft = target.centerPosition().x <= this.position.x + this.width / 2;
                    if (centerfromAbove) {

                        target.position.y = this.position.y - target.height
                        target.deltaPosition.y = 0
                        if (target.eventQueue) target.pushEvent('land')
                    } else if (centerfromBelow) {
                        target.position.y = this.position.y + this.height + 1
                        target.deltaPosition.y = 0

                    } else if (centerfromRight) {
                        target.position.x = this.position.x + this.width
                        target.deltaPosition.x = 0

                    } else if (centerfromLeft) {
                        target.position.x = this.position.x - target.width
                        target.deltaPosition.x = 0
                    } else {
                        console.log('bakana!')
                    }
                }
            }
        }
    }

    // 2種類のProxyを実装する
    // でも、正直Tagは使いたくないけどね
    function getProxy(target) {
        target.request = new Proxy({}, {
            get: (target, prop) => {
                const value = target[prop];
                target[prop] = false; // 読んだら自動で false にする
                return value ?? false;
            }
        });

        // 未定義状態。自由に書き込める。デフォルト状態はfalse
        target.Tag = new Proxy({}, {
            get(target, prop) {
                return prop in target ? target[prop] : false;
            }
        })
    }

    function getActiveTags(tagObj, separator = " ") {
        return Object.entries(tagObj)
            .filter(([_, v]) => v === true)
            .map(([k]) => k)
            .join(separator);
    }

    // 疎結合のためのEvent対応ようComponent
    function getEventHandler(target) {
        target.handlers = {}
        target.on = function (event, handler) {
            this.handlers[event] = handler
        }

        // Manager側で、自分の参照をtargetで送って来る
        target.onRequest = function (eventName, target, ...args) {
            const handler = this.handlers[eventName]
            if (handler) {
                handler(target, ...args)
                return true
            } else {
                return false
            }

        }

        target.resetHandlers = function () {
            target.handlers = {}
        }
    }

    function getEventManager(target) {
        // Stateはイベントの処理する対象。
        // わざと別で定義するのは、StateMachineの導入用のInterfaceとしてです
        target.state = target
        // かの有名なEventQueue
        target.eventQueue = []
        target.pushEvent = function (eName, ...args) {
            this.eventQueue.push([eName, ...args])
        }

        // 一回きりでhandleする
        target.dealEvent = function (logic_object = target.state) {
            for (const [ev, ...args] of this.eventQueue)
                logic_object.onRequest(ev, this, ...args)
            this.eventQueue = []
        }
        // masterのイベントを、ChildrenにHandleしてもらう
        // Eventは一回対応されると消える
        target.notifyEventToChildren = function () {
            this.updateList.forEach(child => {
                if (child.onRequest)
                    for (const [ev, ...args] of this.eventQueue) {
                        let consumed = false
                        if (!consumed && child.onRequest(ev, this, ...args)) {
                            consumed = true
                            //console.log(`${child.constructor.name} handle the event ${ev}`)
                        }
                    }
            })
            this.eventQueue = []

            // traverseの問題じゃないな
            return
            this.traverse(this.updateList, (child) => {
                if (child.onRequest)
                    for (const [ev, ...args] of this.eventQueue) {
                        let consumed = false
                        if (!consumed && child.onRequest(ev, this, ...args)) {
                            consumed = true
                            //console.log(`${child.constructor.name} handle the event ${ev}`)
                        }
                    }
            })

        }
        target.resetEvent = function () {
            this.eventQueue = []
        }
        target.showEventQueue = function () {
            let str = ''
            for (const [ev, ...args] of this.eventQueue) {
                str += ev + ' '
            }
            return str
        }
    }

    function getEventHubManager(target) {
        target.observers = []
        target.notifyEvent = function (Event) {
            for (const ob of target.observers) {
                ob.pushEvent(Event)
            }
        }
    }

    // Methodを結合する。returnのスコープを注意
    function addMethodFirst(target, target_method, comp, method) {
        const t = target[target_method].bind(target)
        const c = comp[method].bind(comp)
        target[target_method] = function (...args) {
            c(...args)
            t(...args)
        }
    }

    function addMethodLast(target, target_method, comp, method = target_method) {
        const t = target[target_method].bind(target)
        const c = comp[method].bind(comp)
        target[target_method] = function () {
            t()
            c()
        }
    }

    // 独自のupdateとDrawを持ったcomponentを内部に埋め込む
    function joinComponent(cmpnt, trgt) {

        addMethodLast(trgt, 'update', cmpnt)
        addMethodLast(trgt, 'draw', cmpnt)

        if (cmpnt.dealEvent && trgt.dealEvent) {
            addMethodLast(trgt, 'dealEvent', cmpnt)
        }

        return cmpnt

    }
    // state Machine の初期化。これのDecoupleは…
    // 外部データが必要
    function getStateMachine(target) {
        const initialState = target.data.state[target.data.initialState]
        target.state = new ImportedState(target.data.initialState, initialState)
        target.state.enter(target)

        target.cst = function (stateName) {
            target.state = new ImportedState(stateName, target.data.state[stateName])

            target.counter.setEnd()// じゃないと前のカウンターの処理が裏で走ってしまう
            target.state.enter(target)
        }

        const update_ = target.update.bind(target)
        console.log('state machine joined ')

        target.update = function () {
            update_()
            target.state.update(target)

        }

    }





    class ImageLoader {
        constructor(url) {
            this.loaded = false
            this.img = new Image()
            this.img.src = url
            this.img.onload = () => {
                this.loaded = true
            }
        }
        load(url) {
            this.loaded = false
            this.img.src = url
            this.img.onload = () => {
                this.loaded = true
            }
        }
        draw() {
            if (!this.loaded) return
            c.drawImage(this.img, 0, 0, this.img.width, this.img.height, 0, 0, w, h)
        }
    }

    class Counter {
        constructor({
            endTime = 100,
            pause = false,
            end = false,
            target = null,
            msg = "__",
            processCall = null,
            endCall = () => { },
            loop = false,
        } = {}) {
            this.time = 0
            this.endTime = endTime
            this.loop = loop
            this.pause = pause
            this.end = end
            this.target = target
            this.processCall = processCall
            this.endCall = endCall
            this.msg = msg
        }
        progress() {
            return this.time / this.endTime
        }
        start() {
            this.pause = false
        }
        stop() {
            this.pause = true
        }

        setEnd() {
            this.end = true
        }
        isEnd() {
            return this.end
        }

        #endMethod() {
            if (this.loop) {
                this.time = 0
                return
            }
            this.end = true
            this.endCall?.()
        }


        update() {
            if (this.time < this.endTime) {
                this.processCall?.()
                this.time++
            } else this.#endMethod()
        }
    }

    // 対象がCounterを持つようになる
    // Counterを描画するための関数が追加される
    function getCounterComponent(t, gm = GM) {
        t.counter = GM.addCounter({
            endTime: 100,
            target: t,
            processCall: function () {
                if (this.time == this.endTime - 1) {
                    this.time = 0
                }
            },
            endCall: () => {
                console.log('no chance to end')
            }
        })

        t.drawCounter = function () {
            c.fillStyle = 'red'
            c.fillRect(t.drawPosition.x, t.drawPosition.y, 32 * t.counter.progress(), 10)
        }

        addMethodLast(t, 'draw', t, 'drawCounter')
    }


    // test 用のGameManagerObject
    // cameraを入れたら、drawがcamera経由になる
    const GM = {
        registry: new Map(),
        counters: [],
        updateList: [],
        flatUpdateList: [],   // update用の平坦キャッシュ
        flatDrawList: [],    // draw用の平坦キャッシュ
        _needsRebuild: true,
        camera: {
            update: () => { },
            draw: () => {
                GM.flatDrawList.forEach(e => {
                    e.draw?.()
                })
            },
        },
        update_self: function () {
            this.camera.update()
            this.dealEvent?.()
            this.gameLoop_input()
            this.gameLoop_check()
            this.gameLoop_update()
        },
        _rebuildFlatLists() {
            console.log('[when GM rebuild] GM rebuild update and draw Lists')
            this.flatUpdateList.length = 0;
            this.flatDrawList.length = 0;

            const stack = [];
            // ルート配列は末尾→先頭の順で push（こうすると pop で先頭から処理される）
            for (let i = this.updateList.length - 1; i >= 0; i--) stack.push(this.updateList[i]);

            while (stack.length) {
                const node = stack.pop();                 // ここで“正しい順番”に取り出される
                this.flatUpdateList.push(node);
                if (!node.drawPause)
                    this.flatDrawList.push(node);

                const ch = node.updateList;
                if (ch && ch.length) {
                    // 子は「末尾から先頭へ」push していく
                    // → pop したときに先頭の子から処理され、結果として親→子の順を維持
                    for (let i = ch.length - 1; i >= 0; i--) stack.push(ch[i]);
                }
            }

            this._needsRebuild = false;
        },
        update_counters: function () {
            // 
            for (let _c of this.counters)
                if (_c.pause === false)
                    _c.update()
            this.counters = this.counters.filter((_c) => _c.end == false)
        },
        showList: function (List, level = 0) {
            if (level == 0)
                if (!this._needsRebuild)
                    if (this.updateListTXT)
                        return false
                    else
                        console.log('[when GM rebuild] GM printed the updatedw list')


            this.updateListTXT = 'txt'
            let result = '';
            if (!level) result = 'GM Root\n'
            List.forEach(e => {
                // インデント作成
                let indent = '  | '

                if (level) {

                    indent += '  | '.repeat(level - 1);
                } else {
                    indent = '  | '.repeat(level)
                }
                if (e.updatePause) indent += 'x '
                else indent += 'o '
                if (e.drawPause) indent += 'x '
                else indent += 'o '
                indent += ' '
                let tags = ''
                if (e.tags)
                    tags = Array.from(e.tags).join(" ")


                // 自分を出力
                result += `${indent}${e.name ? e.name : e.constructor.name}: (${tags})\n`;

                // 子リストがあれば再帰
                if (!e.folded && e.updateList) {
                    result += this.showList(e.updateList, level + 1);
                } else if (e.folded)
                    result += 'folded\n'
            });

            this.updateListTXT = result
            return this.updateListTXT;
        },
        showCounters: function () {
            let _table = ""
            for (let _c of this.counters) {
                _table += _c.msg + ":" + _c.time + "/" + _c.endTime + "\n"
            }
            return _table
        },
        addCounter: function ({
            msg = "[untitled]",
            target = undefined,
            endTime = 10,
            loop = false,
            processCall = null,
            endCall = () => {
                this.end = true
            },

        } = {}) {
            let _temp = new Counter({
                endTime: endTime,
                target: target,
                loop: loop,
                msg: msg,
                processCall: processCall,
                endCall: endCall,
            })
            this.counters.push(_temp)
            return _temp
        },
        // counterはEventになる、そしてEventとInputと同様
        gameLoop_input: function () {

        },
        // 予測型コリジョン判定用
        gameLoop_check: function () {

        },
        // 数値の適応と更新
        gameLoop_update: function () {

        },
        traverse: function (list, callback) {
            for (const obj of list) {
                callback(obj)
                if (obj.updateList) {
                    this.traverse(obj.updateList, callback)
                }
            }
        },

        flattenUpdateList: function (list) {
            const result = []
            for (const obj of list) {
                result.push(obj)
                if (obj.updateList)
                    result.push(...GM.flattenUpdateList(obj.updateList))
            }
            return result
        },
        setTagPause: function (tag, pause = true, List = this.updateList) {
            GM.traverse(List, (e) => {
                if (e.tags?.has(tag))
                    e.updatePause = pause
            })
        },

        removeByTag: function (tag, list = this.updateList) {
            for (let i = list.length - 1; i >= 0; i--) { // 逆順で安全に削除
                const obj = list[i];
                if (!obj.tags) continue
                if (obj.tags.has(tag)) {
                    obj.destroy?.()
                    list.splice(i, 1); // 該当オブジェクトを削除
                }
                else if (obj.updateList) {
                    // 子リストがある場合は再帰
                    GM.removeByTag(tag, obj.updateList);
                }
            }
        },
        reset: function () {
            this.registry = new Map()
            this.updateList = []
            this.drawList = []

        },
        addChild: function (e, draw = true) {
            this._needsRebuild = true;
            this.updateList.push(e)
            if (e.onAttach)
                e.onAttach(this)
            else
                e.master = this
            e.updatePause = false
            if (e.drawPause == true) return
            if (draw) e.drawPause = false
            else e.drawPause = true
        },
        update: function () {

            if (this.updatePause === true) return

            if (this._needsRebuild) this._rebuildFlatLists();

            this.update_self()
            this.flatUpdateList.forEach(e => {
                e.update?.()
            })

        },

        draw: function () {
            c.clearRect(0, 0, w, h)

            this.camera.draw()


        },

        update_sandbox: function () {

        },
        draw_sandbox: function () {

        }

    }

    // 本当は配列に入れたほうが、あとから消すことができるけどね
    function joinGameLoop(target, gm = GM) {

        if (target.dealEvent)
            addMethodLast(gm, 'gameLoop_input', target, 'dealEvent')
        if (target.check)
            addMethodLast(gm, 'gameLoop_check', target, 'check')
        if (target.update)
            addMethodLast(gm, 'gameLoop_update', target, 'update')
        if (target.draw)
            addMethodLast(gm, 'draw', target, 'draw')
    }

    // ここに入れれば、繰り返し呼び出される
    function gameLoop() {
        console.log('1st frame, game start')
    }

    function update() {
        gameLoop()
        requestAnimationFrame(update)
    }
    update()
</script>

<script id="3D accessable world engine">
    // マイクラ世界の醍醐味の一つ
    // positionとwidth, height, blockSizeの定義も必須
    // アクセスできる世界の情報で、好きなタイミングで checkができる。


    function moveAxis(axis, delta, _player = player, _world = _player.world) {
        _player[`v` + axis] = _world.moveAxisCheck_BottomType(_player.position, axis, delta, _player.size, _player)
    }

    // player.current を設定するだけ。
    // and the player needs position, size, vx,vy,vz
    // 完全透明。空のupdateとupdateListを入れることで、this.currentのupdateなどに二回アクセスするのを防ぐ
    class PlayerProxy {
        constructor(initial = null, name) {
            this.current = initial;
            this.name = name
            this.updateList = []
            return new Proxy(this, {
                get: (target, prop, receiver) => {
                    if (prop in target) return Reflect.get(target, prop, receiver);
                    return target.current?.[prop];
                },
                set: (target, prop, value, receiver) => {
                    if (prop in target) return Reflect.set(target, prop, value, receiver);
                    if (target.current) target.current[prop] = value;
                    return true;
                }
            });
        }

        update() { }

        setCurrent(obj) {
            this.current = obj;
        }
        getCurrent() {
            return this.current;
        }
    }



    class EmptyObject {
        constructor() {
        }
        //これは上書きしない
        update() {
            if (this.updatePause === true) return
            this.update_self()
        }
        traverse(list, callback) {
            for (const obj of list) {
                callback(obj)
                if (obj.updateList) {
                    GM.traverse(obj.updateList, callback)
                }
            }
        }

        updateList_filter(ID) {
            this.updateList = this.updateList.filter((c) => c.id != ID)
        }
        addChild(e, draw = true) {
            this.updateList.push(e)
            e.master = this
            e.updatePause = false
            if (draw) e.drawPause = false
            else e.drawPause = true
        }
        update_self() {
        }
        destroy() {
            console.log(`${this.constructor.name} destroyed`);
        }

        draw() {
            console.log('Empty object draw')
        }
    }

    class GameObject {
        constructor(name) {
            this.folded = false // toggle this to fold a folder group
            this.name = name
            this.updateList = []
            this.drawList = []
            this.tags = new Set()
            this.drawPause = false
            this.updatePause = false
        }
        //これは上書きしない
        update() {
            if (this.updatePause === true) return
            this.update_self()
        }

        onAttach(master) {
            this.master = master;
        }
        traverse(list, callback) {
            for (const obj of list) {
                callback(obj)
                if (obj.updateList) {
                    this.traverse(obj.updateList, callback)
                }
            }
        }

        updateList_filter(ID) {
            this.updateList = this.updateList.filter((c) => c.id != ID)
        }
        addChild(e, draw = true) {
            this.updateList.push(e)
            e.master = this
            if (e.onAttach)
                e.onAttach(this)
            else
                e.master = this
            e.updatePause = false
            if (e.drawPause == true) return
            if (draw) e.drawPause = false
            else e.drawPause = true
        }
        update_self() {
        }
        destroy() {
            console.log(`${this.constructor.name} destroyed`);
        }

        draw() {
            console.log('gameobject draw')
        }
    }

    class BlockWorld extends GameObject {
        constructor(x = 10, y = 10, z = 5, block_size = 32) {
            super()
            this.block_size = 50
            this.world = []
            this.worldSize = {
                x: x,
                y: y,
                z: z
            }

            this.initialize()

            this.blockImage = new ImageLoader('https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/map/MCblock.png')

        }

        initialize() {
            for (let x = 0; x < this.worldSize.x; x++) {
                this.world[x] = []
                for (let y = 0; y < this.worldSize.y; y++) {
                    this.world[x][y] = []
                    const height = Math.floor(Math.random() * (this.worldSize.z - 1)) + 1
                    for (let z = 0; z < height; z++) {
                        this.world[x][y][z] = 1

                        if (x > 1 && x < this.worldSize.x - 2 && y > 1 && y < this.worldSize.y - 2 && z > 0) {
                            this.world[x][y][z] = 0

                        }
                    }
                }
            }

        }

        moveAxisCheck_BottomType(pp, axis, delta, size, target = null) {
            const block = this.block_size
            const pw = size.x
            const pd = size.y
            const ph = size.z
            const np = { x: pp.x, y: pp.y, z: pp.z }
            np[axis] += delta
            // この計算…一回だけでいいよね？
            // いやだめだ、軸ごとにPositionの更新が入るので、引っかかるBlockも更新されるべき
            const eps = 0.001// Math.floorは[0,1)なので、max側にくっつけた状態が良くない
            const minX = Math.floor((np.x - pw / 2) / block)
            const maxX = Math.floor((np.x + pw / 2 - eps) / block)
            const minY = Math.floor((np.y - pd / 2) / block)
            const maxY = Math.floor((np.y + pd / 2 - eps) / block)
            const minZ = Math.floor((np.z) / block)
            const maxZ = Math.floor((np.z + ph - eps) / block)

            for (let bx = minX; bx <= maxX; bx++) {
                for (let by = minY; by <= maxY; by++) {
                    for (let bz = minZ; bz <= maxZ; bz++) {
                        if (this.world[bx]?.[by]?.[bz]) {
                            // 衝突補正: 進行方向に応じて位置をブロックの端に揃える
                            if (axis === 'x') {
                                if (delta > 0) pp[axis] = bx * block - pw / 2;
                                if (delta < 0) pp[axis] = (bx + 1) * block + pw / 2
                            } else if (axis === 'y') {
                                if (delta > 0) pp[axis] = by * block - pd / 2;
                                if (delta < 0) pp[axis] = (by + 1) * block + pd / 2
                            } else if (axis === 'z') {
                                if (delta > 0) pp[axis] = bz * block - ph;       // top
                                if (delta < 0) {
                                    pp[axis] = (bz + 1) * block;
                                    target.pushEvent('land')


                                }  // landing

                            }
                            return 0; // 衝突したら移動終了
                        }
                    }
                }
            }

            return delta
        }


        exportRenderQueue(camera) {
            const worldSize = this.worldSize
            const block_size = this.block_size
            const world = this.world
            const camera_angle = camera.rotation / 180 * Math.PI
            const blockImage = this.blockImage

            for (let x = 0; x < worldSize.x; x++) for (let y = 0; y < worldSize.y; y++) for (let z = 0; z < worldSize.z; z++) if (world[x][y][z]) {
                const v_p = camera.projection({
                    x: x * block_size,
                    y: (y + 1) * block_size,
                    z: z * block_size
                })
                const v2_p = camera.projection({
                    x: x * block_size,
                    y: (y + 1) * block_size,
                    z: (z + 1) * block_size
                })
                const h1 = v2_p.y // top
                const h2 = v_p.y // bottom

                if (h1 < h && h2 > 0) if (h2 - h1 > 0)
                    // draw front height
                    camera.renderQueue.push({
                        depth: x + y + z + 1,
                        color: `hsla(${z / worldSize.z * 20 + y / worldSize.y * 20 + 200}, 50%, ${z / worldSize.z * 50 + y / worldSize.y * 50}%,
                                0.2)`,
                        draw: function () {
                            let coord = null
                            if (!world[x][y][z + 1]) {

                                coord = { x: 3, y: 0 }
                            }
                            else {
                                coord = { x: 2, y: 0 }

                            }

                            if (blockImage.loaded) {
                                c.drawImage(
                                    blockImage.img,
                                    coord.x * 48,
                                    coord.y * 48,
                                    48,
                                    48,
                                    v2_p.x,
                                    v2_p.y,
                                    block_size,
                                    Math.ceil(h2 - h1) + 1)
                            }

                            c.fillStyle = this.color;
                            c.fillRect(
                                v2_p.x,
                                v2_p.y,
                                block_size,
                                Math.ceil(h2 - h1) + 1
                            );

                        }
                    })

                // draw top!
                if (!world[x][y][z + 1]) {
                    const vt_p = camera.projection({
                        x: x * block_size,
                        y: y * block_size,
                        z: (z + 1) * block_size
                    })
                    const vt2_p = camera.projection({
                        x: x * block_size,
                        y: (y + 1) * block_size,
                        z: (z + 1) * block_size
                    })
                    const h1 = vt_p.y // top
                    const h2 = vt2_p.y // bottom

                    if (h1 < h && h2 > 0) if (h2 - h1 > 0)

                        camera.renderQueue.push({
                            depth: x + y + z + 1,
                            color: `hsla(
                                ${(z + 1) * 40 / worldSize.z}, 
                                80%, 
                                ${(z + 1) * 100 / worldSize.z}%,
                                0.3)`,
                            draw: function () {


                                if (blockImage.loaded) {
                                    const coord = { x: 12, y: 12 }
                                    c.drawImage(
                                        blockImage.img,
                                        coord.x * 48,
                                        coord.y * 48,
                                        48,
                                        48,
                                        vt_p.x,
                                        vt_p.y,
                                        block_size,
                                        Math.ceil(h2 - h1) + 1)
                                }

                                c.fillStyle = this.color;
                                c.fillRect(
                                    vt_p.x,
                                    vt_p.y,
                                    block_size,
                                    Math.ceil(h2 - h1) + 1
                                )


                            }
                        })
                }



            }
        }
    }

    class Camera2_5 extends GameObject {
        constructor(target) {
            super()
            this.position = {
                x: 0,
                y: 0,
                z: 0,

            }
            this.target = target
            this.radius = 400 // cylinder effect
            this.tilt = 0 // z axis rotation
            this.rotation = 45 // x axis rotation
            this.zoom = 1
            this.speed = 0.04
            this.drawList = []
            this.drawListUI = []
            this.renderQueue = []
            this.updateList = []

        }
        update_self() {
            if (this.target) {
                const deltaX = this.target.position.x - this.position.x
                const deltaY = this.target.position.y - this.position.y
                const deltaZ = this.target.position.z - this.position.z
                if (Math.abs(deltaX) > 1)
                    this.position.x += (deltaX) * this.speed
                else
                    this.position.x = this.target.position.x
                if (Math.abs(deltaY) > 1)
                    this.position.y += (deltaY) * this.speed
                else
                    this.position.y = this.target.position.y
                if (Math.abs(deltaZ) > 1)
                    this.position.z += (deltaZ) * this.speed
                else
                    this.position.z = this.target.position.z
            }
        }

        projection(position) {
            const cp = this.position
            const rad = this.rotation / 180 * Math.PI // angle in radius
            const radius = this.radius
            // my canvas XYZ to Maya XYZ
            // the origin is left-top
            const v1 = {
                x: position.x - cp.x,
                y: position.y - cp.y,
                z: position.z - cp.z
            }


            //const k = Math.min(Math.abs(v1.y) / this.world.block_size/2, 1)
            const k = 1
            const theta = v1.y / radius
            v1.y = v1.y * (1 - k) + k * (radius + position.z) * Math.sin(theta)
            v1.z = v1.z * (1 - k) + k * (v1.z - (radius + position.z) * (1 - Math.cos(theta)))


            const v2 = {
                x: v1.x,
                y: h - v1.y,
                z: v1.z
            }
            // world to camera(in Maya XYZ)
            // the dot production, to get the coords in new coordination
            const v3 = {
                x: v2.x,
                y: v2.y * Math.cos(rad) + v2.z * Math.sin(rad),
                z: v2.y * Math.sin(rad) - v2.z * Math.cos(rad)
            }
            // camera(Maya XYZ) to screen(invert the y)
            // camera center! (x, h * Math.cos(rad))
            const v4 = {
                x: (v3.x) + w / 2,
                y: (h * Math.cos(rad) - v3.y) + h / 2,
                z: v3.z
            }

            //v.update_drawPosition(v4)
            return v4
        }

        getDepth() { }

        draw() {
            this.getGMRenderQueue()

            c.save(); // 現在の状態を保存
            // 中心を回転の基準点に移動
            c.translate(w / 2, h / 2);
            c.rotate(this.tilt * Math.PI / 180);
            c.scale(1 + (this.zoom - 1) * 2, this.zoom)
            c.translate(-w / 2, -h / 2);
            this.renderQueue.forEach(e => {
                e.draw?.()
            })
            c.restore(); // 状態を元に戻す

            this.renderQueue.length = 0 // こっちのほうがメモリー的に良いらしい

            this.drawListUI.forEach(e => {
                e.draw?.()
            })
            this.drawListUI = []
        }
        getGMRenderQueue() {
            GM.traverse(GM.updateList, (e) => {
                if (!e.drawPause)
                    if (e.exportRenderQueue)
                        e.exportRenderQueue(GM.camera)
                    else
                        this.drawListUI.push(e)


            })
            this.renderQueue.sort((a, b) => a.depth - b.depth)
        }

        getRenderQueue() {
            // for loop the world, push something into renderqueue

            // draw player!
            this.drawList.forEach(e => {
                if (!e.exportRenderQueue) return console.log('some object need the exportRenderQueue Method')
                e.exportRenderQueue(this)
            })
            this.renderQueue.sort((a, b) => a.depth - b.depth)

        }
    }



    // the player is defined by the world

    class Collision3D extends GameObject {
        constructor() {
            super()
            this.drawPause = false
            getEventHandler(this)
            this.on('keydown', (target) => {
                target.vy = 2
            })
            this.on('keyup', (target) => {
                target.vy = -2
            })
            this.on('keyright', (target) => {
                target.vx = 2
            })
            this.on('keyleft', (target) => {
                target.vx = -2
            })
        }
        update_self() {
            const m = this.master
            // get and chect the next, in just one code!

            // self-check the delta 
            m.vx = m.worldMove('x', m.vx)
            m.vy = m.worldMove('y', m.vy)
            m.vz = m.worldMove('z', m.vz)


            m.position.x += m.vx
            m.position.y += m.vy
            m.position.z += m.vz

            if (m.vx > 0) m.direction.x = 1
            else if (m.vx < 0) m.direction.x = -1

            if (m.vx != 0 || m.vy != 0) m.pushEvent('onMove')
            else if (m.vx == 0 && m.vy == 0) m.pushEvent('onStop')

            if (m.vz < 0) m.pushEvent('fall')

            // 摩擦力未実装なのでとりあえず止める
            m.vx = this.applyFriction(m.vx)
            m.vy = this.applyFriction(m.vy)
            m.vz -= 0.5

        }

        applyFriction(v) {
            const friction = this.master.friction || 0.1;

            if (Math.abs(v) <= friction) {
                return 0;
            } else {
                return v - Math.sign(v) * friction;
            }
        }
        applyGravity(v) {
            const friction = this.master.friction || 0.1;
            return v - 0.5
        }

        exportRenderQueue(camera) {
            const m = this.master
            const vp1 = camera.projection({
                x: m.position.x - m.size.x / 2,
                y: m.position.y - m.size.y / 2,
                z: m.position.z + m.size.z
            });
            const vp2 = camera.projection({
                x: m.position.x - m.size.x / 2,
                y: m.position.y + m.size.y / 2,
                z: m.position.z + m.size.z
            });
            const vp3 = camera.projection({
                x: m.position.x - m.size.x / 2,
                y: m.position.y + m.size.y / 2,
                z: m.position.z
            });
            camera.renderQueue.push({
                depth: (m.position.x + m.position.y + m.position.z) / m.world.block_size,
                draw: () => {
                    c.fillStyle = 'yellow';
                    c.fillRect(
                        vp1.x,
                        vp1.y,
                        m.size.x,
                        (vp2.y - vp1.y)
                    );

                    c.fillStyle = 'red';
                    c.fillRect(
                        vp2.x,
                        vp2.y,
                        m.size.x,
                        (vp3.y - vp2.y),
                    );

                }

            });
        }
    }

    class Player3D extends GameObject {
        constructor(_world) {
            super()
            this.world = _world
            this.color = 'yellow'
            this.position = {
                x: 300,
                y: 100,
                z: 300,
            }
            this.size = {
                x: 20,
                y: 20,
                z: 20,
            }
            this.direction = {
                x: 0,
                y: 1,
                z: 1,
            }
            this.vx = 0
            this.vy = 0
            this.vz = 0
            this.updateList = []
            this.drawPause = true
            // to spread the event
            getEventManager(this)
        }

        moveTo(x, y, z) {
            this.position.x = x
            this.position.y = y
            this.position.z = z
        }

        worldMove(Axis, delta) {
            const d = this.world.moveAxisCheck_BottomType(this.position, Axis, delta, this.size, this)
            return d
        }

        update_self() {
            this.notifyEventToChildren()

        }


        exportRenderQueue(camera) {
            const vp1 = camera.projection({
                x: this.position.x - this.size.x / 2,
                y: this.position.y - this.size.y / 2,
                z: this.position.z + this.size.z
            });
            const vp2 = camera.projection({
                x: this.position.x - this.size.x / 2,
                y: this.position.y + this.size.y / 2,
                z: this.position.z + this.size.z
            });
            const vp3 = camera.projection({
                x: this.position.x - this.size.x / 2,
                y: this.position.y + this.size.y / 2,
                z: this.position.z
            });
            camera.renderQueue.push({
                depth: (this.position.x + this.position.y + this.position.z) / this.world.block_size,
                draw: () => {
                    c.fillStyle = this.color;
                    c.fillRect(
                        vp1.x,
                        vp1.y,
                        this.size.x,
                        (vp2.y - vp1.y)
                    );

                    c.fillStyle = 'rgba(160,0,100,1)';
                    c.fillRect(
                        vp2.x,
                        vp2.y,
                        this.size.x,
                        (vp3.y - vp2.y),
                    );

                }

            });
        }

    }


    class Controller3D extends GameObject {
        constructor() {
            super()
            this.id = 'controller3D'

        }
        update_self() {

            if (!this.master) return
            const m = this.master
            if (keys.down.pressed) {
                m.pushEvent('keydown')
            } else if (keys.up.pressed) {
                m.pushEvent('keyup')
            }

            if (keys.left.pressed) {
                m.pushEvent('keyleft')

            } else if (keys.right.pressed) {
                m.pushEvent('keyright')
            }

            onPressHandlers.attack = () => {
                m.pushEvent('atk')
            }
            onPressHandlers.jump = () => {
                //moveAxis('z', 8, this.target)
                m.pushEvent('jump')

            }
            onPressHandlers.parry = () => {
                //moveAxis('z', 8, this.target)
                m.pushEvent('parry')

            }


        }
    }

    class ListShower {
        constructor() {
            this.text = []
        }
        update() {
        }
        draw() {
            if (!this.master) return
            const text = GM.showList(this.master.flatDrawList)

            if (text != false) {
                console.log('[when GM rebuild] list shower split the list')
                const lines = text.split('\n')
                this.text = lines
                const startY = 0
                const lineHeight = 20 // 行間。お好みで調整

                c.fillStyle = 'rgba(0,0,0,0.5)'
                c.fillRect(0, 0, w / 3, lineHeight * lines.length)

                c.fillStyle = 'white'
                c.font = '10px sans-serif' // フォント指定も忘れずに

                lines.forEach((line, i) => {
                    c.fillText(line, 10, startY + 20 + i * lineHeight)
                })
            } else {

                const lines = this.text
                const startY = 0
                const lineHeight = 20 // 行間。お好みで調整

                c.fillStyle = 'rgba(0,0,0,0.5)'
                c.fillRect(0, 0, w / 3, lineHeight * lines.length)

                c.fillStyle = 'white'
                c.font = '10px sans-serif' // フォント指定も忘れずに
                lines.forEach((line, i) => {
                    c.fillText(line, 10, startY + 20 + i * lineHeight)
                })
            }
        }
    }


    class stateRenderer2_5 extends GameObject {
        constructor(master) {
            super()
            this.master = master
            this.spriteImage = null
            this.currentFrame = 0

        }

        checkSprite() {
            const n = this.master.activeState.name
            const s = this.master.data.state[n]?.sprite
            if (!s) return false
            if (this.spriteName === n) return true

            const path = this.master.data.spriteFolder + s.path

            if (!this.spriteImage)
                this.spriteImage = new ImageLoader(path)
            else if (this.spriteImage.img.src != path)
                this.spriteImage.load(path)

            return true
        }

        update() {
            if (!this.checkSprite()) {
                this.spriteImage = null
                return
            }

            const n = this.master.activeState.name
            const s = this.master.data.state[n]?.sprite
            const mc = this.master.counter
            let FrameBuffer = mc.endTime / s.length
            this.currentFrame = Math.floor(mc.time / FrameBuffer)
            this.currentFrame = Math.min(this.currentFrame, s.length - 1)

        }

        exportSpriteDraw(camera) {
            if (!this.spriteImage?.loaded) return false
            const n = this.master.activeState.name
            const s = this.master.data.state[n]?.sprite

            const sw = this.spriteImage.img.width / s.length
            const sh = this.spriteImage.img.height

            const cropbox = {
                position: {
                    x: sw * this.currentFrame,
                    y: 0,
                },
                width: sw,
                height: sh,
            }

            if (this.offset) {
                this.drawPosition.x += this.offset.x
                this.drawPosition.y += this.offset.y
            }

            const target = this.master.master
            const sizex = target.size.x * 2
            const sizey = target.size.y * 2
            const vp1 = camera.projection({
                x: target.position.x,
                y: target.position.y,
                z: target.position.z + target.size.z / 2
            });

            let flip = 1
            let flipX = vp1.x - sw / 2
            if (target.direction.x <= 0) flip *= -1
            if (s.flip) flip *= -1
            if (flip <= 0) flipX = -(vp1.x + sw / 2)

            const offsetx = s.offset ? s.offset.x : 0
            const offsety = s.offset ? s.offset.y : 0

            const drawObject = {
                depth: (target.position.x + target.position.y + target.position.z) / target.world.block_size,

                draw: () => {
                    c.save()
                    c.scale(flip, 1);
                    c.drawImage(
                        this.spriteImage.img,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        flipX + offsetx,
                        vp1.y - sh / 2 + offsety,
                        sw,
                        sh,
                    )

                    c.restore()


                    showHTML(`${this.master.activeState.name}: ${Math.floor(this.master.counter?.progress() * 10) / 10},currentFrame:${this.currentFrame}`, 11)
                }
            }

            return drawObject




        }

        draw() {
            if (!this.spriteImage?.loaded) return
            const n = this.master.activeState.name
            const s = this.master.data.state[n]?.sprite

            const sw = this.spriteImage.img.width / s.length
            const sh = this.spriteImage.img.height

            const cropbox = {
                position: {
                    x: sw * this.currentFrame,
                    y: 0,
                },
                width: sw,
                height: sh,
            }

            if (this.offset) {
                this.drawPosition.x += this.offset.x
                this.drawPosition.y += this.offset.y
            }

            c.drawImage(
                this.spriteImage,
                cropbox.position.x,
                cropbox.position.y,
                cropbox.width,
                cropbox.height,

                this.drawPosition.x,
                this.drawPosition.y,
                sw,
                sh,
            )
        }


        exportRenderQueue(camera) {
            const ex = this.exportSpriteDraw(camera)
            if (!ex) return
            camera.renderQueue.push(ex);
        }


    }

    class Player3DState {
        constructor(master) {
            this.name = ''
            this.data = master.data
            this.master = master
            this.target = master.master
            getEventHandler(this)

        }

        update() { }
        draw() { }
        enter() {
            console.log(`${this.name} state is created`)
        }
    }

    class Player3DImportedState extends Player3DState {
        constructor(sname, master) {
            super(master)
            this.name = sname
            console.log(`${this.name} state created`)
            this.data = master.data.state[sname]
            if (this.data.baseState) {
                const n = this.data.baseState
                this.data = master.data.state[n]
            }
            for (const [eventName, action] of Object.entries(this.data.on || {})) {

                this.on(eventName, (target, EventData) => {
                    if (action.move) {
                        for (const m in action.move) {
                            if (action.move[m]) {
                                moveAxis(m, action.move[m], this.target)
                            }
                        }
                    }
                    if (action.log) console.log(action.log)
                    if (action.event) GM.pushEvent(action.event)
                    if (action.nextState)
                        this.master.cst2(action.nextState)
                })
            }

            this.enter()
        }

        enter() {
            const _counter = GM.addCounter({
                msg: '[' + this.name + ']',
                target: this.master,
                endTime: this.data.duration,
                endCall: () => {
                    this.target.pushEvent('onEnd')

                }
            })

            const _counter0 = new Counter({
                msg: '[' + this.name + ']',
                target: this.master,
                endTime: this.data.duration,
                endCall: () => {
                    this.target.pushEvent('onEnd')

                }
            })

            const loop = this.data.sprite.loop
            const length = this.data.sprite.length
            const duration = this.data.duration
            if (loop) {
                _counter.processCall = () => {
                    for (const step of this.data.steps || [])
                        if (_counter.time === step.time)
                            step.action(this.target)
                    if (_counter.time === duration - 1)
                        if (loop < length && duration > 0) {
                            _counter.time = Math.floor(loop / length * duration)
                        }
                }
            } else {
                _counter.processCall = () => {
                    for (const step of this.data.steps || [])
                        if (_counter.time === step.time)
                            step.action(this.target)
                }
            }

            // counter must be end
            this.master.counter?.setEnd()
            this.master.counter = _counter
        }
    }



    class StateMachine extends GameObject {
        constructor(data = Rock, name) {
            super(name)
            this.drawPause = true
            this.data = data
            this.counter = null

        }

        onAttach(master) {
            console.log('onAttach')
            this.master = master;
            this.activeState = new Player3DImportedState(this.data.initialState, this);
            this.addChild(new stateRenderer2_5(this))

        }

        // just interface
        onRequest(eventName, target, ...args) {
            return this.activeState.onRequest(eventName, target, ...args)
        }

        cst2(stateName) {
            this.activeState = new Player3DImportedState(stateName, this)
        }

        update_self() {
            this.activeState.update()
        }

        draw() {
            if (this.drawPause) return
            c.fillStyle = 'red'
            c.fillRect(0, 0, w, h)
        }

        exportRenderQueue(camera) {
            const sizex = this.master.size.x / 2
            const sizey = this.master.size.y / 2
            const vp1 = camera.projection({
                x: this.master.position.x,
                y: this.master.position.y + this.master.size.y / 2,
                z: this.master.position.z + this.master.size.z / 2
            });
            camera.renderQueue.push({
                depth: (this.master.position.x + this.master.position.y + this.master.position.z) / this.master.world.block_size,
                draw: () => {
                    c.fillStyle = 'red';
                    c.fillRect(
                        vp1.x - sizex / 2,
                        vp1.y - sizey / 2,
                        sizex,
                        sizey
                    );
                }

            });
        }
    }


    // SoundManager
    // register and play
    class SoundManager {
        constructor() {
            this.registry = new Map(); // name → path
        }

        // 音を登録
        register(name, path) {
            this.registry.set(name, path);
        }

        // 再生
        play(name, volume = 1.0) {
            const path = this.registry.get(name);
            if (!path) {
                console.warn(`Sound "${name}" is not registered.`);
                return;
            }
            const audio = new Audio(path);
            audio.volume = Math.max(0, Math.min(1, volume));
            audio.play();
        }
    }



    // ちいさいユーティリティ
    const lerp = (a, b, t) => a + (b - a) * t;
    const clamp01 = (t) => Math.max(0, Math.min(1, t));
    // 代表的なEasing（必要な分だけ）
    const ease = {
        linear: t => t,
        inQuad: t => t * t,
        outQuad: t => t * (2 - t),
        inOutQuad: t => (t < .5) ? 2 * t * t : -1 + (4 - 2 * t) * t,
    };

    // ========= Timeline2（内部クロック + 複数Track）=========
    class Timeline {
        constructor({ length = 120, loop = false } = {}) {
            this.length = length;     // 総フレーム（or tick）
            this.loop = loop;
            this.time = 0;
            this.paused = false;
            this.tracks = [];
            this.tags = new Set(["eventStopper"]); // 必要なら既存タグ運用に合わせる
        }
        onAttach(master) {        // GM.addChild が呼んでくれる
            this.master = master;
        }
        addTrack(track) { this.tracks.push(track); return this; }
        reset() {
            this.time = 0;
            this.finished = false
            this.tracks.forEach(e => {
                e.reset()
            })
        }
        update() {
            if (this.paused) return;
            this.time++;
            if (this.time > this.length) {
                if (this.loop) { this.time = 0; this.onLoop?.(); }
                else {
                    this.time = this.length; this.onComplete?.();
                    this.destroy(); return
                }
            }

            const t = this.time;
            for (const tr of this.tracks) tr.update(t);
        }
        process() {
            return this.time / this.length
        }
        draw() {
            // draw time line process bar
            const thickness = 14
            const pos = Math.min(1, Math.sin(this.process() * Math.PI) * 8) * thickness
            c.fillStyle = 'black'
            c.fillRect(0, h - pos, w, thickness)
            c.fillStyle = 'rgba(0,128,255,1)'
            c.fillRect(0, h - pos, this.process() * w, thickness)
        }
        destroy() {
            console.log('destroying')
            if (this.finished) return;
            this.finished = true;
            // 親の updateList から自分を除去
            const parent = this.master;
            GM.setTagPause('CSStop', false)

            parent.removeByTag('eventStopper')
            /* sss */
        }
    }

    // ========= KeyframeTrack（keys/steps対応）=========
    // keys: [{t:0, v:100, ease:ease.outQuad}, {t:60, v:250}, {t:90, v:250, interpolation:'hold'}]
    class KeyframeTrack {
        // getter/setter か、target & path（"position.x"みたいな）を渡す
        constructor({
            getter, setter,
            target = null, path = null,
            keys = [],                 // 時間はtimeline基準のフレーム/カウント
            defaultEase = ease.linear, // 未指定キーの補間
        }) {
            // アクセス方法を用意
            if (!getter || !setter) {
                if (!target || !path) throw new Error("KeyframeTrack: getter/setter か target+path を渡してね");
                const parts = path.split(".");
                getter = () => parts.reduce((o, k) => o[k], target);
                setter = (val) => {
                    const last = parts.slice(0, -1).reduce((o, k) => o[k], target);
                    last[parts[parts.length - 1]] = val;
                };
            }
            this.getter = getter;
            this.setter = setter;
            // キーを t 昇順に
            this.keys = keys.slice().sort((a, b) => a.t - b.t);
            this.defaultEase = defaultEase;
            this._lastIndex = -1; // step/hook用で必要なら使う
        }
        reset() {
            this._lastIndex = -1
        }

        update(t) {
            if (this.keys.length === 0) return;

            // 範囲外（前/後）
            if (t <= this.keys[0].t) {
                this.setter(this.keys[0].v, this.getter());
                return;
            }
            const K = this.keys;
            const last = K[K.length - 1];
            if (t >= last.t) {
                this.setter(last.v, this.getter());
                return;
            }

            // 区間を探す（t_i <= t < t_{i+1}）
            let i = (this._lastIndex >= 0 && this._lastIndex < K.length - 1) ? this._lastIndex : 0;

            // 前フレームからの継続探索をするなら _lastIndex を使って微最適化も可
            for (; i < K.length - 1; i++) {
                if (t >= K[i].t && t < K[i + 1].t) break;
            }

            this._lastIndex = i

            const key0 = K[i], key1 = K[i + 1];

            // ステップ（hold）指定があれば v = k0.v で維持
            if (key0.interpolation === "hold") {
                this.setter(key0.v, this.getter());
                return;
            }

            // 線形 or イージング補間
            const ease = key0.ease || this.defaultEase;
            const span = Math.max(1, (key1.t - key0.t)) // 0で割ることを防ぐ
            let process = clamp01((t - key0.t) / span);
            process = ease(process);

            const v = lerp(key0.v, key1.v, process);
            this.setter(v, this.getter());
        }
    }


    scene = {
        1: {
            init: () => {
                GM.reset()
                console.log('scene 1 init')

                const testEvent = {
                    update: function () {
                        console.log('now playing test event, all player should be stopped')
                    },


                }

                GM.registry.set("testWorld", new BlockWorld());

                GM.registry.set("charA", new Player3D(GM.registry.get('testWorld')));
                GM.registry.set("testControl", new Controller3D(GM.registry.get('charA')));

                GM.registry.get('testControl').tags.add('eventStop')
                GM.registry.get('charA').updateList.push(GM.registry.get('testControl'))

                GM.registry.set('ccamera', new Camera2_5(GM.registry.get('charA')))
                GM.registry.get('ccamera').drawList.push(GM.registry.get('testWorld'))
                GM.registry.get('ccamera').drawList.push(GM.registry.get('charA'))

                GM.updateList.push(GM.registry.get('testWorld'))
                GM.updateList.push(GM.registry.get('ccamera'))
                GM.updateList.push(GM.registry.get('charA'))

                GM.drawList.push(GM.registry.get('ccamera'))




            }
        }
    }

</script>


<script id="key mapping">
    // EventID好きなだけ追加
    const eventID = new Proxy({}, (() => {
        let currentID = 0;
        const map = new Map();
        return {
            get(target, prop) {

                if (typeof prop === "symbol") return undefined;
                if (!map.has(prop)) {
                    map.set(prop, currentID++);
                }
                return map.get(prop);
            },
            ownKeys() {
                return Array.from(map.keys());
            },
        };
    })());

    // if(keys.xxx.pressed)これをGameLoopに入れたら連続発火

    const keyMap = {
        'a': 'left',
        'd': 'right',
        'w': 'up',
        's': 'down',
        'i': 'parry',
        'j': 'attack',
        'k': 'jump',
        'l': 'camera_radius_down',
        ' ': 'shot',
        'q': 'switch',
        'e': 'switch2'
    }

    // 必要なキーだけ登録すればOK
    const onPressHandlers = {
        up: () => {

        },
        down: () => {
        },
        left: () => {
        },
        right: () => {
        },
        shot: () => {

        }
    }

    const onReleasehandlers = {
        left: () => {
        },
        right: () => {
        },
        shot: () => {
        }
    }

    // the event list


</script>

<script>

    keyMap.q = 'turnLeft'
    keyMap.e = 'turnRight'
    // all in canvas coordination, unit 1 meter
    // block size 1 meter
    // ===== Player =====
    const player = {
        id: 'player',
        angle: Math.PI / 2,
        px: 13.5,
        py: 3.5,
        pz: 0,
        sizex: 10,
        sizey: 10,
        moveSpeed: 0.04,
        rotSpeed: 0.02,
        world: null,
        update: function () {
            //const dt = Math.min(0.033, (now - last) * 0.001);
            //last = now;
            if (this.angle < 0) {
                this.angle *= -1
                this.angle %= Math.PI * 2
                this.angle = Math.PI * 2 - this.angle
            } else {
                this.angle %= Math.PI * 2
            }
            if (!this.world) return console.log('player need world!')
            if (keys == undefined) return console.log('player waiting for key Event')
            const
                _fwdx = Math.cos(this.angle),
                _fwdy = Math.sin(this.angle);
            const
                _rightx = Math.cos(this.angle + Math.PI / 2),
                _righty = Math.sin(this.angle + Math.PI / 2);

            let mx = 0, my = 0;
            if (keys.up.pressed) { mx += _fwdx; my += _fwdy; }
            if (keys.down.pressed) { mx -= _fwdx; my -= _fwdy; }
            if (keys.left.pressed) { mx -= _rightx; my -= _righty; }
            if (keys.right.pressed) { mx += _rightx; my += _righty; }

            const mag = Math.hypot(mx, my) || 1;
            mx /= mag;
            my /= mag;

            const step = this.moveSpeed * (keys['AltLeft'] ? 1.7 : 1.0) //* dt;

            const npx = this.px + mx * step, npy = this.py + my * step;
            if (!this.world.atPos(Math.floor(npx), Math.floor(this.py))) this.px = npx;
            if (!this.world.atPos(Math.floor(this.px), Math.floor(npy))) this.py = npy;

            if (keys.turnLeft.pressed) this.angle -= this.rotSpeed //* dt;
            if (keys.turnRight.pressed) this.angle += this.rotSpeed //* dt;

        },
        draw: function () {

        }
    }


    class SpriteAsset extends GameObject {
        constructor(sprite = { tex, size, color: 'white' }, px = 3, py = 3, pz = 0, inverted = false, height) {
            super()
            this.id = 'sprite'
            this.px = px
            this.py = py
            this.pz = pz
            this.sprite = sprite
            this.inverted = inverted
            this.height = height
        }
        draw() {

        }
    }
    const world2_6 = {
        id: 'world',
        map: worldMap,
        ceil_tex: checkerTex,
        floor_tex: checkerTex,
        _floorZ: 0,
        _ceilZ: 1,
        width: 16,
        height: 16,
        fogColor: [255, 200, 255], // 空色
        atPos: (x, y) => (x < 0 || y < 0 || x >= world2_6.width || y >= world2_6.height) ? 0 : world2_6.map[y * world2_6.width + x] | 0

    }

    class RayCasterCamera extends GameObject {
        constructor(target, world, show2D) {
            super()
            this.id = 'camera'
            this.px = 0
            this.py = 0
            this.pz = 0
            this.FOV = Math.PI / 3// angle of view
            this.sample_width = 4//2 とかちょっと重たくなる
            this.sample_height = 2
            this.eyeHeight = 0.4
            this.eyeZ = 0.4
            this.followSpeed = 0.04
            this.target = target                // 目線高さ（床=0 からの相対）
            this.world = world // 参照するworld
            this.show2D = show2D
            this.hits = []
        }

        update() {
            if (!this.target || !this.world) return
            this.pz = this.target.pz
            this.eyeZ = this.pz + this.eyeHeight
            const deltaX = this.target.px - this.px
            const deltaY = this.target.py - this.py
            if (Math.abs(deltaX) > 0.01)
                this.px += (deltaX) * this.followSpeed
            else
                this.px = this.target.px
            if (Math.abs(deltaY) > 0.01)
                this.py += (deltaY) * this.followSpeed
            else
                this.py = this.target.py
        }
        draw() {


            // target check
            // draw BG
            // z-buffer reset
            // cast 2D ray for loop 
            //    check and draw wall, ceil, floor
            //    check and draw sprites  
            const dot = (a, b) => a.x * b.x + a.y * b.y;
            const sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });
            const cross = (a, b) => a.x * b.y - a.y * b.x;

            if (!this.target || !this.world) {
                this.drawPause = true
                console.log('camera waiting for target assign')
                return
            }

            if (this.show2D)
                this.Render2DView()

            // --- draw background ---

            // z-buffer reset
            if (!this.zbuf || this.zbuf.length !== w) this.zbuf = new Float32Array(w);
            this.zbuf.fill(Infinity);

            // focal length pre-compute
            // 1フレーム1回だけ
            const FocalLength = this.getFocalLength()

            // draw World
            for (let _x = 0; _x < w; _x += this.sample_width) {
                const ray_angle = (_x / w - 0.5) * this.FOV; // (-0.5~0.5) *FOV
                const true_ray_angle = this.target.angle + ray_angle;
                const
                    dx = Math.cos(true_ray_angle),
                    dy = Math.sin(true_ray_angle) // all in canvas coordination, inverted y!

                // DDA（原点オフセットで自己衝突回避）
                const hit = this.raycast2D(this.px + dx * 1e-4, this.py + dy * 1e-4, dx, dy);

                if (this.show2D) {

                    const sw = w0 / this.world.width
                    const sh = h0 / this.world.height

                    drawLine(c2,
                        sw * (this.px + dx * 1e-4),
                        sw * (this.py + dy * 1e-4),
                        sw * (this.px + dx * hit.dist),
                        sw * (this.py + dy * hit.dist),
                        'white', 1
                    )
                }


                if (!hit.hit) continue; // 壁に当たらないとレンダリングしないようにしてうる
                const distWall = Math.max(1e-6, hit.dist * Math.cos(ray_angle))



                // ⊥距離（魚眼補正 Ver
                let perpDistance = Math.max(1e-6, hit.dist * Math.cos(ray_angle));
                //let perp_d = Math.max(1e-6, hit.dist);
                //

                // 列が sample_width ピッチなので、該当する画面xに深度を入れておく
                for (let _xi = _x; _xi < Math.min(w, _x + this.sample_width); _xi++) {
                    // 近いもの優先で最小を保持
                    if (perpDistance < this.zbuf[_xi]) this.zbuf[_xi] = perpDistance;
                }

                // セルの floorZ/ceilZ（今回は floorZ=0, ceilZ=height）
                this.world._floorZ = 0.0;
                this.world._ceilZ = 1;//これでシーンの高さを変えれる

                // ★ 正しい投影：上端/下端を別々に計算
                const yTop = (h / 2) - ((this.world._ceilZ - this.eyeZ) * FocalLength) / perpDistance;
                const yBot = (h / 2) + ((this.eyeZ - this.world._floorZ) * FocalLength) / perpDistance;

                // クリップ
                const y0 = Math.max(0, Math.min(h - 1, yTop | 0));
                const y1 = Math.max(0, Math.min(h, yBot | 0));
                //const y0 = yTop
                //const y1 = yBot
                const lineH = y1 - y0
                if (lineH <= 0) continue;

                // 色（マテリアル）＋ 面向きで陰
                // ここはまあ、Lightingもできればやってみたいけど
                const fog_depth = Math.min(1, hit.dist / 16)
                const fog_color = [122, 200, 255]
                const shade = hit.side ? 0.45 : 1.0;

                let tex_info = {
                    tex: checkerTex,
                    size: 32,
                    wall: true,
                }
                let col = [255, 200, 100];
                if (hit.id != 4) {

                    if (hit.id === 1) col = [0, 120, 0];
                    if (hit.id === 2) col = [230, 210, 30];
                    if (hit.id === 3) {
                        tex_info.tex = Monitor16
                        tex_info.size = 16
                        col = [40, 160, 255];
                    }

                    c.fillStyle = `rgb(
            ${(this.lerp(fog_depth, col[0] * shade, fog_color[0])) | 0},
            ${(this.lerp(fog_depth, col[1] * shade, fog_color[1])) | 0},
            ${(this.lerp(fog_depth, col[2] * shade, fog_color[2])) | 0})`;
                    c.fillRect(_x, y0, this.sample_width, y1 - y0);
                } else {
                    tex_info.tex = window8
                    tex_info.size = 8
                }

                const wx = this.px + dx * hit.dist; // ヒット世界座標
                const wy = this.py + dy * hit.dist;
                const u =
                    hit.side ?
                        (hit.dir.y < 0 ? wx - Math.floor(wx) : 1 - wx + Math.floor(wx)) :
                        (hit.dir.x > 0 ? wy - Math.floor(wy) : 1 - wy + Math.floor(wy))

                if (yBot < yTop) return
                const blendFogColor = `rgb(
                            ${this.lerp(fog_depth, col[0], fog_color[0])},
                            ${this.lerp(fog_depth, col[1], fog_color[1])},
                            ${this.lerp(fog_depth, col[2], fog_color[2])})`
                this.UVSampleStrand(tex_info.tex, tex_info.size, blendFogColor,
                    _x, y0, y1,
                    yTop, yBot,
                    u)





                // ====== ★ FLOOR CAST: 壁の下の床をサンプリング ======
                // 逆投影の定数（列ごとに一定）
                const Kfloor = (this.eyeZ - this.world._floorZ) * FocalLength; // eyeZから床までのスケール

                // 床は y1(=壁下端) から画面下端まで
                for (let _y = y1; _y < h; _y += this.sample_height) {
                    // 画面行 y → 垂直距離 d_perp
                    const denom = (_y) - h / 2;             // ピクセル中心 (+0.5 推奨)
                    if (denom <= 0) continue;
                    const dPerpFloor = Kfloor / denom; // Key: dist = (eyeZ-floorZ)*Focallength/(y-H/2)
                    const dRay = dPerpFloor / Math.cos(ray_angle) // 画面⊥距離から実距離（魚眼補正逆変換）
                    //const dRay = dPerpFloor;          


                    // 世界座標（同じレイ方向）
                    const fx = this.px + dx * dRay;
                    const fy = this.py + dy * dRay;
                    // タイル繰り返しUV（0..1）
                    const u = fx - Math.floor(fx);
                    const v = fy - Math.floor(fy);
                    // 例：32x32のチェッカーからサンプル
                    //const iu = (u * 32) | 0;
                    //const iv = (v * 32) | 0;
                    //const on = checkerTex[(iv & 31) * 32 + (iu & 31)];
                    const on = this.UVSampling(this.world.floor_tex, u, v, 32)

                    // 簡単なフォグ（距離で空色へ寄せる）
                    const fog = Math.min(1, dPerpFloor / 16);
                    let r = on ? 0 : 10, g = on ? 0 : 80, b = on ? 0 : 122; // 地面のベース色
                    r = ((1 - fog) * r + fog * this.world.fogColor[0]) | 0;
                    g = ((1 - fog) * g + fog * this.world.fogColor[1]) | 0;
                    b = ((1 - fog) * b + fog * this.world.fogColor[2]) | 0;

                    c.fillStyle = `rgb(${r},${g},${b})`;
                    c.fillRect(_x, _y, this.sample_width, this.sample_height);
                }


                // ====== ★ CEIL CAST: 天井をサンプリング ======
                const CeilOffset = 0
                const KCeil = (this.world._ceilZ + CeilOffset - this.eyeZ) * FocalLength; // eyeZから床までのスケール

                for (let _y = y0 - this.sample_height; _y > 0; _y -= this.sample_height) {
                    // 画面行 y → 垂直距離 d_perp
                    const denom = h / 2 - (_y);             // ピクセル中心 
                    if (denom <= 0) continue;
                    const dPerpFloor = KCeil / denom; // Key: dist = (eyeZ-floorZ)*Focallength/(y-H/2)
                    const dRay = dPerpFloor / Math.cos(ray_angle) // 魚眼補正逆変換
                    //const dRay = dPerpFloor;          

                    // 世界座標（同じレイ方向）からタイル繰り返しUV（0..1）
                    const fx = this.px + dx * dRay;
                    const fy = this.py + dy * dRay;
                    const u = fx - Math.floor(fx)
                    const v = fy - Math.floor(fy)
                    const sampleCeil = this.UVSampling(ceilMap16, fx / 16, fy / 16, 16)
                    if (sampleCeil > 0) {

                        // 例：32x32のチェッカーからサンプル
                        const on = this.UVSampling(this.world.ceil_tex, u, v, 32)

                        // 簡単なフォグ（距離で空色へ寄せる）
                        const fog = Math.min(1, dPerpFloor / 16);
                        const col = [10, 10, 10]
                        let r = on ? 122 : col[0], g = on ? 120 : col[1], b = on ? 80 : col[2]; // 地面のベース色
                        r = ((1 - fog) * r + fog * this.world.fogColor[0]) | 0;
                        g = ((1 - fog) * g + fog * this.world.fogColor[1]) | 0;
                        b = ((1 - fog) * b + fog * this.world.fogColor[2]) | 0;

                        c.fillStyle = `rgb(${r},${g},${b})`;
                        c.fillRect(_x, _y, this.sample_width, this.sample_height);
                    } else {
                    }
                } // end of Draw ceiling for




                GM.flatDrawList.forEach(_s => {
                    if (_s.id != 'sprite') return
                    const ca = Math.cos(this.target.angle), sa = Math.sin(this.target.angle)
                    const vx = _s.px - this.px, vy = _s.py - this.py
                    const depth = vx * ca + vy * sa
                    if (depth <= 1e-4 || depth >= distWall) return

                    const side = vx * (-sa) + vy * ca
                    const sideX = w / 2 + side * FocalLength / depth
                    const billHeight = (_s.height || 1.0) * FocalLength / depth
                    const billWidth = billHeight * (_s.aspect || 1.0)

                    const x0 = sideX - billWidth / 2, x1 = sideX + billWidth / 2
                    if (_x < x0 || _x > x1) return // out of billborad range

                    let yBot, yTop, y0, y1
                    if (_s.inverted) {
                        yTop = h / 2 + ((this.eyeZ - (_s.pz || 0)) * FocalLength / depth)
                        yBot = yTop + billHeight
                        y0 = Math.max(0, Math.min(h - 1, yTop | 0));
                        y1 = Math.max(0, Math.min(h, yBot | 0));
                    } else {

                        yBot = h / 2 + ((this.eyeZ - (_s.pz || 0)) * FocalLength / depth)
                        yTop = yBot - billHeight
                        y0 = Math.max(0, Math.min(h - 1, yTop | 0));
                        y1 = Math.max(0, Math.min(h, yBot | 0));
                    }

                    if (y1 > y0) {
                        const u = (_x - x0) / (x1 - x0)

                        this.zbuf[_x] = depth;

                        this.UVSampleStrand(
                            _s.sprite.tex, _s.sprite.size, _s.sprite.color,
                            _x, y0, y1,
                            yTop, yBot,
                            u

                        )
                        // さらに手前のものが勝てるよう更新
                    }
                })


                // ray sample sign
                const fwdx = Math.cos(this.target.angle), fwdy = Math.sin(this.target.angle)

                for (const _sign of signs) {
                    const hitSign = this.intersectRaySegment(
                        { x: this.px, y: this.py }, { x: dx, y: dy },
                        { x: _sign.ax, y: _sign.ay }, { x: _sign.bx, y: _sign.by }
                    )
                    if (!hitSign.hit) continue

                    //
                    const Px = this.px + hitSign.t * dx, Py = this.py + hitSign.t * dy
                    const dotDistance = (Px - this.px) * fwdx + (Py - this.py) * fwdy
                    const distSign = Math.max(1e-6, dotDistance)

                    if (distSign >= this.zbuf[_x]) continue

                    const yTop = h / 2 - ((_sign.ceilZ - this.eyeZ) * FocalLength) / distSign
                    const yBot = h / 2 + ((this.eyeZ - _sign.floorZ) * FocalLength) / distSign
                    const y0 = Math.max(0, Math.min(h - 1, yTop | 0))
                    const y1 = Math.max(0, Math.min(h, yBot | 0))
                    if (y0 < y1) {
                        c.fillStyle = 'purple'
                        c.fillRect(_x, y0, this.sample_width, y1 - y0)
                        this.zbuf[_x] = distSign
                    }

                    this.UVSampleStrand(checkerTex, 32, 'pink',
                        _x, y0, y1,
                        yTop, yBot,
                        hitSign.s,
                    )

                } // end of sign 



            } // end of for 



        }


        draw() {


            // target check
            // draw BG
            // z-buffer reset
            // cast 2D ray for loop 
            //    check and draw wall, ceil, floor
            //    check and draw sprites  
            const dot = (a, b) => a.x * b.x + a.y * b.y;
            const sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });
            const cross = (a, b) => a.x * b.y - a.y * b.x;

            if (!this.target || !this.world) {
                this.drawPause = true
                console.log('camera waiting for target assign')
                return
            }

            if (this.show2D)
                this.Render2DView()

            // --- draw background ---

            // z-buffer reset
            if (!this.zbuf || this.zbuf.length !== w) this.zbuf = new Float32Array(w);
            this.zbuf.fill(Infinity);

            // focal length pre-compute
            // 1フレーム1回だけ
            const FocalLength = this.getFocalLength()

            // draw World
            for (let _x = 0; _x < w; _x += this.sample_width) {
                const ray_angle = (_x / w - 0.5) * this.FOV; // (-0.5~0.5) *FOV
                const true_ray_angle = this.target.angle + ray_angle;
                const
                    dx = Math.cos(true_ray_angle),
                    dy = Math.sin(true_ray_angle) // all in canvas coordination, inverted y!

                // DDA（原点オフセットで自己衝突回避）
                const hit = this.raycast2D(this.px + dx * 1e-4, this.py + dy * 1e-4, dx, dy);

                if (this.show2D) {

                    const sw = w0 / this.world.width
                    const sh = h0 / this.world.height

                    drawLine(c2,
                        sw * (this.px + dx * 1e-4),
                        sw * (this.py + dy * 1e-4),
                        sw * (this.px + dx * hit.dist),
                        sw * (this.py + dy * hit.dist),
                        'white', 1
                    )
                }


                if (!hit.hit) continue; // 壁に当たらないとレンダリングしないようにしてうる

                const distWall = Math.max(1e-6, hit.dist * Math.cos(ray_angle))
                let yTopWall = 0, yBotWall = h


                // ⊥距離（魚眼補正 Ver
                let perpDistance = Math.max(1e-6, hit.dist * Math.cos(ray_angle));
                //let perp_d = Math.max(1e-6, hit.dist);
                //

                // 列が sample_width ピッチなので、該当する画面xに深度を入れておく
                for (let _xi = _x; _xi < Math.min(w, _x + this.sample_width); _xi++) {
                    // 近いもの優先で最小を保持
                    if (perpDistance < this.zbuf[_xi]) this.zbuf[_xi] = perpDistance;
                }

                // セルの floorZ/ceilZ（今回は floorZ=0, ceilZ=height）
                this.world._floorZ = 0.0;
                this.world._ceilZ = 1;//これでシーンの高さを変えれる

                // ★ 正しい投影：上端/下端を別々に計算
                const yTop = (h / 2) - ((this.world._ceilZ - this.eyeZ) * FocalLength) / perpDistance;
                const yBot = (h / 2) + ((this.eyeZ - this.world._floorZ) * FocalLength) / perpDistance;

                yTopWall = yTop
                yBotWall = yBot

                // クリップ
                const y0 = Math.max(0, Math.min(h - 1, yTop | 0));
                const y1 = Math.max(0, Math.min(h, yBot | 0));
                //const y0 = yTop
                //const y1 = yBot
                const lineH = y1 - y0
                if (lineH <= 0) continue;

                // 色（マテリアル）＋ 面向きで陰
                // ここはまあ、Lightingもできればやってみたいけど
                const fog_depth = Math.min(1, hit.dist / 16)
                const fog_color = [122, 200, 255]
                const shade = hit.side ? 0.45 : 1.0;

                let tex_info = {
                    tex: checkerTex,
                    size: 32,
                    wall: true,
                }
                let col = [255, 200, 100];
                if (hit.id != 4) {

                    if (hit.id === 1) col = [0, 120, 0];
                    if (hit.id === 2) col = [230, 210, 30];
                    if (hit.id === 3) {
                        tex_info.tex = Monitor16
                        tex_info.size = 16
                        col = [40, 160, 255];
                    }

                    c.fillStyle = `rgb(
            ${(this.lerp(fog_depth, col[0] * shade, fog_color[0])) | 0},
            ${(this.lerp(fog_depth, col[1] * shade, fog_color[1])) | 0},
            ${(this.lerp(fog_depth, col[2] * shade, fog_color[2])) | 0})`;
                    c.fillRect(_x, y0, this.sample_width, y1 - y0);
                } else {
                    tex_info.tex = window8
                    tex_info.size = 8
                }

                const wx = this.px + dx * hit.dist; // ヒット世界座標
                const wy = this.py + dy * hit.dist;
                const u =
                    hit.side ?
                        (hit.dir.y < 0 ? wx - Math.floor(wx) : 1 - wx + Math.floor(wx)) :
                        (hit.dir.x > 0 ? wy - Math.floor(wy) : 1 - wy + Math.floor(wy))

                if (yBot < yTop) return
                const blendFogColor = `rgb(
                            ${this.lerp(fog_depth, col[0], fog_color[0])},
                            ${this.lerp(fog_depth, col[1], fog_color[1])},
                            ${this.lerp(fog_depth, col[2], fog_color[2])})`
                this.UVSampleStrand(tex_info.tex, tex_info.size, blendFogColor,
                    _x, y0, y1,
                    yTop, yBot,
                    u)





                // ====== ★ FLOOR CAST: 壁の下の床をサンプリング ======
                // 逆投影の定数（列ごとに一定）
                const Kfloor = (this.eyeZ - this.world._floorZ) * FocalLength; // eyeZから床までのスケール

                // 床は y1(=壁下端) から画面下端まで
                for (let _y = y1; _y < h; _y += this.sample_height) {
                    // 画面行 y → 垂直距離 d_perp
                    const denom = (_y) - h / 2;             // ピクセル中心 (+0.5 推奨)
                    if (denom <= 0) continue;
                    const dPerpFloor = Kfloor / denom; // Key: dist = (eyeZ-floorZ)*Focallength/(y-H/2)
                    const dRay = dPerpFloor / Math.cos(ray_angle) // 画面⊥距離から実距離（魚眼補正逆変換）
                    //const dRay = dPerpFloor;          


                    // 世界座標（同じレイ方向）
                    const fx = this.px + dx * dRay;
                    const fy = this.py + dy * dRay;
                    // タイル繰り返しUV（0..1）
                    const u = fx - Math.floor(fx);
                    const v = fy - Math.floor(fy);
                    // 例：32x32のチェッカーからサンプル
                    //const iu = (u * 32) | 0;
                    //const iv = (v * 32) | 0;
                    //const on = checkerTex[(iv & 31) * 32 + (iu & 31)];
                    const on = this.UVSampling(this.world.floor_tex, u, v, 32)

                    // 簡単なフォグ（距離で空色へ寄せる）
                    const fog = Math.min(1, dPerpFloor / 16);
                    let r = on ? 0 : 10, g = on ? 0 : 80, b = on ? 0 : 122; // 地面のベース色
                    r = ((1 - fog) * r + fog * this.world.fogColor[0]) | 0;
                    g = ((1 - fog) * g + fog * this.world.fogColor[1]) | 0;
                    b = ((1 - fog) * b + fog * this.world.fogColor[2]) | 0;

                    c.fillStyle = `rgb(${r},${g},${b})`;
                    c.fillRect(_x, _y, this.sample_width, this.sample_height);
                }


                // ====== ★ CEIL CAST: 天井をサンプリング ======
                const CeilOffset = 0
                const KCeil = (this.world._ceilZ + CeilOffset - this.eyeZ) * FocalLength; // eyeZから床までのスケール

                for (let _y = y0 - this.sample_height; _y > 0; _y -= this.sample_height) {
                    // 画面行 y → 垂直距離 d_perp
                    const denom = h / 2 - (_y);             // ピクセル中心 
                    if (denom <= 0) continue;
                    const dPerpFloor = KCeil / denom; // Key: dist = (eyeZ-floorZ)*Focallength/(y-H/2)
                    const dRay = dPerpFloor / Math.cos(ray_angle) // 魚眼補正逆変換
                    //const dRay = dPerpFloor;          

                    // 世界座標（同じレイ方向）からタイル繰り返しUV（0..1）
                    const fx = this.px + dx * dRay;
                    const fy = this.py + dy * dRay;
                    const u = fx - Math.floor(fx)
                    const v = fy - Math.floor(fy)
                    const sampleCeil = this.UVSampling(ceilMap16, fx / 16, fy / 16, 16)
                    if (sampleCeil > 0) {

                        // 例：32x32のチェッカーからサンプル
                        const on = this.UVSampling(this.world.ceil_tex, u, v, 32)

                        // 簡単なフォグ（距離で空色へ寄せる）
                        const fog = Math.min(1, dPerpFloor / 16);
                        const col = [10, 10, 10]
                        let r = on ? 122 : col[0], g = on ? 120 : col[1], b = on ? 80 : col[2]; // 地面のベース色
                        r = ((1 - fog) * r + fog * this.world.fogColor[0]) | 0;
                        g = ((1 - fog) * g + fog * this.world.fogColor[1]) | 0;
                        b = ((1 - fog) * b + fog * this.world.fogColor[2]) | 0;

                        c.fillStyle = `rgb(${r},${g},${b})`;
                        c.fillRect(_x, _y, this.sample_width, this.sample_height);
                    } else {
                    }
                } // end of Draw ceiling for


                const hits = this.collectColumnSprites(_x, distWall, true_ray_angle, FocalLength)

                const ZNew = this.renderColumnFromHits(_x, hits, distWall, yTopWall, yBotWall)



            } // end of for 



        }


        // only for billborads and signs


        collectColumnSprites(_x, distWall, true_ray_angle, FocalLength) {
            this.hits.length = 0
            const hits = this.hits

            {
                const ca = Math.cos(this.target.angle), sa = Math.sin(this.target.angle)
                GM.flatDrawList.forEach(spr => {
                    if (spr.id != 'sprite') return

                    const vx = spr.px - this.px, vy = spr.py - this.py
                    const depth = vx * ca + vy * sa
                    if (depth <= 1e-4 || depth >= distWall) return

                    const side = vx * (-sa) + vy * ca
                    const sideX = w / 2 + side * FocalLength / depth
                    const billHeight = (spr.height || 1.0) * FocalLength / depth
                    const billWidth = billHeight * (spr.aspect || 1.0)

                    const x0 = sideX - billWidth / 2, x1 = sideX + billWidth / 2
                    if (_x < x0 || _x > x1) return // out of billborad range

                    let yBot, yTop, y0, y1
                    if (spr.inverted) {
                        yTop = h / 2 + ((this.eyeZ - (spr.pz || 0)) * FocalLength / depth)
                        yBot = yTop + billHeight
                        y0 = Math.max(0, Math.min(h - 1, yTop | 0));
                        y1 = Math.max(0, Math.min(h, yBot | 0));
                    } else {

                        yBot = h / 2 + ((this.eyeZ - (spr.pz || 0)) * FocalLength / depth)
                        yTop = yBot - billHeight
                    }

                    const sprite = spr.sprite
                    const u = (_x - x0) / (x1 - x0)
                    hits.push({
                        depth: depth,
                        kind: 'sprite',
                        sprite: spr.sprite,
                        yTop: yTop, yBot: yBot,
                        u: u
                    })


                })
            }// end of collect sprite



            {
                const dir = { x: Math.cos(true_ray_angle), y: Math.sin(true_ray_angle) }
                const fwd = { x: Math.cos(this.target.angle), y: Math.sin(this.target.angle) }
                for (const s of signs) {
                    const e = { x: s.bx - s.ax, y: s.by - s.ay }
                    // if(s.oneSided)
                    const hitS = this.intersectRaySegment(
                        { x: this.px, y: this.py }, dir,
                        { x: s.ax, y: s.ay }, { x: s.bx, y: s.by }
                    )
                    if (!hitS.hit) continue

                    //
                    const Px = this.px + hitS.t * dir.x, Py = this.py + hitS.t * dir.y
                    const depth = (Px - this.px) * fwd.x + (Py - this.py) * fwd.y
                    if (depth <= 1e-4) continue

                    const yTop = h / 2 - ((s.ceilZ - this.eyeZ) * FocalLength) / depth
                    const yBot = h / 2 + ((this.eyeZ - s.floorZ) * FocalLength) / depth

                    const sprite = s.sprite
                    const u = hitS.s
                    hits.push({
                        depth: depth,
                        kind: 'sign',
                        sprite: s.sprite,
                        yTop: yTop, yBot: yBot,
                        u: u

                    })

                }
            } // end of 

            return hits
        }

        renderColumnFromHits(_x, hits, zbufX, yTopWall, yBotWall) {
            hits.sort((a, b) => b.depth - a.depth)


            for (const hit of hits) {
                if (hit.depth > zbufX) continue


                let y0 = Math.max(0, hit.yTop | 0);
                let y1 = Math.min(h, hit.yBot | 0);
                if (y1 <= y0) continue

                /*
                const isFront = hit.depth < zbufX
                 if (!isFront) {
        
                  const A0 = y0, A1 = Math.min(y1, yTopWall | 0)
                  const B0 = Math.max(y0, yBotWall | 0), B1 = y1
        
                  if (A1 > A0) {
                    c.globalAlpha = hit.alpha
                    c.fillStyle = hit.color
                    c.fillRect(_x, A0, this.sample_width, A1 - A0)
                  }
                  if (B1 > B0) {
                    c.globalAlpha = hit.alpha
                    c.fillStyle = hit.color
                    c.fillRect(_x, B0, this.sample_width, B1 - B0)
                  }
                  continue
                }// end of back */



                this.UVSampleStrand(
                    hit.sprite?.tex || checkerTex, hit.sprite?.size || 32, hit.sprite?.color || 'white',
                    _x, y0, y1,
                    hit.yTop, hit.yBot,
                    hit.u
                )

                zbufX = hit.depth
            }// end of h sample
            return zbufX
        }

        getFocalLength() {

            return (h / 2) / Math.tan(this.FOV / 2) * (w / h)  // 投影スケール
        }
        lerp(k, v1, v2) {
            return (1 - k) * v1 + k * v2
        }

        intersectRaySegment(O, d, A, B) {
            const cross = (a, b) => a.x * b.y - a.y * b.x;
            const sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y }); /* これは独立させておきたい */
            const e = sub(B, A);
            const denom = cross(d, e);
            if (Math.abs(denom) < 1e-9) return { hit: false };

            const AO = sub(A, O);
            const t = cross(AO, e) / denom;  // レイ側
            const s = cross(AO, d) / denom;  // 線分側(0..1)
            if (t > 1e-6 && s >= 0 && s <= 1) return { hit: true, t, s };

            return { hit: false };
        }
        UVSampling(tex, u, v, texSizeX, texSizeY = texSizeX) {
            const U = Math.floor(u * texSizeX)
            const V = Math.floor(v * texSizeY)
            return tex[V * texSizeX + U]
        }
        UVSampleStrand(
            _tex, _texSize, _color,
            _x, y0, y1,
            yTop, yBot,
            u,
            dotWidth = this.sample_width, dotHeight = this.sample_height
        ) {
            const strandHeight = y1 - y0
            for (let y = 0; y < strandHeight; y += dotHeight) {
                const v = (y0 + y - yTop) / (yBot - yTop) // FIX!!!
                //const checkerU = Math.floor(u * 32)
                //const checkerV = Math.floor(startV * 32)
                c.save()
                const on = this.UVSampling(_tex, u, v, _texSize)
                if (on == 1) {
                    c.fillStyle = _color

                    c.fillRect(_x, y0 + y, dotWidth, dotHeight)
                }
                else if (on == 0) {
                    c.fillStyle = 'black'
                    c.fillRect(_x, y0 + y, dotWidth, dotHeight)

                }
                c.restore()
            }
        }


        // 廃止予定
        draw_sprite() {

            /* if (this.show2D) {
              const sw = w0 / this.world.width
              const sh = h0 / this.world.height
              drawLine(c2, this.px * sw, this.py * sh, sprite.px * sw, sprite.py * sh, 'blue', 1)
            } */

            GM.flatDrawList.forEach(e => {
                if (e.id != 'sprite') return
                //projection
                const v0 = {
                    x: e.px - this.px,
                    y: e.py - this.py,
                    z: e.pz - this.eyeZ
                }

                // angleの回転方向は逆。。。。30分かかったかも
                const v1 = {
                    x: v0.x * Math.cos(this.target.angle) + v0.y * Math.sin(this.target.angle),
                    y: -v0.x * Math.sin(this.target.angle) + v0.y * Math.cos(this.target.angle),
                    z: v0.z
                }

                if (v1.x > 0) //カメラ前方にいる
                    c.fillStyle = 'yellow'
                else
                    return false

                // camera space
                const side = v1.y // camera.x
                const vertical = -v1.z // camera.y
                const depth = v1.x // -camera.z

                const FocalLength = this.getFocalLength()
                const v3 = {
                    x: (side / Math.max(1e-4, depth)) * FocalLength + w / 2,
                    y: (vertical / Math.max(1e-4, depth)) * FocalLength + h / 2,
                    z: -depth
                }


                c.fillRect(0, 0, 100, 10)
                /* if (v3.x < 0 || v3.x > W || v3.y < 0 || v3.y > H)
                  return false */

                const onScreenSize = e.height / depth * FocalLength

                // クリップ
                let x0, x1, y0, y1

                if (e.inverted) {
                    x0 = Math.floor(v3.x - onScreenSize / 2);
                    x1 = Math.floor(v3.x + onScreenSize / 2);
                    y0 = Math.floor(v3.y);
                    y1 = Math.floor(v3.y + onScreenSize);
                } else {
                    x0 = Math.floor(v3.x - onScreenSize / 2);
                    x1 = Math.floor(v3.x + onScreenSize / 2);
                    y0 = Math.floor(v3.y - onScreenSize);
                    y1 = Math.floor(v3.y + 0);

                }

                if (x1 <= 0 || x0 >= w) return;

                const cx0 = Math.max(0, x0);
                const cx1 = Math.min(w, x1);
                const cy0 = Math.max(0, y0);
                const cy1 = Math.min(h, y1);







                // 遮蔽比較：列ごとに depth(=d⊥) と zbuf[x] を比較して前にある時だけ描く
                c.fillStyle = e.color || 'orange';
                for (let x = cx0; x < cx1; x += this.sample_width) {
                    if (depth < this.zbuf[x]) {
                        // 本格はここでテクスチャ縦スライス描画（
                        const u = (x - x0) / onScreenSize
                        for (let y = cy0; y < cy1; y += this.sample_height) {
                            const v = (y - y0) / onScreenSize
                            const on = this.UVSampling(e.sprite.tex, u, v, e.sprite.size)
                            if (on == 0) {
                                c.fillStyle = 'black'
                                c.fillRect(x, y, this.sample_width, this.sample_height);
                            } else if (on == 1) {
                                c.fillStyle = 'white'
                                c.fillRect(x, y, this.sample_width, this.sample_height);

                            }


                        }
                    } else {
                        c.save()
                        c.fillStyle = '#87a7ff'
                        c.fillRect(x, y0, 3, y1 - y0);
                        c.restore()
                    }
                }


                //c.fillStyle = 'red'; c.fillRect(v3.x - 2, v3.y - 2, 4, 4)
            })


        }

        raycast2D(ox, oy, dx, dy, maxDist = 32) {
            // start position in grid system
            let mapX = Math.floor(ox), mapY = Math.floor(oy);
            const
                searchDirX = dx > 0 ? 1 : -1, // right or left
                searchDirY = dy > 0 ? 1 : -1; // down or up
            const
                _nextBlockX = mapX + (searchDirX > 0 ? 1 : 0), // 0 for the right side
                _nextBlockY = mapY + (searchDirY > 0 ? 1 : 0); // 0 for the bottom side

            const eps = 1e-9,
                invDx = 1 / (Math.abs(dx) < eps ? eps : dx),
                invDy = 1 / (Math.abs(dy) < eps ? eps : dy);
            const
                tDeltaX = Math.abs(invDx),// 常に一定
                tDeltaY = Math.abs(invDy);
            let
                nextBlockDistByX = (_nextBlockX - ox) * invDx, // tMaxX * Math.cos(ra) = (N-O)
                nextBlockDistByY = (_nextBlockY - oy) * invDy;

            // check if inside
            const id0 = this.world.atPos(mapX, mapY)
            if (id0) return {
                hit: true, dist: 0, id: id0,
                side: 0, dir: { x: searchDirX, y: searchDirY },
                cellX: mapX, cellY: mapY
            };

            let side = 0, dist = 0, hitId = 0;
            for (let i = 0; i < 128; i++) {
                // youtubeのは、XとY方向で全部終わってから比較する、こっちは交互でやる
                // move the check block position, update the dist
                if (nextBlockDistByX <= nextBlockDistByY) {
                    mapX += searchDirX;
                    dist = nextBlockDistByX;
                    nextBlockDistByX += tDeltaX;
                    side = 0;
                }
                else {
                    mapY += searchDirY;
                    dist = nextBlockDistByY;
                    nextBlockDistByY += tDeltaY;
                    side = 1;
                }

                if (dist > maxDist) break;

                hitId = this.world.atPos(mapX, mapY)
                if (hitId)
                    return {
                        hit: true, dist, id: hitId,
                        side, dir: { x: searchDirX, y: searchDirY },
                        cellX: mapX, cellY: mapY
                    };
            }

            // no hit
            return {
                hit: false, dist: maxDist, id: 0,
                side: 0, dir: { x: searchDirX, y: searchDirY },
                cellX: -1, cellY: -1
            };

        }
        Render2DView() {

            c2.fillStyle = 'grey'
            c2.fillRect(0, 0, w0, h0)
            const sw = w0 / this.world.width
            const sh = h0 / this.world.height
            for (let y = 0; y < this.world.height; y++) for (let x = 0; x < this.world.width; x++)
                if (this.world.map[x + y * this.world.width] > 0) {
                    c2.fillStyle = 'black'
                    c2.fillRect(x * sw + 1, y * sh + 1, sw - 1, sh - 1)
                }


            const arraylength = 20

            c2.beginPath();
            c2.arc(this.target.px * sw, this.target.py * sh, this.target.sizex / 2, 0, 2 * Math.PI)
            c2.fillStyle = "red"
            c2.fill()

            c2.beginPath();
            c2.arc(this.px * sw, this.py * sh, this.target.sizex / 2, 0, 2 * Math.PI)
            c2.fillStyle = "yellow"
            c2.fill()

            GM.flatDrawList.forEach(e => {
                if (e.id == 'sprite') {
                    c2.beginPath();
                    c2.arc(e.px * sw, e.py * sh, this.target.sizex / 2, 0, 2 * Math.PI)
                    c2.fillStyle = "blue"
                    c2.fill()
                }

            })


            drawLine(c2,
                this.target.px * sw,
                this.target.py * sh,
                this.target.px * sw + arraylength * Math.cos(this.target.angle),
                this.target.py * sh + arraylength * Math.sin(this.target.angle)
            )

        }

    }


    // ===== 2D DDA（セル座標とside返却）=====
    /*     
    ox, oy: レイの開始座標（プレイヤーの位置など）
    dx, dy: normalized ray vector (cosA,sinA)
    maxDist: 最大探索距離（安全のために打ち切る）
     */


    // ===== Render =====


    // 面描画
    const signs = [
        {
            ax: 12, ay: 5,   // 端点A
            bx: 12, by: 5.5,   // 端点B
            floorZ: 0.0,         // 下端高さ（床からのオフセット）
            ceilZ: 0.6,         // 上端高さ
            oneSided: true,      // 片面にする？
            sprite: {
                tex: Monitor16,
                size: 16,
                color: '#ffd54a'
            }
        },

        {
            ax: 12.04, ay: 5,   // 端点A
            bx: 12.04, by: 5.5,   // 端点B
            floorZ: 0.0,         // 下端高さ（床からのオフセット）
            ceilZ: 0.6,         // 上端高さ
            oneSided: true,      // 片面にする？
            sprite: {
                tex: Monitor16,
                size: 16,
                color: '#ffd54a'
            }
        },

        {
            ax: 12.8, ay: 6.6,   // 端点A
            bx: 10, by: 10,   // 端点B
            floorZ: 0.0,         // 下端高さ（床からのオフセット）
            ceilZ: 0.2,         // 上端高さ
            oneSided: true,      // 片面にする？
            color: '#ffd54a'
        }
    ];

    const billBoards = [
        {

        },
    ]

    const npc1 = [{
        txt: 'have a nice day my friend.\n and see you next time'
    }]


    // O + t*d と A + s*(B-A)



    // need target to follow the angle
    class PanoramaBG extends GameObject {
        constructor(url, target) {
            super()
            this.id = 'BG'
            this.iml = new ImageLoader(url)
            this.startOffset = 0
            this.drawLengthPropotion = 0.4
            this.drawHeightPosition = 1
            this.rotateAngle = 0
            this.target = target
            //this.drawPause = true
        }
        update() {
            if (this.target)
                this.rotateAngle = this.target.angle

        }
        draw() {
            if (!this.iml.loaded) return
            const img = this.iml.img
            const width = this.iml.img.width
            const height = this.iml.img.height
            const rotation_offset = this.rotateAngle * width / (Math.PI * 2)
            const startPos = this.startOffset % width + rotation_offset

            if (this.drawLengthPropotion < 0 || this.drawLengthPropotion > 1) return
            const drawLength = width * this.drawLengthPropotion
            if (startPos + drawLength > width) {
                const drawLength1 = width - startPos
                const drawEndPos1 = w * drawLength1 / drawLength
                c.drawImage(
                    img,
                    startPos, 0,
                    drawLength1, height * this.drawHeightPosition,
                    0, 0,
                    drawEndPos1, h * this.drawHeightPosition)
                c.drawImage(
                    img,
                    0, 0,
                    drawLength - drawLength1, height * this.drawHeightPosition,
                    drawEndPos1 - 1, 0,
                    w - drawEndPos1 + 1, h * this.drawHeightPosition)

            } else {
                c.drawImage(
                    img,
                    startPos, 0,
                    drawLength, height * this.drawHeightPosition,
                    0, 0,
                    w, h * this.drawHeightPosition)

            }
        }

    }




    // into GM!


    GM.addChild(new PanoramaBG('E:/Games/workspace/assets/BG/panorama_mountain.jpg', player))
    GM.addChild(player)
    player.world = world2_6
    GM.addChild(new RayCasterCamera(player, world2_6, true))
    GM.addChild(new SpriteAsset({ tex: ceilLight8, size: 8, color: 'white' }, 12, 12, 1, true, 0.2))
    GM.addChild(new SpriteAsset({ tex: ceilLight8, size: 8, color: 'white' }, 12, 10, 1, true, 0.2))
    GM.addChild(new SpriteAsset({ tex: ceilLight8, size: 8, color: 'white' }, 12, 8, 1, true, 0.2))
    GM.addChild(new SpriteAsset({ tex: ceilLight8, size: 8, color: 'white' }, 12, 6, 1, true, 0.2))
    GM.addChild(new SpriteAsset({ tex: ceilLight8, size: 8, color: 'white' }, 12, 4, 1, true, 0.2))
    GM.addChild(new SpriteAsset({ tex: Lily32, size: 32, color: 'blue' }, 12, 6, 0, false, 0.6))
    GM.addChild(new SpriteAsset({ tex: Lily32, size: 32, color: 'white' }, 12, 8, 0, false, 0.6))
    GM.addChild(new SpriteAsset({ tex: Lily32, size: 32, color: 'pink' }, 12, 10, 0, false, 0.6))

    //GM.addChild(new ListShower())


    let deltaTime = 0

    function gameLoop() {

        player.pz = 0.2 * Math.abs(Math.sin(deltaTime++ / 100))
        // --- update ---

        GM.update()

        GM.draw()


    }

</script>

</html>
