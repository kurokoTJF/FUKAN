<body></body>
<canvas id="canvas" width="500" height="300"></canvas>

<p>
    <button onmousedown="keyPress('atk')"> atk </button>
    <button onmousedown="keyPress('jump')"> jump </button>
    <button onmousedown="keyPress('left')"> left </button>
    <button onmousedown="keyPress('stop')"> stop </button>
    <button onmousedown="keyPress('right')"> right </button>

</p>

<p>
<div id="log">log</div>
</p>
<script>
    keyPress = function (key) {
        keys[key].pressed = true
    }

    const keys = new Proxy({}, {
        get(target, prop) {
            if (!(prop in target)) {
                target[prop] = { press: false, pressed: false };
            }
            return target[prop];
        }
    });

    // 使い捨て外部リクエスト、自由に追加できる。
    // 確認するたびにfalseにリセットされる
    const sample_request = new Proxy({}, {
        get: (target, prop) => {
            const value = target[prop];
            target[prop] = false; // 読んだら自動で false にする
            return value ?? false;
        }
    });

    // 未定義状態。自由に書き込める。デフォルト状態はfalse
    const sample_Tag = new Proxy({}, {
        get(target, prop) {
            return prop in target ? target[prop] : false;
        }
    })

    function log(msg) {
        document.getElementById("log").innerText += "\n_" + msg
    }

    function showHTML(MSG, ID) {
        let el = document.getElementById(ID);

        if (!el) {
            el = document.createElement('div');
            el.id = ID;

            const body = document.body;
            if (body.firstChild) {
                body.insertBefore(el, body.firstChild); // ← 先頭に挿入
            } else {
                body.appendChild(el); // ← 最悪何もないときは普通に追加
            }
        }

        el.innerText = MSG;
    }



    function getActiveTags(tagObj, separator = " ") {
        return Object.entries(tagObj)
            .filter(([_, v]) => v === true)
            .map(([k]) => k)
            .join(separator);
    }

    function equipThisWithProxy(target) {
        target.request = new Proxy({}, {
            get: (target, prop) => {
                const value = target[prop];
                target[prop] = false; // 読んだら自動で false にする
                return value ?? false;
            }
        });

        // 未定義状態。自由に書き込める。デフォルト状態はfalse
        target.Tag = new Proxy({}, {
            get(target, prop) {
                return prop in target ? target[prop] : false;
            }
        })
    }

    function equipThisWithEventHandler(target) {
        target.handlers = {}
        target.on = function (event, handler) {
            this.handlers[event] = handler
        }

        target.onRequest = function (eventName, target, ...args) {
            const handler = this.handlers[eventName]
            if (handler) handler(target, ...args)
        }
    }

    function equipThisWithEventManager(target) {
        target.eventQueue = []
        target.pushEvent = function (eName, ...args) {
            this.eventQueue.push([eName, ...args])
        }
        target.dealEvent = function (state) {
            for (const [ev, ...args] of this.eventQueue)
                state.onRequest(ev, this, ...args)
            this.eventQueue = []
        }
        target.resetEvent = function () {
            this.eventQueue = []
        }
        target.showEventQueue = function () {
            let str = ''
            for (const [ev, ...args] of this.eventQueue) {
                str += ev + ' '
            }
            return str
        }
    }
</script>

<script id="data"></script>

<script id="class">
    class Player {
        constructor(data) {
            this.position = { x: 200, y: 100 }
            this.width = 30
            this.height = 30
            this.deltaPosition = { x: 0, y: 0 }
            this.renderer = new movieRenderer(this)


        }
        update() {

            this.position.x += this.deltaPosition.x
            this.position.y += this.deltaPosition.y

            this.deltaPosition.y += 0.2
        }

        draw() {
            this.renderer.draw()

        }


    }

    class Tiles {
        constructor(ID) {
            this.position = { x: 20, y: 250 }
            this.width = 30
            this.height = 30
            if (ID == 'slop') {
                this.slopHeight = function () {
                    const rpx = player.position.x - this.position.x
                    const clampedX = Math.max(-player.width, Math.min(rpx, this.width));
                    if (player.position.y < this.position.y + this.height)
                        if (clampedX > -player.width && clampedX < this.width) {
                            return this.position.y + this.height - this.height / (this.width+player.width) * rpx
                        }
                    return this.position.y
                }
                this.draw = function () {
                    c.fillStyle = 'black'
                    c.beginPath()
                    c.moveTo(this.position.x, this.position.y + this.height)
                    c.lineTo(this.position.x + this.width, this.position.y + this.height)
                    c.lineTo(this.position.x + this.width, this.position.y)
                    c.closePath()
                    c.fill()
                }
            } else {
                this.draw = function () {
                    c.fillStyle = 'black'
                    c.fillRect(this.position.x, this.position.y, this.width, this.height)
                }
            }
        }

        hitTest(target){
            const py1 = target.position.y + target.height + target.deltaPosition.y
            const py2 = target.position.y + target.deltaPosition.y
            const px1 = target.position.x + target.width + target.deltaPosition.x
            const px2 = target.position.x + target.deltaPosition.x
            if (
                py1 > this.position.y &&
                py2 < this.position.y + this.height &&
                px1 > this.position.x &&
                px2 < this.position.x + this.width
            ) {

                const fromAbove = target.position.y + target.height <= this.position.y;
                const fromBelow = target.position.y >= this.position.y + this.height;
                const fromRight = target.position.x >= this.position.x + this.width;
                const fromLeft = target.position.x + target.width <= this.position.x;
                if (fromAbove) {
                    target.position.y = this.position.y - target.height
                    target.deltaPosition.y = 0
                } else if (fromBelow) {
                    target.position.y = this.position.y + this.height + 1
                    target.deltaPosition.y = 0

                } else if (fromRight) {
                    target.position.x = this.position.x + this.width
                    target.deltaPosition.x = 0

                } else if (fromLeft) {
                    target.position.x = this.position.x - target.width
                    target.deltaPosition.x = 0
                } else {
                    log('?!')
                    const centerfromAbove = target.position.y + target.height / 2 <= this.position.y + this.height / 2;
                    const centerfromBelow = target.position.y + target.height / 2 >= this.position.y + this.height / 2;
                    const centerfromRight = target.position.x + target.width / 2 >= this.position.x + this.width / 2;
                    const centerfromLeft = target.position.x + target.width / 2 <= this.position.x + this.width / 2;
                    if (centerfromAbove) {
                        target.position.y = this.position.y - target.height
                        target.deltaPosition.y = 0
                    } else if (centerfromBelow) {
                        target.position.y = this.position.y + this.height + 1
                        target.deltaPosition.y = 0

                    } else if (centerfromRight) {
                        target.position.x = this.position.x + this.width
                        target.deltaPosition.x = 0

                    } else if (centerfromLeft) {
                        target.position.x = this.position.x - target.width
                        target.deltaPosition.x = 0
                    }
                }
            }
        }

        update(target) {
            const y = this.position.y
            if (this.slopHeight) {
                this.position.y = this.slopHeight()
            }
            
            this.hitTest(target)

            this.position.y = y
        }


    }

    class movieRenderer {
        constructor(master) {
            this.master = master
        }

        draw() {
            c.fillStyle = 'grey'
            c.fillRect(this.master.position.x, this.master.position.y, this.master.width, this.master.height)

        }
    }
</script>



<script>
    const canvas = document.querySelector("canvas")
    const c = canvas.getContext("2d", { willReadFrequently: true })


    const player = new Player({})
    const terrain = new Tiles()
    terrain.width = 300
    terrain.height = 30

    const terrain2 = new Tiles('slop')
    terrain2.width = 200
    terrain2.height = 50
    terrain2.position.x = 200
    terrain2.position.y = 150

    function update() {
        // terrain update
        terrain.update(player)
        terrain2.update(player)

        //player update
        player.update()

        //bg
        c.fillStyle = 'rgb(220,220,220)'
        c.fillRect(0, 0, canvas.width, canvas.height)

        // terrain
        terrain.draw()
        terrain2.draw()


        // player
        player.draw()




        if (keys.atk.pressed)
            player.deltaPosition.x = 0
        if (keys.jump.pressed)
            player.deltaPosition.y = -6
        if (keys.left.pressed)
            player.deltaPosition.x = -1
        if (keys.stop.pressed)
            player.deltaPosition.x = 0
        if (keys.right.pressed)
            player.deltaPosition.x = 1
        requestAnimationFrame(update)

        for (let _key in keys) keys[_key].pressed = false


    }



    update()

</script>
