<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>2D Ray Casting with Variable Heights (Fixed)</title>
  <style>
    body {
      margin: 0;
      background: #575757;

      display: grid;
      place-items: center;
      height: 80vh
    }

    canvas {

      image-rendering: pixelated;
      background: #8b8b8b
    }
  </style>
</head>

<body>
  <p>[canvas0: c(w,h)]</p>
  <div id="fps"></div>
  <canvas id="c" width="480" height="320"></canvas>
  <p>[canvas1: c2(w0,h0)]</p>
  <canvas id="c0" width="240" height="240"></canvas>
  <p id="list"></p>


</body>

<script src="data.js"></script>include data.js</script>




<script id="page basic setting">
  // ===== Canvas =====
  const canvas0 = document.getElementById('c')
  const ctx0 = canvas0.getContext('2d', { alpha: false, willReadFrequently: true })
  const W = canvas0.width, H = canvas0.height

  const canvas1 = document.getElementById('c0')
  const ctx1 = canvas1.getContext('2d', { alpha: false, willReadFrequently: true })
  const w0 = canvas1.width, h0 = canvas1.height


  function drawLine(ctx, x0, y0, x1, y1, color = 'red', thickness = 4) {
    ctx.strokeStyle = color
    ctx.lineWidth = thickness
    ctx.beginPath()
    ctx.moveTo(x0, y0)
    ctx.lineTo(x1, y1)
    ctx.stroke()
  }

  function drawSimpleBG(color) {
    ctx0.fillStyle = color
    ctx0.fillRect(0, 0, W, H)
  }

  function drawGrid(cellSize = 50) {
    const cols = Math.floor(W / cellSize); // 横方向のマス数
    const rows = Math.floor(H / cellSize); // 縦方向のマス数

    ctx0.strokeStyle = 'rgba(0,0,0,0.2)'
    ctx0.lineWidth = 2
    ctx0.fillStyle = 'black'
    ctx0.font = '10px sans-serif' // フォント指定も忘れずに

    for (let i = 0; i <= cols; i++) {
      ctx0.beginPath()
      ctx0.moveTo(i * cellSize, 0)
      ctx0.lineTo(i * cellSize, H)
      ctx0.stroke()
      ctx0.fillText(i * cellSize, i * cellSize, 10)
    }

    for (let j = 0; j <= rows; j++) {
      ctx0.beginPath()
      ctx0.moveTo(0, j * cellSize)
      ctx0.lineTo(W, j * cellSize)
      ctx0.stroke()
      ctx0.fillText(j * cellSize, 0, j * cellSize)
    }
  }
</script>


<script id="equipment & engine & utilities">

  // key Maps > keys > Listener
  document.addEventListener("keyup", (e) => {
    const action = keyMap[e.key.toLowerCase()]
    if (action) {
      keys[action].pressed = false
      if (onReleasehandlers[action]) {
        if (keys[action].press) {
          onReleasehandlers[action]()
          keys[action].press = false
        }
      } else {
        keys[action].press = false

      }
      e.preventDefault()
    }
  })

  document.addEventListener("keydown", (e) => {
    const action = keyMap[e.key.toLowerCase()]
    if (action) {
      keys[action].pressed = true
      if (onPressHandlers[action]) {
        if (!keys[action].press) {
          onPressHandlers[action]()
          keys[action].press = true
        }
      } else {
        keys[action].press = true

      }
      e.preventDefault()  // ページスクロールなどを防止
    }
  })



  // html button interface
  keyPress = function (key) {
    keys[key].pressed = true
    keys[key].source = 'button'
  }

  // for (let _key in keys) keys[_key].pressed = false

  // key container
  const keys = new Proxy({}, {
    get(target, prop) {
      if (!(prop in target)) {
        target[prop] = { press: false, pressed: false }
      }
      return target[prop]
    }
  })


</script>
<script id="equipment functions">
  // 画面になにか
  function showHTML(MSG, ID = 0) {
    let el = document.getElementById(ID)

    if (!el) {
      el = document.createElement('div')
      el.id = ID

      const body = document.body
      if (body.firstChild) {
        body.insertBefore(el, body.firstChild); // ← 先頭に挿入
      } else {
        body.appendChild(el); // ← 最悪何もないときは普通に追加
      }
    }

    el.innerText = MSG
  }


  // render queueと一緒に使う、一気に変換
  function cameraProjection(target, camera) {
    //target.drawPosition.x = target.position.x
    //target.drawPosition.y = target.position.y
    ctx0.save()

    target.drawPosition.x = target.position.x - camera.position.x + W / 2
    target.drawPosition.y = target.position.y - camera.position.y + H / 2

    const scale = 1.5
    ctx0.scale(scale, scale)
    // 左上がスケールの原点
    // 真ん中の点を真ん中に戻せばいい
    // 拡大したら、点の調整もスケールかけるので、最後に/scaleが必要
    target.drawPosition.x -= ((scale - 1) * W / 2) / scale
    target.drawPosition.y -= ((scale - 1) * H / 2) / scale

    target.draw()

    ctx0.restore()


  }

  // 四角い判定ボックスと 予測型コリジョン判定用のやつ
  // updateしないと、drawPositionも更新されない
  function getCollision(target, draw = true, ctx = ctx) {
    target.position = { x: 0, y: 0 }
    target.deltaPosition = { x: 0, y: 0 }
    target.drawPosition = { x: 0, y: 0 }
    target.accelaration = { x: 0, y: 0 }
    target.width = 32
    target.height = 32
    target.gravity = 1
    target.direction = 1
    target.maxSpeed = { x: 3, y: 10 }

    target.checkSpeed = function () {
      const vx = target.deltaPosition.x
      const vy = target.deltaPosition.y
      if (Math.abs(vx) > target.maxSpeed.x) {
        target.deltaPosition.x = Math.sign(vx) * target.maxSpeed.x
      }
      if (Math.abs(vy) > target.maxSpeed.y) {
        target.deltaPosition.y = Math.sign(vy) * target.maxSpeed.y
      }
    }

    const _update = target.update.bind(target)
    target.update = function () {
      _update()
      target.drawPosition.x = target.position.x
      target.drawPosition.y = target.position.y
    }

    target.moveTo = function (x, y) {
      target.position.x = x
      target.position.y = y
    }
    target.updateDir = function () {
      if (target.deltaPosition.x > 0) target.direction = 1
      else if (target.deltaPosition.x < 0) target.direction = -1
    }

    target.drawRect = function (ctx = ctx) {
      ctx.fillStyle = 'grey'
      ctx.fillRect(target.drawPosition.x, target.drawPosition.y, this.width, this.height)
    }
    addMethodLast(target, 'draw', target, 'drawRect')


    target.initialize = function (x, y, w, h) {
      this.position = { x: x, y: y }
      this.width = w
      this.height = h
    }

    target.swapPosition = function () {
      target.position.x += target.deltaPosition.x
      target.position.y += target.deltaPosition.y
    }

    target.updateGravity = function () {
      target.deltaPosition.y += target.gravity
    }
    target.applyFriction = function () {
      const friction = 0.1
      const vx = target.deltaPosition.x

      if (Math.abs(vx) <= friction) {
        target.deltaPosition.x = 0
      } else {
        target.deltaPosition.x -= Math.sign(vx) * friction
      }
    }

    target.Ytop = function () {
      return { now: this.position.y, next: this.position.y + this.deltaPosition.y }
    }
    target.Ybottom = function () {
      return { now: this.position.y + this.height, next: this.position.y + this.height + this.deltaPosition.y }

    }
    target.Xleft = function () {
      return { now: this.position.x, next: this.position.x + this.deltaPosition.x }

    }
    target.Xright = function () {
      return { now: this.position.x + this.width, next: this.position.x + this.width + this.deltaPosition.x }

    }

    target.YLandOn = function (_ground) {
      target.position.y = _ground - target.height
      target.deltaPosition.y = 0
    }
    target.centerPosition = function () {
      return { x: this.position.x + this.width / 2, y: this.position.y + this.height / 2 }
    }



  }

  // the object to object hitTester
  // not use this anymore in accessable block world
  function getHitTester(_target) {
    _target.hitTest = function (target) {
      if (
        target.Ybottom().next > this.Ytop().now &&
        target.Ytop().next < this.Ybottom().now &&
        target.Xright().next > this.Xleft().now &&
        target.Xleft().next < this.Xright().now
      ) {

        const fromAbove = target.Ybottom().now <= this.Ytop().now
        const fromBelow = target.Ytop().now >= this.Ybottom().now
        const fromRight = target.Xleft().now >= this.Xright().now
        const fromLeft = target.Xright().now <= this.Xleft().now
        if (fromAbove) {
          target.position.y = this.position.y - target.height
          target.deltaPosition.y = 0
          if (target.eventQueue) target.pushEvent('land')
        } else if (fromBelow) {
          target.position.y = this.position.y + this.height + 1
          target.deltaPosition.y = 0

        } else if (fromRight) {
          target.position.x = this.position.x + this.width
          target.deltaPosition.x = 0

        } else if (fromLeft) {
          target.position.x = this.position.x - target.width
          target.deltaPosition.x = 0
        } else {
          console.log('?!')
          const centerfromAbove = target.centerPosition().y <= this.position.y + this.height / 2
          const centerfromBelow = target.centerPosition().y >= this.position.y + this.height / 2
          const centerfromRight = target.centerPosition().x >= this.position.x + this.width / 2
          const centerfromLeft = target.centerPosition().x <= this.position.x + this.width / 2
          if (centerfromAbove) {

            target.position.y = this.position.y - target.height
            target.deltaPosition.y = 0
            if (target.eventQueue) target.pushEvent('land')
          } else if (centerfromBelow) {
            target.position.y = this.position.y + this.height + 1
            target.deltaPosition.y = 0

          } else if (centerfromRight) {
            target.position.x = this.position.x + this.width
            target.deltaPosition.x = 0

          } else if (centerfromLeft) {
            target.position.x = this.position.x - target.width
            target.deltaPosition.x = 0
          } else {
            console.log('bakana!')
          }
        }
      }
    }
  }

  // 2種類のProxyを実装する
  // でも、正直Tagは使いたくないけどね
  function getProxy(target) {
    target.request = new Proxy({}, {
      get: (target, prop) => {
        const value = target[prop]
        target[prop] = false; // 読んだら自動で false にする
        return value ?? false
      }
    })

    // 未定義状態。自由に書き込める。デフォルト状態はfalse
    target.Tag = new Proxy({}, {
      get(target, prop) {
        return prop in target ? target[prop] : false
      }
    })
  }

  function getActiveTags(tagObj, separator = " ") {
    return Object.entries(tagObj)
      .filter(([_, v]) => v === true)
      .map(([k]) => k)
      .join(separator)
  }



  // Methodを結合する。returnのスコープを注意
  function addMethodFirst(target, target_method, comp, method) {
    const t = target[target_method].bind(target)// this = target
    const c = comp[method].bind(comp)// this = comp
    target[target_method] = function (...args) {
      c(...args)
      t(...args)
    }
  }

  function addMethodLast(target, target_method, comp, method = target_method) {
    const t = target[target_method].bind(target)
    const c = comp[method].bind(comp)
    target[target_method] = function () {
      t()
      c()
    }
  }

  // 独自のupdateとDrawを持ったcomponentを内部に埋め込む
  function joinComponent(cmpnt, trgt) {

    addMethodLast(trgt, 'update', cmpnt)
    addMethodLast(trgt, 'draw', cmpnt)

    if (cmpnt.dealEvent && trgt.dealEvent) {
      addMethodLast(trgt, 'dealEvent', cmpnt)
    }

    return cmpnt

  }
  // state Machine の初期化。これのDecoupleは…
  // 外部データが必要
  function getStateMachine(target) {
    const initialState = target.data.state[target.data.initialState]
    target.state = new ImportedState(target.data.initialState, initialState)
    target.state.enter(target)

    target.cst = function (stateName) {
      target.state = new ImportedState(stateName, target.data.state[stateName])

      target.counter.setEnd()// じゃないと前のカウンターの処理が裏で走ってしまう
      target.state.enter(target)
    }

    const update_ = target.update.bind(target)
    console.log('state machine joined ')

    target.update = function () {
      update_()
      target.state.update(target)

    }

  }
</script>


<script id="utilities">
  class ImageLoader {
    constructor(url) {
      this.loaded = false
      this.img = new Image()
      this.img.src = url
      this.img.onload = () => {
        this.loaded = true
      }
    }
    load(url) {
      this.loaded = false
      this.img.src = url
      this.img.onload = () => {
        this.loaded = true
      }
    }
    draw() {
      if (!this.loaded) return
      ctx0.drawImage(this.img, 0, 0, this.img.width, this.img.height, 0, 0, W, H)
    }
  }

  // ここが大事。歯車
  class Counter {
    constructor({
      endTime = 100,
      pause = false,
      end = false,
      target = null,
      msg = "__",
      processCall = null,
      endCall = () => { },
      loop = false,
    } = {}) {
      this.time = 0
      this.endTime = endTime
      this.loop = loop
      this.pause = pause
      this.end = end
      this.target = target
      this.processCall = processCall
      this.endCall = endCall
      this.msg = msg
    }
    progress() {
      return this.time / this.endTime
    }
    start() {
      this.pause = false
    }
    stop() {
      this.pause = true
    }

    setEnd() {
      this.end = true
    }
    isEnd() {
      return this.end
    }

    #endMethod() {
      if (this.loop) {
        this.time = 0
        return
      }
      this.end = true
      this.endCall?.()
    }


    update() {
      if (this.time < this.endTime) {
        this.processCall?.()
        this.time++
      } else this.#endMethod()
    }
  }

  // 対象がCounterを持つようになる
  // Counterを描画するための関数が追加される
  function getCounterComponent(t, gm = GM) {
    t.counter = this.addCounter({
      endTime: 100,
      target: t,
      processCall: function () {
        if (this.time == this.endTime - 1) {
          this.time = 0
        }
      },
      endCall: () => {
        console.log('no chance to end')
      }
    })

    t.drawCounter = function () {
      ctx0.fillStyle = 'red'
      ctx0.fillRect(t.drawPosition.x, t.drawPosition.y, 32 * t.counter.progress(), 10)
    }

    addMethodLast(t, 'draw', t, 'drawCounter')
  }


  // test 用のGameManagerObject
  // cameraを入れたら、drawがcamera経由になる

  // 本当は配列に入れたほうが、あとから消すことができるけどね
  function joinGameLoop(target, gm = GM) {

    if (target.dealEvent)
      addMethodLast(gm, 'gameLoop_input', target, 'dealEvent')
    if (target.check)
      addMethodLast(gm, 'gameLoop_check', target, 'check')
    if (target.update)
      addMethodLast(gm, 'gameLoop_update', target, 'update')
    if (target.draw)
      addMethodLast(gm, 'draw', target, 'draw')
  }

  // ここに入れれば、繰り返し呼び出される
  function gameLoop() {
    console.log('define the [gameLoop],the KeyMap,gameManager,EventQueue,ListShowerHTML')
  }

  // ここが心臓部分
  function update() {
    gameLoop()
    requestAnimationFrame(update)
  }
  update()
</script>

<script id="3D accessable world engine">
  // マイクラ世界の醍醐味の一つ
  // positionとwidth, height, blockSizeの定義も必須
  // アクセスできる世界の情報で、好きなタイミングで checkができる。


  function moveAxis(axis, delta, _player = player, _world = _player.world) {
    _player[`v` + axis] = _world.moveAxisCheck_BottomType(_player.position, axis, delta, _player.size, _player)
  }

  // player.current を設定するだけ。
  // and the player needs position, size, vx,vy,vz
  // 完全透明。空のupdateとupdateListを入れることで、this.currentのupdateなどに二回アクセスするのを防ぐ
  class PlayerProxy {
    constructor(initial = null, name) {
      this.current = initial
      this.name = name
      this.objectList = []
      return new Proxy(this, {
        get: (target, prop, receiver) => {
          if (prop in target) return Reflect.get(target, prop, receiver)
          return target.current?.[prop]
        },
        set: (target, prop, value, receiver) => {
          if (prop in target) return Reflect.set(target, prop, value, receiver)
          if (target.current) target.current[prop] = value
          return true
        }
      })
    }

    update() { }

    setCurrent(obj) {
      this.current = obj
    }
    getCurrent() {
      return this.current
    }
  }



  class EmptyObject {
    constructor() {
    }
    //これは上書きしない
    update() {
      if (this.updatePause === true) return
      this.update_self()
    }
    traverse(list, callback) {
      for (const obj of list) {
        callback(obj)
        if (obj.objectList) {
          this.traverse(obj.objectList, callback)
        }
      }
    }

    updateList_filter(ID) {
      this.objectList = this.objectList.filter((c) => c.id != ID)
    }
    addChild(e, draw = true) {
      this.objectList.push(e)
      e.master = this
      e.updatePause = false
      if (draw) e.drawPause = false
      else e.drawPause = true
    }
    update_self() {
    }
    destroy() {
      console.log(`${this.constructor.name} destroyed`)
    }

    draw() {
      console.log('Empty time')
    }
  }

  //ゲーム世界の原子になる
  //name for showList, id more like type
  // need Vec3 class
  class GameObject {
    constructor(name = 'Node', id = 'game_object') {
      this.folded = false // toggle this to fold a folder group
      this.id = id
      this.name = name
      this.deleted = false
      this.objectList = []
      this.drawList = []
      this.tags = new Set()
      this.drawPause = false
      this.updatePause = false
      this.position = new Vec3(0, 0, 0)
    }

    get size() {
      return { x: this.sizex ?? 0, y: this.sizey ?? 0, z: this.sizez ?? 0 }
    }

    get rotation() {
      return { x: 0, y: 0, z: this.angle ?? 0 }
    }

    get px() {
      //return this.master?.px || 0 + this.localx
      return (this.master?.px ?? 0) + this.localx
    }
    get py() {
      return (this.master?.py ?? 0) + this.localy

    }
    get pz() {
      return (this.master?.pz ?? 0) + this.localz
    }

    set px(v) {
      this.localx = v
    }

    set py(v) {
      this.localy = v
    }

    set pz(v) {
      this.localz = v
    }

    //これは上書きしない
    update() {
      if (this.updatePause === true) return
      this.update_self()
    }
    update_self() {
    }

    draw() {
      //console.log('gameobject draw')
    }
    onAttach(master) {
      this.master = master
    }
    traverse(list, callback) {
      for (const obj of list) {
        callback(obj)
        if (obj.objectList) {
          this.traverse(obj.objectList, callback)
        }
      }
    }

    updateList_filter(ID) {
      this.objectList = this.objectList.filter((c) => c.id != ID)
    }
    addChild(e, draw = true) {
      this.objectList.push(e)
      this._needsRebuild = true
      if (e.onAttach)
        e.onAttach(this)
      else
        e.master = this
      e.updatePause = false
      e.gatherReference?.(this)

      if (e.drawPause == true) return e
      if (draw) e.drawPause = false
      else e.drawPause = true

      return e
    }
    destroy() {
      if (this.deleted) return
      this.deleted = true
      console.log(`${this.constructor.name} destroyed`)
    }

  }


  class ListShower {
    constructor() {
      this.text = []
    }
    update() {
    }
    draw() {
      if (!this.master) return
      const text = this.master.showList(this.master.objectList)

      if (text != false) {
        console.log('[when GM rebuild] list shower split the list')
        const lines = text.split('\n')
        this.text = lines
        const startY = 0
        const lineHeight = 20 // 行間。お好みで調整

        ctx0.fillStyle = 'rgba(0,0,0,0.5)'
        ctx0.fillRect(0, 0, W / 3, lineHeight * lines.length)

        ctx0.fillStyle = 'white'
        ctx0.font = '10px sans-serif' // フォント指定も忘れずに

        lines.forEach((line, i) => {
          ctx0.fillText(line, 10, startY + 20 + i * lineHeight)
        })
      } else {

        const lines = this.text
        const startY = 0
        const lineHeight = 20 // 行間。お好みで調整

        ctx0.fillStyle = 'rgba(0,0,0,0.5)'
        ctx0.fillRect(0, 0, W / 3, lineHeight * lines.length)

        ctx0.fillStyle = 'white'
        ctx0.font = '10px sans-serif' // フォント指定も忘れずに
        lines.forEach((line, i) => {
          ctx0.fillText(line, 10, startY + 20 + i * lineHeight)
        })
      }
    }
  }


  class ListShowerHTML extends GameObject {
    constructor(name = 'ListShowerHTML') {
      super(name)
      this.text = []
    }
    update() {
    }
    draw() {
      if (!this.master) return
      const text = this.master.showList(this.master.objectList)

      if (text) {
        showHTML(text, 'list')

      }
    }
  }




  class BlockWorld extends GameObject {
    constructor(x = 10, y = 10, z = 5, block_size = 32) {
      super()
      this.block_size = 50
      this.world = []
      this.worldSize = {
        x: x,
        y: y,
        z: z
      }

      this.initialize()

      this.blockImage = new ImageLoader('https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/map/MCblock.png')

    }

    initialize() {
      for (let x = 0; x < this.worldSize.x; x++) {
        this.world[x] = []
        for (let y = 0; y < this.worldSize.y; y++) {
          this.world[x][y] = []
          const height = Math.floor(Math.random() * (this.worldSize.z - 1)) + 1
          for (let z = 0; z < height; z++) {
            this.world[x][y][z] = 1

            if (x > 1 && x < this.worldSize.x - 2 && y > 1 && y < this.worldSize.y - 2 && z > 0) {
              this.world[x][y][z] = 0

            }
          }
        }
      }

    }

    moveAxisCheck_BottomType(pp, axis, delta, size, target = null) {
      const block = this.block_size
      const pw = size.x
      const pd = size.y
      const ph = size.z
      const np = { x: pp.x, y: pp.y, z: pp.z }
      np[axis] += delta
      // この計算…一回だけでいいよね？
      // いやだめだ、軸ごとにPositionの更新が入るので、引っかかるBlockも更新されるべき
      const eps = 0.001// Math.floorは[0,1)なので、max側にくっつけた状態が良くない
      const minX = Math.floor((np.x - pw / 2) / block)
      const maxX = Math.floor((np.x + pw / 2 - eps) / block)
      const minY = Math.floor((np.y - pd / 2) / block)
      const maxY = Math.floor((np.y + pd / 2 - eps) / block)
      const minZ = Math.floor((np.z) / block)
      const maxZ = Math.floor((np.z + ph - eps) / block)

      for (let bx = minX; bx <= maxX; bx++) {
        for (let by = minY; by <= maxY; by++) {
          for (let bz = minZ; bz <= maxZ; bz++) {
            if (this.world[bx]?.[by]?.[bz]) {
              // 衝突補正: 進行方向に応じて位置をブロックの端に揃える
              if (axis === 'x') {
                if (delta > 0) pp[axis] = bx * block - pw / 2
                if (delta < 0) pp[axis] = (bx + 1) * block + pw / 2
              } else if (axis === 'y') {
                if (delta > 0) pp[axis] = by * block - pd / 2
                if (delta < 0) pp[axis] = (by + 1) * block + pd / 2
              } else if (axis === 'z') {
                if (delta > 0) pp[axis] = bz * block - ph;       // top
                if (delta < 0) {
                  pp[axis] = (bz + 1) * block
                  target.pushEvent('land')


                }  // landing

              }
              return 0; // 衝突したら移動終了
            }
          }
        }
      }

      return delta
    }


    exportRenderQueue(camera) {
      const worldSize = this.worldSize
      const block_size = this.block_size
      const world = this.world
      const camera_angle = camera.rotation / 180 * Math.PI
      const blockImage = this.blockImage

      for (let x = 0; x < worldSize.x; x++) for (let y = 0; y < worldSize.y; y++) for (let z = 0; z < worldSize.z; z++) if (world[x][y][z]) {
        const v_p = camera.projection({
          x: x * block_size,
          y: (y + 1) * block_size,
          z: z * block_size
        })
        const v2_p = camera.projection({
          x: x * block_size,
          y: (y + 1) * block_size,
          z: (z + 1) * block_size
        })
        const h1 = v2_p.y // top
        const h2 = v_p.y // bottom

        if (h1 < H && h2 > 0) if (h2 - h1 > 0)
          // draw front height
          camera.renderQueue.push({
            depth: x + y + z + 1,
            color: `hsla(${z / worldSize.z * 20 + y / worldSize.y * 20 + 200}, 50%, ${z / worldSize.z * 50 + y / worldSize.y * 50}%,
                                0.2)`,
            draw: function () {
              let coord = null
              if (!world[x][y][z + 1]) {

                coord = { x: 3, y: 0 }
              }
              else {
                coord = { x: 2, y: 0 }

              }

              if (blockImage.loaded) {
                ctx0.drawImage(
                  blockImage.img,
                  coord.x * 48,
                  coord.y * 48,
                  48,
                  48,
                  v2_p.x,
                  v2_p.y,
                  block_size,
                  Math.ceil(h2 - h1) + 1)
              }

              ctx0.fillStyle = this.color
              ctx0.fillRect(
                v2_p.x,
                v2_p.y,
                block_size,
                Math.ceil(h2 - h1) + 1
              )

            }
          })

        // draw top!
        if (!world[x][y][z + 1]) {
          const vt_p = camera.projection({
            x: x * block_size,
            y: y * block_size,
            z: (z + 1) * block_size
          })
          const vt2_p = camera.projection({
            x: x * block_size,
            y: (y + 1) * block_size,
            z: (z + 1) * block_size
          })
          const h1 = vt_p.y // top
          const h2 = vt2_p.y // bottom

          if (h1 < H && h2 > 0) if (h2 - h1 > 0)

            camera.renderQueue.push({
              depth: x + y + z + 1,
              color: `hsla(
                                ${(z + 1) * 40 / worldSize.z}, 
                                80%, 
                                ${(z + 1) * 100 / worldSize.z}%,
                                0.3)`,
              draw: function () {


                if (blockImage.loaded) {
                  const coord = { x: 12, y: 12 }
                  ctx0.drawImage(
                    blockImage.img,
                    coord.x * 48,
                    coord.y * 48,
                    48,
                    48,
                    vt_p.x,
                    vt_p.y,
                    block_size,
                    Math.ceil(h2 - h1) + 1)
                }

                ctx0.fillStyle = this.color
                ctx0.fillRect(
                  vt_p.x,
                  vt_p.y,
                  block_size,
                  Math.ceil(h2 - h1) + 1
                )


              }
            })
        }



      }
    }
  }

  class Camera2_5 extends GameObject {
    constructor(target) {
      super()
      this.position = {
        x: 0,
        y: 0,
        z: 0,

      }
      this.target = target
      this.radius = 400 // cylinder effect
      this.tilt = 0 // z axis rotation
      this.rotation = 45 // x axis rotation
      this.zoom = 1
      this.speed = 0.04
      this.drawList = []
      this.drawListUI = []
      this.renderQueue = []
      this.objectList = []

    }
    update_self() {
      if (this.target) {
        const deltaX = this.target.position.x - this.position.x
        const deltaY = this.target.position.y - this.position.y
        const deltaZ = this.target.position.z - this.position.z
        if (Math.abs(deltaX) > 1)
          this.position.x += (deltaX) * this.speed
        else
          this.position.x = this.target.position.x
        if (Math.abs(deltaY) > 1)
          this.position.y += (deltaY) * this.speed
        else
          this.position.y = this.target.position.y
        if (Math.abs(deltaZ) > 1)
          this.position.z += (deltaZ) * this.speed
        else
          this.position.z = this.target.position.z
      }
    }

    projection(position) {
      const cp = this.position
      const rad = this.rotation / 180 * Math.PI // angle in radius
      const radius = this.radius
      // my canvas XYZ to Maya XYZ
      // the origin is left-top
      const v1 = {
        x: position.x - cp.x,
        y: position.y - cp.y,
        z: position.z - cp.z
      }


      //const k = Math.min(Math.abs(v1.y) / this.world.block_size/2, 1)
      const k = 1
      const theta = v1.y / radius
      v1.y = v1.y * (1 - k) + k * (radius + position.z) * Math.sin(theta)
      v1.z = v1.z * (1 - k) + k * (v1.z - (radius + position.z) * (1 - Math.cos(theta)))


      const v2 = {
        x: v1.x,
        y: H - v1.y,
        z: v1.z
      }
      // world to camera(in Maya XYZ)
      // the dot production, to get the coords in new coordination
      const v3 = {
        x: v2.x,
        y: v2.y * Math.cos(rad) + v2.z * Math.sin(rad),
        z: v2.y * Math.sin(rad) - v2.z * Math.cos(rad)
      }
      // camera(Maya XYZ) to screen(invert the y)
      // camera center! (x, h * Math.cos(rad))
      const v4 = {
        x: (v3.x) + W / 2,
        y: (H * Math.cos(rad) - v3.y) + H / 2,
        z: v3.z
      }

      //v.update_drawPosition(v4)
      return v4
    }

    getDepth() { }

    draw() {
      this.getGMRenderQueue()

      ctx0.save(); // 現在の状態を保存
      // 中心を回転の基準点に移動
      ctx0.translate(W / 2, H / 2)
      ctx0.rotate(this.tilt * Math.PI / 180)
      ctx0.scale(1 + (this.zoom - 1) * 2, this.zoom)
      ctx0.translate(-W / 2, -H / 2)
      this.renderQueue.forEach(e => {
        e.draw?.()
      })
      ctx0.restore(); // 状態を元に戻す

      this.renderQueue.length = 0 // こっちのほうがメモリー的に良いらしい

      this.drawListUI.forEach(e => {
        e.draw?.()
      })
      this.drawListUI = []
    }
    getGMRenderQueue() {
      GM.traverse(GM.objectList, (e) => {
        if (!e.drawPause)
          if (e.exportRenderQueue)
            e.exportRenderQueue(GM.camera)
          else
            this.drawListUI.push(e)


      })
      this.renderQueue.sort((a, b) => a.depth - b.depth)
    }

    getRenderQueue() {
      // for loop the world, push something into renderqueue

      // draw player!
      this.drawList.forEach(e => {
        if (!e.exportRenderQueue) return console.log('some object need the exportRenderQueue Method')
        e.exportRenderQueue(this)
      })
      this.renderQueue.sort((a, b) => a.depth - b.depth)

    }
  }



  // the player is defined by the world

  class Collision3D extends GameObject {
    constructor() {
      super()
      this.drawPause = false
      EventHub.getEventHandler(this)
      this.on('keydown', (target) => {
        target.vy = 2
      })
      this.on('keyup', (target) => {
        target.vy = -2
      })
      this.on('keyright', (target) => {
        target.vx = 2
      })
      this.on('keyleft', (target) => {
        target.vx = -2
      })
    }
    update_self() {
      const m = this.master
      // get and chect the next, in just one code!

      // self-check the delta 
      m.vx = m.worldMove('x', m.vx)
      m.vy = m.worldMove('y', m.vy)
      m.vz = m.worldMove('z', m.vz)


      m.position.x += m.vx
      m.position.y += m.vy
      m.position.z += m.vz

      if (m.vx > 0) m.direction.x = 1
      else if (m.vx < 0) m.direction.x = -1

      if (m.vx != 0 || m.vy != 0) m.pushEvent('onMove')
      else if (m.vx == 0 && m.vy == 0) m.pushEvent('onStop')

      if (m.vz < 0) m.pushEvent('fall')

      // 摩擦力未実装なのでとりあえず止める
      m.vx = this.applyFriction(m.vx)
      m.vy = this.applyFriction(m.vy)
      m.vz -= 0.5

    }

    applyFriction(v) {
      const friction = this.master.friction || 0.1

      if (Math.abs(v) <= friction) {
        return 0
      } else {
        return v - Math.sign(v) * friction
      }
    }
    applyGravity(v) {
      const friction = this.master.friction || 0.1
      return v - 0.5
    }

    exportRenderQueue(camera) {
      const m = this.master
      const vp1 = camera.projection({
        x: m.position.x - m.size.x / 2,
        y: m.position.y - m.size.y / 2,
        z: m.position.z + m.size.z
      })
      const vp2 = camera.projection({
        x: m.position.x - m.size.x / 2,
        y: m.position.y + m.size.y / 2,
        z: m.position.z + m.size.z
      })
      const vp3 = camera.projection({
        x: m.position.x - m.size.x / 2,
        y: m.position.y + m.size.y / 2,
        z: m.position.z
      })
      camera.renderQueue.push({
        depth: (m.position.x + m.position.y + m.position.z) / m.world.block_size,
        draw: () => {
          ctx0.fillStyle = 'yellow'
          ctx0.fillRect(
            vp1.x,
            vp1.y,
            m.size.x,
            (vp2.y - vp1.y)
          )

          ctx0.fillStyle = 'red'
          ctx0.fillRect(
            vp2.x,
            vp2.y,
            m.size.x,
            (vp3.y - vp2.y),
          )

        }

      })
    }
  }

  class Player3D extends GameObject {
    constructor(_world) {
      super()
      this.world = _world
      this.color = 'yellow'
      this.position = {
        x: 300,
        y: 100,
        z: 300,
      }
      this.size = {
        x: 20,
        y: 20,
        z: 20,
      }
      this.direction = {
        x: 0,
        y: 1,
        z: 1,
      }
      this.vx = 0
      this.vy = 0
      this.vz = 0
      this.objectList = []
      this.drawPause = true
      // to spread the event
      //getEventManager(this)
    }

    moveTo(x, y, z) {
      this.position.x = x
      this.position.y = y
      this.position.z = z
    }

    worldMove(Axis, delta) {
      const d = this.world.moveAxisCheck_BottomType(this.position, Axis, delta, this.size, this)
      return d
    }

    update_self() {
      this.notifyEventToChildren()

    }


    exportRenderQueue(camera) {
      const vp1 = camera.projection({
        x: this.position.x - this.size.x / 2,
        y: this.position.y - this.size.y / 2,
        z: this.position.z + this.size.z
      })
      const vp2 = camera.projection({
        x: this.position.x - this.size.x / 2,
        y: this.position.y + this.size.y / 2,
        z: this.position.z + this.size.z
      })
      const vp3 = camera.projection({
        x: this.position.x - this.size.x / 2,
        y: this.position.y + this.size.y / 2,
        z: this.position.z
      })
      camera.renderQueue.push({
        depth: (this.position.x + this.position.y + this.position.z) / this.world.block_size,
        draw: () => {
          ctx0.fillStyle = this.color
          ctx0.fillRect(
            vp1.x,
            vp1.y,
            this.size.x,
            (vp2.y - vp1.y)
          )

          ctx0.fillStyle = 'rgba(160,0,100,1)'
          ctx0.fillRect(
            vp2.x,
            vp2.y,
            this.size.x,
            (vp3.y - vp2.y),
          )

        }

      })
    }

  }


  class Controller3D extends GameObject {
    constructor() {
      super()
      this.id = 'controller3D'
      onPressHandlers.attack = () => {
        this.master.pushEvent('atk')
      }
      onPressHandlers.jump = () => {
        //moveAxis('z', 8, this.target)
        this.master.pushEvent('jump')

      }
      onPressHandlers.parry = () => {
        //moveAxis('z', 8, this.target)
        this.master.pushEvent('parry')

      }


    }
    update_self() {

      if (!this.master) return
      const m = this.master
      if (keys.down.pressed) {
        m.pushEvent('keydown')
      } else if (keys.up.pressed) {
        m.pushEvent('keyup')
      }

      if (keys.left.pressed) {
        m.pushEvent('keyleft')

      } else if (keys.right.pressed) {
        m.pushEvent('keyright')
      }


    }
  }




  class stateRenderer2_5 extends GameObject {
    constructor(master) {
      super()
      this.master = master
      this.spriteImage = null
      this.currentFrame = 0

    }

    checkSprite() {
      const n = this.master.activeState.name
      const s = this.master.data.state[n]?.sprite
      if (!s) return false
      if (this.spriteName === n) return true

      const path = this.master.data.spriteFolder + s.path

      if (!this.spriteImage)
        this.spriteImage = new ImageLoader(path)
      else if (this.spriteImage.img.src != path)
        this.spriteImage.load(path)

      return true
    }

    update() {
      if (!this.checkSprite()) {
        this.spriteImage = null
        return
      }

      const n = this.master.activeState.name
      const s = this.master.data.state[n]?.sprite
      const mc = this.master.counter
      let FrameBuffer = mc.endTime / s.length
      this.currentFrame = Math.floor(mc.time / FrameBuffer)
      this.currentFrame = Math.min(this.currentFrame, s.length - 1)

    }

    exportSpriteDraw(camera) {
      if (!this.spriteImage?.loaded) return false
      const n = this.master.activeState.name
      const s = this.master.data.state[n]?.sprite

      const sw = this.spriteImage.img.width / s.length
      const sh = this.spriteImage.img.height

      const cropbox = {
        position: {
          x: sw * this.currentFrame,
          y: 0,
        },
        width: sw,
        height: sh,
      }

      if (this.offset) {
        this.drawPosition.x += this.offset.x
        this.drawPosition.y += this.offset.y
      }

      const target = this.master.master
      const sizex = target.size.x * 2
      const sizey = target.size.y * 2
      const vp1 = camera.projection({
        x: target.position.x,
        y: target.position.y,
        z: target.position.z + target.size.z / 2
      })

      let flip = 1
      let flipX = vp1.x - sw / 2
      if (target.direction.x <= 0) flip *= -1
      if (s.flip) flip *= -1
      if (flip <= 0) flipX = -(vp1.x + sw / 2)

      const offsetx = s.offset ? s.offset.x : 0
      const offsety = s.offset ? s.offset.y : 0

      const drawObject = {
        depth: (target.position.x + target.position.y + target.position.z) / target.world.block_size,

        draw: () => {
          ctx0.save()
          ctx0.scale(flip, 1)
          ctx0.drawImage(
            this.spriteImage.img,
            cropbox.position.x,
            cropbox.position.y,
            cropbox.width,
            cropbox.height,

            flipX + offsetx,
            vp1.y - sh / 2 + offsety,
            sw,
            sh,
          )

          ctx0.restore()


          showHTML(`${this.master.activeState.name}: ${Math.floor(this.master.counter?.progress() * 10) / 10},currentFrame:${this.currentFrame}`, 11)
        }
      }

      return drawObject




    }

    draw() {
      if (!this.spriteImage?.loaded) return
      const n = this.master.activeState.name
      const s = this.master.data.state[n]?.sprite

      const sw = this.spriteImage.img.width / s.length
      const sh = this.spriteImage.img.height

      const cropbox = {
        position: {
          x: sw * this.currentFrame,
          y: 0,
        },
        width: sw,
        height: sh,
      }

      if (this.offset) {
        this.drawPosition.x += this.offset.x
        this.drawPosition.y += this.offset.y
      }

      ctx0.drawImage(
        this.spriteImage,
        cropbox.position.x,
        cropbox.position.y,
        cropbox.width,
        cropbox.height,

        this.drawPosition.x,
        this.drawPosition.y,
        sw,
        sh,
      )
    }


    exportRenderQueue(camera) {
      const ex = this.exportSpriteDraw(camera)
      if (!ex) return
      camera.renderQueue.push(ex)
    }


  }

  // standard state unit
  class Player3DState {
    constructor(master) {
      this.name = ''
      this.data = master.data
      this.master = master
      this.target = master.master
      EventHub.getEventHandler(this)

    }

    update() { }
    draw() { }
    enter() {
      console.log(`${this.name} state is created`)
    }
  }

  class Player3DImportedState extends Player3DState {
    constructor(sname, master) {
      super(master)
      this.name = sname
      console.log(`${this.name} state created`)
      this.data = master.data.state[sname]
      if (this.data.baseState) {
        const n = this.data.baseState
        this.data = master.data.state[n]
      }
      for (const [eventName, action] of Object.entries(this.data.on || {})) {
        // setting up handlers
        this.on(eventName, (target, EventData) => {
          if (action.move) {
            for (const m in action.move) {
              if (action.move[m]) {
                moveAxis(m, action.move[m], this.target)
              }
            }
          }
          if (action.log) console.log(action.log)
          if (action.event) GM.pushEvent(action.event)
          if (action.nextState)
            this.master.cst2(action.nextState)
        })
      }

      this.enter()
    }

    enter() {
      const _counter = GM.addCounter({
        msg: '[' + this.name + ']',
        target: this.master,
        endTime: this.data.duration,
        endCall: () => {
          this.target.pushEvent('onEnd')

        }
      })

      const _counter0 = new Counter({
        msg: '[' + this.name + ']',
        target: this.master,
        endTime: this.data.duration,
        endCall: () => {
          this.target.pushEvent('onEnd')

        }
      })

      const loop = this.data.sprite.loop
      const length = this.data.sprite.length
      const duration = this.data.duration
      if (loop) {
        _counter.processCall = () => {
          for (const step of this.data.steps || [])
            if (_counter.time === step.time)
              step.action(this.target)
          if (_counter.time === duration - 1)
            if (loop < length && duration > 0) {
              _counter.time = Math.floor(loop / length * duration)
            }
        }
      } else {
        _counter.processCall = () => {
          for (const step of this.data.steps || [])
            if (_counter.time === step.time)
              step.action(this.target)
        }
      }

      // counter must be end
      this.master.counter?.setEnd()
      this.master.counter = _counter
    }
  }



  class StateMachine extends GameObject {
    constructor(data = Rock, name) {
      super(name)
      this.drawPause = true
      this.data = data
      this.counter = null

    }

    onAttach(master) {
      console.log('onAttach')
      this.master = master
      this.activeState = new Player3DImportedState(this.data.initialState, this)
      this.addChild(new stateRenderer2_5(this))

    }

    // just interface
    onRequest(eventName, target, ...args) {
      return this.activeState.onRequest(eventName, target, ...args)
    }

    cst2(stateName) {
      this.activeState = new Player3DImportedState(stateName, this)
    }

    update_self() {
      this.activeState.update()
    }

    draw() {
      if (this.drawPause) return
      ctx0.fillStyle = 'red'
      ctx0.fillRect(0, 0, W, H)
    }

    exportRenderQueue(camera) {
      const sizex = this.master.size.x / 2
      const sizey = this.master.size.y / 2
      const vp1 = camera.projection({
        x: this.master.position.x,
        y: this.master.position.y + this.master.size.y / 2,
        z: this.master.position.z + this.master.size.z / 2
      })
      camera.renderQueue.push({
        depth: (this.master.position.x + this.master.position.y + this.master.position.z) / this.master.world.block_size,
        draw: () => {
          ctx0.fillStyle = 'red'
          ctx0.fillRect(
            vp1.x - sizex / 2,
            vp1.y - sizey / 2,
            sizex,
            sizey
          )
        }

      })
    }
  }


  // SoundManager
  // register and play
  class SoundManager {
    constructor() {
      this.registry = new Map(); // name → path
    }

    // 音を登録
    register(name, path) {
      this.registry.set(name, path)
    }

    // 再生
    play(name, volume = 1.0) {
      const path = this.registry.get(name)
      if (!path) {
        console.warn(`Sound "${name}" is not registered.`)
        return
      }
      const audio = new Audio(path)
      audio.volume = Math.max(0, Math.min(1, volume))
      audio.play()
    }
  }



  // ちいさいユーティリティ
  const lerp = (a, b, t) => a + (b - a) * t
  const clamp01 = (t) => Math.max(0, Math.min(1, t))
  // 代表的なEasing（必要な分だけ）
  const ease = {
    linear: t => t,
    inQuad: t => t * t,
    outQuad: t => t * (2 - t),
    inOutQuad: t => (t < .5) ? 2 * t * t : -1 + (4 - 2 * t) * t,
  }

  // ========= Timeline2（内部クロック + 複数Track）=========
  class Timeline {
    constructor({ length = 120, loop = false } = {}) {
      this.length = length;     // 総フレーム（or tick）
      this.loop = loop
      this.time = 0
      this.paused = false
      this.tracks = []
      this.tags = new Set(["eventStopper"]); // 必要なら既存タグ運用に合わせる
    }
    onAttach(master) {        //addChild が呼んでくれる
      this.master = master
    }
    addTrack(track) { this.tracks.push(track); return this; }
    reset() {
      this.time = 0
      this.finished = false
      this.tracks.forEach(e => {
        e.reset()
      })
    }
    update() {
      if (this.paused) return
      this.time++
      if (this.time > this.length) {
        if (this.loop) { this.time = 0; this.onLoop?.(); }
        else {
          this.time = this.length; this.onComplete?.()
          this.destroy(); return
        }
      }

      const t = this.time
      for (const tr of this.tracks) tr.update(t)
    }
    process() {
      return this.time / this.length
    }
    draw() {
      // draw time line process bar
      const thickness = 14
      const pos = Math.min(1, Math.sin(this.process() * Math.PI) * 8) * thickness
      ctx0.fillStyle = 'black'
      ctx0.fillRect(0, H - pos, W, thickness)
      ctx0.fillStyle = 'rgba(0,128,255,1)'
      ctx0.fillRect(0, H - pos, this.process() * W, thickness)
    }
    destroy() {
      console.log('destroying')
      if (this.finished) return
      this.finished = true
      // 親の updateList から自分を除去
      const parent = this.master
      GM.setTagPause('CSStop', false)

      parent.removeByTag('eventStopper')
      /* sss */
    }
  }

  // ========= KeyframeTrack（keys/steps対応）=========
  // keys: [{t:0, v:100, ease:ease.outQuad}, {t:60, v:250}, {t:90, v:250, interpolation:'hold'}]
  class KeyframeTrack {
    // getter/setter か、target & path（"position.x"みたいな）を渡す
    constructor({
      getter, setter,
      target = null, path = null,
      keys = [],                 // 時間はtimeline基準のフレーム/カウント
      defaultEase = ease.linear, // 未指定キーの補間
    }) {
      // アクセス方法を用意
      if (!getter || !setter) {
        if (!target || !path) throw new Error("KeyframeTrack: getter/setter か target+path を渡してね")
        const parts = path.split(".")
        getter = () => parts.reduce((o, k) => o[k], target)
        setter = (val) => {
          const last = parts.slice(0, -1).reduce((o, k) => o[k], target)
          last[parts[parts.length - 1]] = val
        }
      }
      this.getter = getter
      this.setter = setter
      // キーを t 昇順に
      this.keys = keys.slice().sort((a, b) => a.t - b.t)
      this.defaultEase = defaultEase
      this._lastIndex = -1; // step/hook用で必要なら使う
    }
    reset() {
      this._lastIndex = -1
    }

    update(t) {
      if (this.keys.length === 0) return

      // 範囲外（前/後）
      if (t <= this.keys[0].t) {
        this.setter(this.keys[0].v, this.getter())
        return
      }
      const K = this.keys
      const last = K[K.length - 1]
      if (t >= last.t) {
        this.setter(last.v, this.getter())
        return
      }

      // 区間を探す（t_i <= t < t_{i+1}）
      let i = (this._lastIndex >= 0 && this._lastIndex < K.length - 1) ? this._lastIndex : 0

      // 前フレームからの継続探索をするなら _lastIndex を使って微最適化も可
      for (; i < K.length - 1; i++) {
        if (t >= K[i].t && t < K[i + 1].t) break
      }

      this._lastIndex = i

      const key0 = K[i], key1 = K[i + 1]

      // ステップ（hold）指定があれば v = k0.v で維持
      if (key0.interpolation === "hold") {
        this.setter(key0.v, this.getter())
        return
      }

      // 線形 or イージング補間
      const ease = key0.ease || this.defaultEase
      const span = Math.max(1, (key1.t - key0.t)) // 0で割ることを防ぐ
      let process = clamp01((t - key0.t) / span)
      process = ease(process)

      const v = lerp(key0.v, key1.v, process)
      this.setter(v, this.getter())
    }
  }


  scene = {
    1: {
      init: () => {
        GM.reset()
        console.log('scene 1 init')

        const testEvent = {
          update: function () {
            console.log('now playing test event, all player should be stopped')
          },


        }

        GM.registry.set("testWorld", new BlockWorld())

        GM.registry.set("charA", new Player3D(GM.registry.get('testWorld')))
        GM.registry.set("testControl", new Controller3D(GM.registry.get('charA')))

        GM.registry.get('testControl').tags.add(eventID.eventStop)
        GM.registry.get('charA').objectList.push(GM.registry.get('testControl'))

        GM.registry.set('ccamera', new Camera2_5(GM.registry.get('charA')))
        GM.registry.get('ccamera').drawList.push(GM.registry.get('testWorld'))
        GM.registry.get('ccamera').drawList.push(GM.registry.get('charA'))

        GM.objectList.push(GM.registry.get('testWorld'))
        GM.objectList.push(GM.registry.get('ccamera'))
        GM.objectList.push(GM.registry.get('charA'))

        GM.drawList.push(GM.registry.get('ccamera'))




      }
    }
  }

</script>



<script id="3d rayCaster Voxel world engine">
  class GameManager extends GameObject {
    constructor(name = 'GM', id = 'GM') {
      super(name, id)

      this.flatUpdateList = []//そのままUpdateリスト。じゃないと毎回重い
      this.flatDrawList = []//そのままDrawリスト
      this._needsRebuild = true // render queue rebuild
      this.camera = { // default scene camera 汚いかも
        update: () => { },
        draw: () => {
          this.flatDrawList.forEach(e => {
            e.draw?.()
          })
        },
      }
      this.counters = [] // 最初のUpdateListじゃないかな
      this.register = new Map()//外部読み込み用
      console.log('[SYSTEM]game manager instanced, equip the EventManager if needed')

      this.eventHub = new EventHub()
      EventHub.getEventHandler(this)
    }

    static emitEvent(_typeName, _sender, _data, _target = GM) {
      if (!_target) return
      _target.eventHub.emit(_typeName, _sender, _data)
    }

    update_self() {
      if (this._needsRebuild) this._rebuildFlatLists()

      this.camera.update()
      // delayed event 
      //this.dealEvent?.()
      this.eventHub.dealEvent(this)
      // counterはInputと同様、Eventの類
      this.gameLoop_input?.()
      // 予測型コリジョン判定用
      this.gameLoop_check?.()
      // 数値の適応と更新
      this.gameLoop_update?.()

      this.flatUpdateList.forEach(e => {
        e.update?.()
      })
    }

    draw() {
      ctx0.clearRect(0, 0, W, H)

      //this.camera.draw()
      this.flatDrawList.forEach(e => {
        e.draw?.()
      })

      //showHTML(this.showEventQueue(), 'event')

    }

    _rebuildFlatLists() {
      //console.clear()
      console.log('[when GM rebuild] GM rebuild update and draw Lists')
      this.objectListTXT = null
      this.flatUpdateList.length = 0
      this.flatDrawList.length = 0

      const stack = []

      // ルート配列は末尾→先頭の順で push（こうすると pop で先頭から処理される）
      for (let i = this.objectList.length - 1; i >= 0; i--) {
        stack.push(this.objectList[i])
      }

      const drawStack = [...stack]

      while (stack.length) {
        const node = stack.pop();// ここで“正しい順番”に取り出される
        if (!node.updatePause) {
          this.flatUpdateList.push(node)

          const ch = node.objectList
          if (ch && ch.length) {
            // 子は「末尾から先頭へ」push していく
            // → pop したときに先頭の子から処理され、結果として親→子の順を維持
            for (let i = ch.length - 1; i >= 0; i--) stack.push(ch[i])
          }
        }
      }

      while (drawStack.length) {
        const node = drawStack.pop();// ここで“正しい順番”に取り出される
        if (!node.drawPause) {
          this.flatDrawList.push(node)
          const ch = node.objectList
          if (ch && ch.length) {
            // 子は「末尾から先頭へ」push していく
            // → pop したときに先頭の子から処理され、結果として親→子の順を維持
            for (let i = ch.length - 1; i >= 0; i--) drawStack.push(ch[i])
          }
        }
      }

      this._needsRebuild = false

      console.log(`[when GM rebuild] gathering reference`)
      //再構築するたびに下やるの？？
      this.flatUpdateList.forEach(e => {
        e.gatherReference?.(this)

      })
    }

    showList(List, level = 0) {
      if (level == 0)
        if (!this._needsRebuild)
          if (this.objectListTXT)
            return false
          else
            console.log('[when GM rebuild] GM printed the updatedw list')


      this.objectListTXT = 'txt'
      let result = ''
      if (!level) result = 'GM Root\n'
      List.forEach(e => {
        // インデント作成
        let indent = '  | '

        if (level) {

          indent += '  | '.repeat(level - 1)
        } else {
          indent = '  | '.repeat(level)
        }
        if (e.updatePause) indent += 'x '
        else indent += 'o '
        if (e.drawPause) indent += 'x '
        else indent += 'o '

        indent += ' '
        let tags = ''
        if (e.tags)
          tags = Array.from(e.tags).join(" | ")


        // 自分を出力
        result += `${indent}${e.name ? e.name : e.constructor.name}: ( ${tags} )\n`

        // 子リストがあれば再帰
        if (!e.folded && e.objectList) {
          result += this.showList(e.objectList, level + 1)
        } else if (e.folded)
          result += 'folded\n'
      })

      this.objectListTXT = result
      return this.objectListTXT
    }

    update_counters() {
      // 
      for (let _c of this.counters)
        if (_c.pause === false)
          _c.update()
      this.counters = this.counters.filter((_c) => _c.end == false)
    }
    showCounters() {
      let _table = ""
      for (let _c of this.counters) {
        _table += _c.msg + ":" + _c.time + "/" + _c.endTime + "\n"
      }
      return _table
    }
    addCounter({
      msg = "[untitled]",
      target = undefined,
      endTime = 10,
      loop = false,
      processCall = null,
      endCall = () => {
        this.end = true
      },

    } = {}) {
      let _temp = new Counter({
        endTime: endTime,
        target: target,
        loop: loop,
        msg: msg,
        processCall: processCall,
        endCall: endCall,
      })
      this.counters.push(_temp)
      return _temp
    }

    // pause by tag
    switchPauseByTag(tag, pause = true, type = 0, List = this.objectList) {
      console.log(`set ${tag}.updatePause = ${pause}`)
      const mapping = {
        0: ["updatePause"],
        1: ["drawPause"],
        default: ["updatePause", "drawPause"]
      }
      this.traverse(List, (e) => {
        if (e.tags?.has(tag)) {
          (mapping[type] ?? mapping.default).forEach(key => {
            e[key] = pause
          })
        }
      })

      this._needsRebuild = true
    }

    removeByTag(tag, list = this.objectList) {
      for (let i = list.length - 1; i >= 0; i--) { // 逆順で安全に削除
        const obj = list[i]
        if (!obj.tags) continue
        if (obj.tags.has(tag)) {
          obj.destroy?.()
          list.splice(i, 1); // 該当オブジェクトを削除
        }
        else if (obj.objectList) {
          // 子リストがある場合は再帰
          this.removeByTag(tag, obj.objectList)
        }
      }
      this._needsRebuild = true

    }
    reset() {
      this.registry = new Map()
      this.objectList.length = 0
      this.drawList.length = 0
      this.flatUpdateList.length = 0
      this.flatDrawList.length = 0

    }

  }

  // new Event System
  class EventHub {
    constructor() { this.eventQueue = [] }

    emit(_typeName, _sender, _data) {
      this.eventQueue.push({ typeName: _typeName, sender: _sender, data: _data, consumed: false })
    }

    dealEvent(_rootNode) {
      const q = this.eventQueue
      this.eventQueue = []
      for (const ev of q) {
        EventHub.broadcast(_rootNode, ev)
      }
    }

    static broadcast(_node, _ev) {

      if (!_node || _ev.consumed) return
      _node.handle?.(_ev)
      if (_ev.consumed) return

      if (_node.objectList) {
        for (const child of _node.objectList) {
          EventHub.broadcast(child, _ev)
          if (_ev.consumed) return
        }
      }

    }

    static getEventHandler(target) {
      target.handlers = new Map()

      target.on = function (_typeName, _fn) {
        this.handlers.set(_typeName, _fn)
        return this
      }

      target.handle = function (_ev) {
        const fn = this.handlers.get(_ev.typeName)
        if (!fn) return false
        fn(_ev)
        return true
      }
    }

  }


  /* =========================
     ベクトル & 数学ユーティリティ
     ========================= */
  class Math2 {
    constructor() { }
    static clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    static mix(a, b, t) { return a + (b - a) * t; }
    static within(v, a, b) { return v > a && v < b }
    static fract(v) { return v - Math.floor(v) }
  }

  class Vec3 {
    constructor(x = 0, y = 0, z = 0) { this.x = x; this.y = y; this.z = z; }
    set(x, y, z) { this.x = x; this.y = y; this.z = z; return this; }
    reset() { this.x = 0; this.y = 0; this.z = 0 }

    add(v) { this.x += v.x; this.y += v.y; this.z += v.z; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; this.z -= v.z; return this; }
    mul(s) { this.x *= s; this.y *= s; this.z *= s; return this; }

    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z
    }
    cross(v) {
      return new Vec3(
        this.y * v.z - this.z * v.y,
        this.z * v.x - this.x * v.z,
        this.x * v.y - this.y * v.x
      )
    }
    len() { return Math.hypot(this.x, this.y, this.z); }
    norm() { const l = this.len() || 1; this.x /= l; this.y /= l; this.z /= l; return this; }
    clone() { return new Vec3(this.x, this.y, this.z); }

    static distsq(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const dz = a.z - b.z;
      return dx * dx + dy * dy + dz * dz;
    }

    // static であれば、Instanceしなくてもいいか
    // yaw:Left,Right ptich:up,down
    static fromYawPitch(yawDeg, pitchDeg) {
      const yaw = yawDeg * Math.PI / 180, pitch = pitchDeg * Math.PI / 180
      const cos_yaw = Math.cos(yaw), sin_yaw = Math.sin(yaw)
      const cos_pitch = Math.cos(pitch), sin_pinch = Math.sin(pitch)
      // 前方: XZ 平面をヨー、Y はピッチ
      return new Vec3(sin_yaw * cos_pitch, -sin_pinch, cos_yaw * cos_pitch).norm()
    }
  }

  /* =========================
     ワールド（world[x][y][z]）
     ========================= */
  class worldBlock3D {
    constructor(width = 48, height = 24, depth = 48) {
      this.width = width
      this.height = height
      this.depth = depth
      this.worldXYZ = worldBlock3D.createWorld(Math.random(), this.width, this.height, this.depth)
    }
    static createWorld(seed = Math.random(), _width, _height, _depth) {
      const __W = _width
      const __H = _height
      const __D = _depth
      // 三次元配列アクセスの見た目を保ちつつ、内部は1D配列で高速化
      // 0〜255の整数
      const data = new Uint8Array(__W * __H * __D)
      const idx = (x, y, z) => (y * __D + z) * __W + x

      // y=0：地面（石）
      for (let x = 0; x < __W; x++)
        for (let z = 0; z < __D; z++) {
          data[idx(x, 9, z)] = 2
          data[idx(x, 0, z)] = 2
        }

      // 簡易の高さマップ＋構造物
      const rng = worldBlock3D.mulberry32(Math.floor(seed * 0x7fffffff))
      // 起伏（草土）
      for (let x = 0; x < __W; x++) {
        for (let z = 0; z < __D; z++) {
          const h = 1 + Math.floor(5 * worldBlock3D.noise2d(x * 0.12, z * 0.12, rng))
          for (let y = 1; y < Math.min(__H, h + 1); y++) data[idx(x, y, z)] = 1
        }
      }
      // 柱や壁（石/木）
      for (let i = 0; i < 220; i++) {
        const x = 2 + Math.floor(rng() * (__W - 4))
        const z = 2 + Math.floor(rng() * (__D - 4))
        const ht = 3 + Math.floor(rng() * 8)
        const id = (rng() < 0.7) ? 2 : 3
        for (let y = 1; y < Math.min(__H, ht); y++) data[idx(x, y, z)] = id
        // たまに横へ延ばす
        if (rng() < 0.3 && x + 1 < __W) for (let y = 1; y < Math.min(__H, ht - 1); y++) data[idx(x + 1, y, z)] = id
        if (rng() < 0.3 && z + 1 < __D) for (let y = 1; y < Math.min(__H, ht - 1); y++) data[idx(x, y, z + 1)] = id
      }
      // 空の広場
      for (let x = 18; x < 30; x++)
        for (let z = 18; z < 30; z++)
          for (let y = 1; y < 6; y++)
            data[idx(x, y, z)] = 0

      // ラッパー：world[x][y][z] 風アクセスを提供
      const wrapperXYZ = []
      for (let x = 0; x < __W; x++) {
        wrapperXYZ[x] = []
        for (let y = 0; y < __H; y++) {
          wrapperXYZ[x][y] = []
          for (let z = 0; z < __D; z++) {
            Object.defineProperty(wrapperXYZ[x][y], z, {
              get() { return data[idx(x, y, z)]; },
              set(v) { data[idx(x, y, z)] = v | 0; },
              enumerable: true
            })
          }
        }
      }
      wrapperXYZ._data = data; wrapperXYZ._idx = idx
      return wrapperXYZ
    }

    static noise2d(x, z, rng) {
      // 簡易な値ノイズ（勾配なし）：タイル状に乱数→双線形補間
      const xi = Math.floor(x), zi = Math.floor(z)
      const xf = x - xi, zf = z - zi
      function hash(i, j) { // 位置依存の擬似乱数
        const seed = ((i * 73856093) ^ (j * 19349663)) >>> 0
        const r = worldBlock3D.mulberry32(seed)()
        return r
      }
      const v00 = hash(xi, zi), v10 = hash(xi + 1, zi), v01 = hash(xi, zi + 1), v11 = hash(xi + 1, zi + 1)
      const v0 = v00 + (v10 - v00) * xf
      const v1 = v01 + (v11 - v01) * xf
      return v0 + (v1 - v0) * zf
    }

    static inBounds(x, y, z, _world) { return x >= 0 && x < _world.width && y >= 0 && y < _world.height && z >= 0 && z < _world.depth }

    static isSolid(x, y, z, _world) {
      return worldBlock3D.inBounds(x, y, z, _world) ? _world.worldXYZ[x][y][z] !== 0 : false
    }

    static mulberry32(a) {
      return function () {
        let t = a += 0x6D2B79F5
        t = Math.imul(t ^ (t >>> 15), t | 1)
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61)
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296
      }
    }

    static moveAxisCheck_CenterType(_world, position3, axis, delta, size3, target = null) {
      const block = 1
      const pw = size3.x
      const ph = size3.y
      const pd = size3.z
      const np = { x: position3.x, y: position3.y, z: position3.z }
      np[axis] += delta
      // この計算…一回だけでいいよね？
      // いやだめだ、軸ごとにPositionの更新が入るので、引っかかるBlockも更新されるべき
      const eps = 0.001// Math.floorは[0,1)なので、max側にくっつけた状態が良くない
      const minX = Math.floor((np.x - pw / 2) / block)
      const maxX = Math.floor((np.x + pw / 2 - eps) / block)
      const minY = Math.floor((np.y - ph / 2) / block)
      const maxY = Math.floor((np.y + ph / 2 - eps) / block)
      const minZ = Math.floor((np.z - pd / 2) / block)
      const maxZ = Math.floor((np.z + pd / 2 - eps) / block)

      for (let bx = minX; bx <= maxX; bx++) {
        for (let by = minY; by <= maxY; by++) {
          for (let bz = minZ; bz <= maxZ; bz++) {
            if (worldBlock3D.isSolid(bx, by, bz, _world)) {
              // 衝突補正: 進行方向に応じて位置をブロックの端に揃える
              // epsを入れないとバグる。「再衝突ループ」が起こってるかららしいけど分からない
              if (axis === 'x') {
                if (delta > 0) position3[axis] = bx * block - pw / 2 - eps
                if (delta < 0) position3[axis] = (bx + 1) * block + pw / 2 + eps
              } else if (axis === 'y') {
                if (delta > 0) position3[axis] = by * block - ph / 2 - eps
                if (delta < 0) position3[axis] = (by + 1) * block + ph / 2 + eps
              } else if (axis === 'z') {
                if (delta > 0) position3[axis] = bz * block - pd / 2 - eps;       // top
                if (delta < 0) position3[axis] = (bz + 1) * block + pd / 2 + eps

              }
              return 0; // 衝突したら移動終了
            }
          }
        }
      }


      position3[axis] += delta

      return delta
    }

    static normalToFace() {

    }
  }


  class cameraRCV extends GameObject {
    constructor(px = 10.5, py = 6.0, pz = 10.5, yaw = 0, pitch = -1, world) {
      super('cameraRCV', 'cameraRCV')
      this.position.set(px, py, pz)
      this.yaw = yaw
      this.pitch = pitch
      this.delta = new Vec3(0, 0, 0)
      this.nextDelta = new Vec3(0, 0, 0)
      this.vecForward = new Vec3(0, 0, 0)
      this.vecRight = new Vec3(0, 0, 0)
      this.vecUp = new Vec3(0, 0, 0)

      this.world = world
      this.fovDeg = 80

      this.tanHalfY = Math.tan(this.fovDeg * Math.PI / 360)
      this.moveSpeed = 0.04
      this.rotSpeed = 1



    }

    update() {

      // update for rendering
      this.vecForward = Vec3.fromYawPitch(this.yaw, this.pitch)
      this.vecRight = this.vecForward.cross(new Vec3(0, 1, 0)).norm()
      this.vecUp = this.vecRight.cross(this.vecForward)



      //controller


      let PRes = 0 // acc-result of key pressing
      if (keys.turnLeft.pressed) PRes--
      if (keys.turnRight.pressed) PRes++
      if (PRes > 0) {
        this.yaw -= this.rotSpeed
      } else if (PRes < 0) {
        this.yaw += this.rotSpeed
      }
      if (this.yaw > 360)
        this.yaw = 0
      else if (this.yaw < 0)
        this.yaw = 360


      PRes = 0
      if (keys.turnDown.pressed) PRes--
      if (keys.turnUp.pressed) PRes++
      if (PRes > 0) {
        this.pitch = Math2.clamp(this.pitch - this.rotSpeed, -89.5, 89.5)
      } else if (PRes < 0) {
        this.pitch = Math2.clamp(this.pitch + this.rotSpeed, -89.5, 89.5)
      }



      const dirForward = Vec3.fromYawPitch(this.yaw, 0); // -Z基準ではなく、既に前方
      // スクリーン座標系（右・上）
      const worldUp = new Vec3(0, 1, 0)
      const dirRight = dirForward.cross(worldUp).norm()

      // XZ軸では、摩擦力MAX設定
      this.delta.x = 0
      this.delta.z = 0

      PRes = 0
      if (keys.left.pressed) { PRes -= 1 }
      if (keys.right.pressed) { PRes += 1 }
      if (PRes > 0)
        this.nextDelta = dirRight.mul(this.moveSpeed)
      else if (PRes < 0)
        this.nextDelta = dirRight.mul(-this.moveSpeed)
      else { this.nextDelta.reset() }
      this.delta.add(this.nextDelta)

      PRes = 0
      if (keys.up.pressed) { PRes += 1 }
      if (keys.down.pressed) { PRes -= 1 }
      if (PRes > 0)
        this.nextDelta = dirForward.mul(this.moveSpeed)
      else if (PRes < 0)
        this.nextDelta = dirForward.mul(-this.moveSpeed)
      else { this.nextDelta.reset() }
      this.delta.add(this.nextDelta)

      GameManager.emitEvent('ResolveMovement', this)


    }



  }

  class RendererRCV {
    constructor(_currentCamera, _currentWorld, _canvas, _statsEl) {
      this.currentCamera = _currentCamera
      this.currentWorld = _currentWorld
      this.canvas = _canvas
      this.FPSstats = _statsEl
      this.ctx = this.canvas.getContext('2d', { alpha: false, desynchronized: true, willReadFrequently: true })
      this.lightDir = new Vec3(0.6, -0.8, 0.2).norm()
      this.worldUp = new Vec3(0, 1, 0)
      this.renderStartTime = 0
      this.internalScale = 4; // 解像度縮小（1=フル, 2=1/2, 4=1/4）
      this.zw = Math.floor(_canvas.width / this.internalScale)
      this.zh = Math.floor(_canvas.height / this.internalScale)
      this.zBuffer = new Float32Array(this.zw * this.zh)
    }
    draw() {
      let maxDistance = 10
      let maxSteps = 512
      let exposure = 1.10
      let showNormals = false

      const skyTop = [0, 0, 0];  // 空（上）
      const skyHzn = [0, 0, 0];  // 空（地平）
      const ambient = 0.0

      const w = Math.floor(this.canvas.width / this.internalScale), h = Math.floor(this.canvas.height / this.internalScale)

      // カメラ基底ベクトル
      const dirForward = Vec3.fromYawPitch(this.currentCamera.yaw, this.currentCamera.pitch); // -Z基準ではなく、既に前方

      // スクリーン座標系（右・上）
      const worldUp = this.worldUp
      const dirRight = dirForward.cross(worldUp).norm()
      const dirUp = dirRight.cross(dirForward).norm()


      const fov = this.currentCamera.fovDeg * Math.PI / 180
      const halfW = Math.tan(fov / 2)
      const aspect = w / h


      this.zBuffer.fill(Infinity)

      // 画面の各ピクセルにレイ
      if (this.FPSstats) this.renderStartTime = performance.now()

      const _img = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height); // 直接フル解像度を塗る（拡大補間なし）

      for (let py_low = 0; py_low < h; py_low++) {
        const vy = (1 - 2 * (py_low + 0.5) / h) * halfW; // [-halfW, halfW]
        for (let px_low = 0; px_low < w; px_low++) {
          const vx = (2 * (px_low + 0.5) / w - 1) * halfW * aspect

          // レイ方向
          const dir = new Vec3(
            dirForward.x + dirRight.x * vx + dirUp.x * vy,
            dirForward.y + dirRight.y * vx + dirUp.y * vy,
            dirForward.z + dirRight.z * vx + dirUp.z * vy
          ).norm()

          const lightDir = dir // horror game light. no direct light!


          const result = RendererRCV.raycastVoxel(dir, maxDistance, maxSteps, this.currentWorld, this.currentCamera)

          let r, g, b
          if (result.hit) {


            // 面法線
            const n = result.normal
            // 色

            // ここはサンプリングもしたい
            let col = RendererRCV.getBlockColor_texture(result.id, n, result.hitPos)


            // 照明（ランバート）
            const ndl = Math.max(0, -(n.x * lightDir.x + n.y * lightDir.y + n.z * lightDir.z))
            let lit = ambient + (1 - ambient) * ndl
            // 距離フォグ
            const fogT = Math2.clamp(result.t / maxDistance, 0, 1)
            const heightFogT = 0//Math2.clamp(result.hitPos.y / 20, 0, 1)
            const sky = [
              Math2.mix(skyHzn[0], skyTop[0], 0.5 - 0.5 * dir.y), // 視線が上なら空色を強く
              Math2.mix(skyHzn[1], skyTop[1], 0.5 - 0.5 * dir.y),
              Math2.mix(skyHzn[2], skyTop[2], 0.5 - 0.5 * dir.y)
            ]

            if (showNormals) {
              // 法線可視化モード
              col = [(n.x * 0.5 + 0.5), (n.y * 0.5 + 0.5), (n.z * 0.5 + 0.5)]
              lit = 1.0
            }

            r = Math2.mix(Math2.mix(col[0] * lit * exposure, sky[0], (fogT)), 1, (heightFogT)) * 255 | 0
            g = Math2.mix(Math2.mix(col[1] * lit * exposure, sky[1], (fogT)), 1, (heightFogT)) * 255 | 0
            b = Math2.mix(Math2.mix(col[2] * lit * exposure, sky[2], (fogT)), 1, (heightFogT)) * 255 | 0

            const cosTheta = dir.dot(dirForward)
            const depthCam = result.t * cosTheta

            RendererRCV.fillImageData_depth(this.canvas, _img.data,
              testRenderer.zBuffer, testRenderer.zw, testRenderer.zh, depthCam,
              this.internalScale, px_low, py_low, r, g, b)
          } else {
            // スカイ
            const t = 0.5 - 0.5 * dir.y; // 上ほど skyTop、下ほど skyHzn
            r = Math2.mix(skyHzn[0], skyTop[0], t) * 255 | 0
            g = Math2.mix(skyHzn[1], skyTop[1], t) * 255 | 0
            b = Math2.mix(skyHzn[2], skyTop[2], t) * 255 | 0

            RendererRCV.fillImageData_depth(this.canvas, _img.data,
              testRenderer.zBuffer, testRenderer.zw, testRenderer.zh, maxDistance,
              this.internalScale, px_low, py_low, r, g, b)
          }
        } // end for px
      } // end for py

      this.ctx.putImageData(_img, 0, 0)


      // render FPS
      if (this.FPSstats) {
        const dt = (performance.now() - this.renderStartTime)
        this.FPSstats.textContent = `
        FPS: ${(1000 / dt).toFixed(1)} | 
        render=${dt.toFixed(1)}ms | ${Math.floor(this.canvas.width / this.internalScale)}x${Math.floor(this.canvas.height / this.internalScale)} (scale ${this.internalScale}x)
        pos=(${this.currentCamera.position.x.toFixed(2)}, ${this.currentCamera.position.y.toFixed(2)}, ${this.currentCamera.position.z.toFixed(2)}) 
        yaw=${this.currentCamera.yaw.toFixed(1)} 
        pitch=${this.currentCamera.pitch.toFixed(1)}`
      }
    }

    static raycastVoxel(dir, maxDistance = 90, maxSteps = 1024, _currentWorld, _camera) {
      /* =========================
       DDA レイキャスト（Amanatides & Woo）
       ========================= */
      /**
       * @param {Vec3} origin ワールド座標
       * @param {Vec3} dir    正規化方向
       * @param {number} maxDistance 最大距離
       * @param {number} maxSteps    ステップ上限
       * @returns { hit:boolean, t:number, vox?:{x,y,z}, normal?:{x,y,z}, id?:number }
       */

      const _worldXYZ = _currentWorld.worldXYZ
      const origin = _camera.position

      let vx = Math.floor(origin.x), vy = Math.floor(origin.y), vz = Math.floor(origin.z)

      // 各軸の進行符号
      const stepX = dir.x > 0 ? 1 : (dir.x < 0 ? -1 : 0)
      const stepY = dir.y > 0 ? 1 : (dir.y < 0 ? -1 : 0)
      const stepZ = dir.z > 0 ? 1 : (dir.z < 0 ? -1 : 0)

      // Δt（1ボクセル進むのに必要な t 増分）
      const tDeltaX = stepX !== 0 ? Math.abs(1 / dir.x) : Infinity
      const tDeltaY = stepY !== 0 ? Math.abs(1 / dir.y) : Infinity
      const tDeltaZ = stepZ !== 0 ? Math.abs(1 / dir.z) : Infinity

      // tMax: 次の格子境界までの t
      let tMaxX, tMaxY, tMaxZ
      if (stepX > 0) tMaxX = (Math.floor(origin.x) + 1 - origin.x) * tDeltaX
      else if (stepX < 0) tMaxX = (origin.x - Math.floor(origin.x)) * tDeltaX
      else tMaxX = Infinity

      if (stepY > 0) tMaxY = (Math.floor(origin.y) + 1 - origin.y) * tDeltaY
      else if (stepY < 0) tMaxY = (origin.y - Math.floor(origin.y)) * tDeltaY
      else tMaxY = Infinity

      if (stepZ > 0) tMaxZ = (Math.floor(origin.z) + 1 - origin.z) * tDeltaZ
      else if (stepZ < 0) tMaxZ = (origin.z - Math.floor(origin.z)) * tDeltaZ
      else tMaxZ = Infinity

      // 始点がブロック内→最初の境界を跨いでから判定（内部からの視点でも安定）
      let t = 0
      let lastAxis = null

      for (let i = 0; i < maxSteps; i++) {
        if (tMaxX < tMaxY) {
          if (tMaxX < tMaxZ) { vx += stepX; t = tMaxX; tMaxX += tDeltaX; lastAxis = 'x'; }
          else { vz += stepZ; t = tMaxZ; tMaxZ += tDeltaZ; lastAxis = 'z'; }
        } else {
          if (tMaxY < tMaxZ) { vy += stepY; t = tMaxY; tMaxY += tDeltaY; lastAxis = 'y'; }
          else { vz += stepZ; t = tMaxZ; tMaxZ += tDeltaZ; lastAxis = 'z'; }
        }
        if (t > maxDistance) break
        if (!worldBlock3D.inBounds(vx, vy, vz, _currentWorld)) return { hit: false, t }

        if (worldBlock3D.isSolid(vx, vy, vz, _currentWorld)) {
          let nx = 0, ny = 0, nz = 0
          if (lastAxis === 'x') nx = -stepX
          else if (lastAxis === 'y') ny = -stepY
          else nz = -stepZ
          return {
            hit: true, t,
            hitPos: { x: origin.x + dir.x * t, y: origin.y + dir.y * t, z: origin.z + dir.z * t },
            vox: { x: vx, y: vy, z: vz },
            normal: { x: nx, y: ny, z: nz },
            id: _worldXYZ[vx][vy][vz]
          }
        }
      }
      return { hit: false, t }
    }
    // just enjoy making static method. help me to figure out the coupling
    static fillImageData(_canvas, _imgData,
      _internalScale, px_low, py_low,//低解像度x,y座標
      r, g, b, a = 255) {
      // 書き込み（内部縮小→スケール描画：最近傍）
      // ここでは直接フル解像度に nearest 拡大して塗る
      const x0 = px_low * _internalScale | 0, y0 = py_low * _internalScale | 0

      // fill rectangle
      for (let iy = 0; iy < _internalScale; iy++) {
        let RGBAoffset = ((y0 + iy) * _canvas.width + x0) * 4
        for (let ix = 0; ix < _internalScale; ix++) {
          _imgData[RGBAoffset] = Math.max(0, Math.min(255, (r * 255) | 0))
          _imgData[RGBAoffset + 1] = Math.max(0, Math.min(255, (g * 255) | 0))
          _imgData[RGBAoffset + 2] = Math.max(0, Math.min(255, (b * 255) | 0))
          _imgData[RGBAoffset + 3] = 255
          RGBAoffset += 4
        }
      }
    }



    // 書き込み（内部縮小→スケール描画：最近傍）
    static fillImageData_depth(_canvas, _imgData,
      _zBuffer, zw, zh, _zDepth,// z-buffer scale
      _internalScale, px_low, py_low,//低解像度x,y座標
      r, g, b, a = 255) {

      // working on...fill z-Buffer
      const i = zw * py_low + px_low
      // Big = Far
      if (_zBuffer[i] <= _zDepth) return
      _zBuffer[i] = _zDepth

      // ここでは直接フル解像度に nearest 拡大して塗る
      const x0 = px_low * _internalScale | 0, y0 = py_low * _internalScale | 0
      for (let iy = 0; iy < _internalScale; iy++) {
        let RGBAoffset = ((y0 + iy) * _canvas.width + x0) * 4
        for (let ix = 0; ix < _internalScale; ix++) {
          _imgData[RGBAoffset] = Math.max(0, Math.min(255, r))
          _imgData[RGBAoffset + 1] = Math.max(0, Math.min(255, g))
          _imgData[RGBAoffset + 2] = Math.max(0, Math.min(255, b))
          _imgData[RGBAoffset + 3] = Math.max(0, Math.min(255, a))
          RGBAoffset += 4
        }
      }
    }



    // 0=空気, 1=草土, 2=石, 3=木
    // block ID data
    static getBlockColor(id, normal) {
      // ブロックごとのベース色（sRGB→linearっぽく扱う簡易）
      let c
      switch (id) {
        case 1: // 草土
          // 上面っぽく少し緑を強める
          const g = 0.38 + 0.22 * Math2.clamp(normal.y, 0, 1)
          c = [0.18, g, 0.12]; break
        case 2: // 石
          c = [0.48, 0.50, 0.52]; break
        case 3: // 木
          c = [0.40, 0.28, 0.14]; break
        default:
          c = [0.8, 0.0, 0.8]
      }
      return c
    }

    static getBlockColor_texture(id, normal, pos) {
      // ブロックごとのベース色（sRGB→linearっぽく扱う簡易）

      let c
      switch (id) {
        case 1: // 草土
          // 上面っぽく少し緑を強める
          if (normal.y > 0) {
            const u = Math2.fract(pos.z)
            const v = Math2.fract(pos.x)
            const res = RendererRCV.UVTextureSampleRGB(woodFloor_32RGB, u, v, 32)
            c = [res.r / 255.0, res.g / 255.0, res.b / 255.0]

          } else {
            c = [0.18, 1, 0.12];
          }
          break
        case 2: // 石
          c = [1, 1, 1]
          if (normal.x > 0) {
          } else if (normal.x < 0) {
            const u = pos.z - Math.floor(pos.z)
            const v = 1 - pos.y + Math.floor(pos.y)
            const res = RendererRCV.UVTextureSampleRGB(woodFloor_32RGB, u, v, 32)
            c = [res.r / 255.0, res.g / 255.0, res.b / 255.0]
          } else if (normal.y > 0) {

          } else if (normal.y < 0) {
          } else if (normal.z > 0) {

          } else if (normal.z < 0) {

          }
          break
        case 3: // 木
          c = [0.40, 0.28, 0.14]; break
        default:
          c = [0.8, 0.0, 0.8]
      }

      return c
    }


    static UVSamplingRGBA(tex, u, v, texSizeX, texSizeY = texSizeX) {
      const U = Math.floor(u * texSizeX)
      const V = Math.floor(v * texSizeY)
      return {
        r: tex[V * texSizeX + U],
        g: tex[V * texSizeX + U + 1],
        b: tex[V * texSizeX + U + 2],
        a: 255,
      }
    }
    static UVSamplingBWA(tex, u, v, texSizeX, texSizeY = texSizeX) {
      const U = Math.floor(u * texSizeX)
      const V = Math.floor(v * texSizeY)
      const c = tex[V * texSizeX + U]
      if (c >= 0) {
        return {
          r: c,
          g: c,
          b: c,
          a: 255,
        }
      } else {
        return {
          r: 0,
          g: 0,
          b: 0,
          a: 0,
        }
      }
    }

    static verticesProjection(v, sv, _cameraRCV) {

      const camForward = _cameraRCV.vecForward
      const camRight = _cameraRCV.vecRight
      const camUp = _cameraRCV.vecUp

      const vector = v.clone().sub(_cameraRCV.position)
      // camera coord
      const project = new Vec3(
        vector.dot(camRight), vector.dot(camUp), vector.dot(camForward)
      )

      // 近すぎる
      if (project.z <= 1e-6) return


      // clip coord

      const tanHalfY = _cameraRCV.tanHalfY
      const tanHalfX = tanHalfY * W / H
      project.set(
        project.x / (tanHalfX * project.z),
        project.y / (tanHalfY * project.z),
        project.z)


      // そのまま上書きする?
      return sv.set(
        (project.x * 0.5 + 0.5) * W,
        (0.5 - project.y * 0.5) * H,
        project.z)


    }

    static UVTextureSample(_tex, u/*0.0~1.0*/, v/*0.0~1.0*/, _texSampleSize) {
      const U = Math.floor(u * (_texSampleSize - 1))
      const V = Math.floor(v * (_texSampleSize - 1))
      return _tex[V * _texSampleSize + U]
    }

    static UVTextureSampleRGB(_tex, u/*0.0~1.0*/, v/*0.0~1.0*/, _texSampleSize) {
      const U = Math.floor(u * (_texSampleSize - 1))
      const V = Math.floor(v * (_texSampleSize - 1))
      const i = (V * _texSampleSize + U) * 3
      return {
        r: _tex[i],
        g: _tex[i + 1],
        b: _tex[i + 2]
      }
    }

    // working on ... unfinished
    // なんか　internal Scale 繰り返しでやってるのが気になるし
    // UVのサンプリングも減ら減るはず。
    static drawRectSpriteBW(
      _canvas, _imgData,
      _tex, _texSampleSize,
      x0, x1, y0, y1,/*true screen coord*/_zDepth,
      _zBuffer, _zw, _zh,
      _internalScale = 4
    ) {

      const px0 = x0 / _internalScale | 0,
        px1 = x1 / _internalScale | 0,
        py0 = y0 / _internalScale | 0,
        py1 = y1 / _internalScale | 0
      if (px1 === px0 || py1 === py0) return

      const sx0 = Math.max(x0, 0) / _internalScale | 0,
        sx1 = Math.min(x1, _canvas.width) / _internalScale | 0,
        sy0 = Math.max(y0, 0) / _internalScale | 0,
        sy1 = Math.min(y1, _canvas.height) / _internalScale | 0
      const drawHeight = (sy1 - sy0)
      const drawWidth = (sx1 - sx0)

      if (drawHeight <= 0 || drawWidth <= 0)
        return
      for (let iy = 0; iy < drawHeight; iy += 1) {
        const v = (sy0 + iy - py0) / (py1 - py0) // FIX!!!
        for (let ix = 0; ix < drawWidth; ix += 1) {
          const u = (sx0 + ix - px0) / (px1 - px0) // FIX!!!
          //
          const res = RendererRCV.UVTextureSample(_tex, u, v, _texSampleSize)
          //          
          if (res == -1) continue
          RendererRCV.fillImageData_depth(_canvas, _imgData,
            _zBuffer, _zw, _zh, _zDepth,
            _internalScale, sx0 + ix, sy0 + iy,
            res, res, res)


        }
      }
      // put Image Data
    }

    static drawRectSpriteRGB(
      _canvas, _imgData,
      _tex, _texSampleSize,
      x0, x1, y0, y1,/*true screen coord*/_zDepth,
      _zBuffer, _zw, _zh,
      _internalScale = 4
    ) {

      const px0 = x0 / _internalScale | 0,
        px1 = x1 / _internalScale | 0,
        py0 = y0 / _internalScale | 0,
        py1 = y1 / _internalScale | 0
      if (px1 === px0 || py1 === py0) return

      const sx0 = Math.max(x0, 0) / _internalScale | 0,
        sx1 = Math.min(x1, _canvas.width) / _internalScale | 0,
        sy0 = Math.max(y0, 0) / _internalScale | 0,
        sy1 = Math.min(y1, _canvas.height) / _internalScale | 0
      const drawHeight = (sy1 - sy0)
      const drawWidth = (sx1 - sx0)

      if (drawHeight <= 0 || drawWidth <= 0)
        return
      for (let iy = 0; iy < drawHeight; iy += 1) {
        const v = (sy0 + iy - py0) / (py1 - py0) // FIX!!!
        for (let ix = 0; ix < drawWidth; ix += 1) {
          const u = (sx0 + ix - px0) / (px1 - px0) // FIX!!!
          //
          const res = RendererRCV.UVTextureSampleRGB(_tex, u, v, _texSampleSize)
          //          
          RendererRCV.fillImageData_depth(_canvas, _imgData,
            _zBuffer, _zw, _zh, _zDepth,
            _internalScale, sx0 + ix, sy0 + iy,
            res.r, res.g, res.b)


        }
      }
      // put Image Data
    }

  }

  // y-up physicSimulator
  class PhysicSimulator_BlockWorld extends GameObject {
    constructor(_collisionWorld) {
      super()
      this.world = _collisionWorld
      EventHub.getEventHandler(this)

      this.on('ResolveMovement', (ev) => {
        if (!this.world) return console.log('no world to resolve movement')
        const t = ev.sender
        t.delta.y -= 0.004
        t.delta.x = worldBlock3D.moveAxisCheck_CenterType(this.world, t.position, 'x', t.delta.x, { x: 0.4, y: 1.6, z: 0.4 })
        t.delta.z = worldBlock3D.moveAxisCheck_CenterType(this.world, t.position, 'z', t.delta.z, { x: 0.4, y: 1.6, z: 0.4 })
        t.delta.y = worldBlock3D.moveAxisCheck_CenterType(this.world, t.position, 'y', t.delta.y, { x: 0.4, y: 1.6, z: 0.4 })

        t.position.x = Math2.clamp(t.position.x, 0.01, this.world.width - 0.01)
        t.position.y = Math2.clamp(t.position.y, 0.01, this.world.height - 0.01)
        t.position.z = Math2.clamp(t.position.z, 0.01, this.world.depth - 0.01)

      })
    }
  }


</script>

<script id="key mapping">
  // EventID好きなだけ追加
  // 使うのを忘れちゃうｗ
  const eventID = new Proxy({}, (() => {
    let currentID = 0
    const map = new Map()
    return {
      get(target, prop) {

        if (typeof prop === "symbol") return undefined
        if (!map.has(prop)) {
          map.set(prop, currentID++)
        }
        return map.get(prop)
      },
      ownKeys() {
        return Array.from(map.keys())
      },
    }
  })())

  // if(keys.xxx.pressed)これをGameLoopに入れたら連続発火
  // keyMap -> keys
  const keyMap = {
    'a': 'left',
    'd': 'right',
    'w': 'up',
    's': 'down',
    ' ': 'shot',
    'j': 'turnLeft',
    'l': 'turnRight',
    'i': 'turnUp',
    'k': 'turnDown',
    'e': 'interact',
  }

  // 必要なキーだけ登録すればOK
  // onPress: 押した瞬間
  const onPressHandlers = {
    up: () => {
    },
    down: () => {
    },
    left: () => {
    },
    right: () => {
    },
    shot: () => {
      //pl0.pushEvent('jump')
      GameManager.emitEvent(eventID.space)
    }
  }

  // onRelease: 離した瞬間
  const onReleasehandlers = {
    left: () => {
    },
    right: () => {
    },
    shot: () => {
    }
  }

  // the event list


</script>


<script id="white canvas">

  const GM = new GameManager('pauseMenu_GM')

  const testWorld = new worldBlock3D()
  const testCameraRCV = new cameraRCV()
  testCameraRCV.world = testWorld
  EventHub.getEventHandler(testCameraRCV)
  testCameraRCV.on(eventID.space, () => {
    testCameraRCV.delta.y = 0.1
  })
  const testRenderer = new RendererRCV(testCameraRCV, testWorld, canvas0, document.getElementById('fps'))

  class raycastVoxelSprite extends GameObject {
    constructor(x = 10, y = 3, z = 15) {
      super('raycastVoxel_sprite')
      this.position.set(x, y, z)
      this.screenPos = new Vec3(0, 0, 0)
      this.spriteSize = 128
      this.interactable = false

      this.show = true
      this.showDot = false
      this.state1 = {}
      this.state_near = {}
      this.state3 = {}
      this.currentState = this.state1
      this.state1.update = function (master) {
        if (Vec3.distsq(master.position, testCameraRCV.position) < 4) {
          GameManager.emitEvent('show_interact')
          master.currentState = master.state_near
          master.showDot = true
        }
      }
      this.state_near.update = function (master) {
        if (Vec3.distsq(master.position, testCameraRCV.position) > 4) {
          GameManager.emitEvent('end_interact')
          master.currentState = master.state1
          master.showDot = false
        }

        if (keys.interact.pressed) {
          GameManager.emitEvent('end_interact')
          GM.testGoal++
          master.currentState = master.state3
          master.show = false
          master.showDot = false
        }
      }
      this.state3.update=function(){}
      EventHub.getEventHandler(this)
      this.on('show_interact', () => {
        console.log('me too')
      })

    }

    update() {
      RendererRCV.verticesProjection(this.position, this.screenPos, testCameraRCV)
      const size = this.spriteSize / this.screenPos.z
      this.sx0 = this.screenPos.x - size
      this.sx1 = this.screenPos.x + size
      this.sy0 = this.screenPos.y - size * 2
      this.sy1 = this.screenPos.y

      this.currentState.update(this)

    }

    draw() {
      if (!this.show) return
      // rendererRCV.renderRectangleSprite()

      const _img = ctx0.getImageData(0, 0, canvas0.width, canvas0.height); // 直接フル解像度を塗る（拡大補間なし）
      const internalScale = testRenderer.internalScale

      RendererRCV.drawRectSpriteRGB(
        canvas0, _img.data,
        nicole_64RGB, 64,
        this.sx0, this.sx1, this.sy0, this.sy1, this.screenPos.z,
        testRenderer.zBuffer, testRenderer.zw, testRenderer.zh,
        internalScale)


      if (this.showDot) {


        if (Math2.within(this.screenPos.x, 0, W) && Math2.within(this.screenPos.y, 0, H)) {
          const
            px =
              Math.floor(this.screenPos.x / internalScale),
            py =
              Math.floor(this.screenPos.y / internalScale)

          RendererRCV.fillImageData(canvas0, _img.data,
            internalScale, px, py, 255, 0, 0)
        }
      }

      ctx0.putImageData(_img, 0, 0)
    }
  }

  const testGUI = new GameObject()
  testGUI.draw = function () {
    ctx0.fillStyle = 'red'
    ctx0.fillText('pree [E] to get the poster', 100, H / 2)
  }
  testGUI.tags.add('testgui')

  GM.on('show_interact', () => {
    GM.addChild(testGUI)
    console.log('press E to get nicole poster')
  })
  GM.on('end_interact', () => {
    GM.removeByTag('testgui')
    console.log('got it end')
  })


  
  GM.addChild(testCameraRCV)
  GM.addChild(testRenderer)
  GM.addChild(new PhysicSimulator_BlockWorld(testWorld))
  GM.addChild(new raycastVoxelSprite(10.5, 4, 15.5))
  GM.addChild(new raycastVoxelSprite(20.5, 4, 25.5))
  GM.addChild(new raycastVoxelSprite(30.5, 6, 35.5))

  
  showHTML('WASD to move, SPACE to jump, IJKL to rotate')
  showHTML('Find 3 poster of Nicole!', 'title')
  //GM.addChild(new ListShower())



  gameLoop = function () {

    GM.update()
    GM.draw()

  }

</script>

</html>