
<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>3D Voxel Raycaster (DDA) - 単一HTMLデモ</title>
  <style>
    :root {
      color-scheme: light dark;
    }

    body {
      margin: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    h1 {
      font-size: 1.1rem;
      margin: 0 0 8px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 12px;
    }

    #wrap {
      position: relative;
    }

    #view {
      width: 100%;
      max-width: 960px;
      border: 1px solid #8886;
      border-radius: 8px;
      image-rendering: pixelated;
    }

    .hud {
      position: absolute;
      left: 8px;
      top: 8px;
      padding: 6px 8px;
      background: color-mix(in oklab, Canvas, transparent 25%);
      border: 1px solid #8886;
      border-radius: 6px;
      font: 12px/1.3 ui-monospace, SFMono-Regular, Consolas, monospace;
      backdrop-filter: blur(4px);
    }

    .panel {
      border: 1px solid #8886;
      border-radius: 8px;
      padding: 10px;
    }

    .panel h2 {
      font-size: 1rem;
      margin: 0 0 8px;
    }

    label {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 6px 0;
    }

    input[type="range"] {
      width: 100%;
    }

    .btn {
      padding: 6px 10px;
      border: 1px solid #8888;
      border-radius: 6px;
      background: #eee;
      cursor: pointer;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .kbd {
      padding: 1px 4px;
      border: 1px solid #aaa;
      border-radius: 3px;
      background: #f6f6f6;
    }

    .note {
      font-size: 12px;
      opacity: 0.8;
    }
  </style>
</head>

<body>
  <h1>3D Voxel レンダリング（Amanatides &amp; Woo DDA / 純JS）</h1>
  <div class="row">
    <div id="wrap">
      <canvas id="view" width="960" height="540"></canvas>
      <div class="hud" id="stats">—</div>
    </div>
    <div class="panel">
      <h2>コントロール</h2>
      <div class="note">
        移動: <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> /
        上下: <span class="kbd">Space</span><span class="kbd">C</span> / 走る: <span class="kbd">Shift</span><br>
        マウスドラッグ（キャンバス上）で視点回転。重いときは「解像度縮小」を上げてください。
      </div>
      <div style="display:flex; gap:8px; flex-wrap:wrap; margin:8px 0;">
        <button class="btn" id="regen">ワールド再生成</button>
        <button class="btn" id="toggleWire">ワイヤー（面の法線色）</button>
      </div>
      <div>
        <label>解像度縮小（内部解像度 = 960 / 値）
          <input id="scale" type="range" min="1" max="6" value="6">
        </label>
        <label>視野角（FOV°）
          <input id="fov" type="range" min="16" max="100" value="75">
        </label>
        <label>最大距離（t）
          <input id="maxDist" type="range" min="16" max="200" value="90">
        </label>
        <label>ステップ上限（安全）
          <input id="maxSteps" type="range" min="64" max="2048" value="512">
        </label>
        <label>露出（全体の明るさ）
          <input id="exposure" type="range" min="0" max="200" value="110">
        </label>


      </div>
      <hr>
      <h2>ほか内部パラメーター</h2>
      <pre class="note" id="info" style="white-space:pre-wrap">—</pre>
    </div>
  </div>

</body>

</html>
<script>
  /* =========================
     ベクトル & 数学ユーティリティ
     ========================= */
  class Vec3 {
    constructor(x = 0, y = 0, z = 0) { this.x = x; this.y = y; this.z = z; }
    set(x, y, z) { this.x = x; this.y = y; this.z = z; return this; }
    add(v) { this.x += v.x; this.y += v.y; this.z += v.z; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; this.z -= v.z; return this; }
    mul(s) { this.x *= s; this.y *= s; this.z *= s; return this; }
    dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
    cross(v) {
      return new Vec3(
        this.y * v.z - this.z * v.y,
        this.z * v.x - this.x * v.z,
        this.x * v.y - this.y * v.x
      );
    }
    len() { return Math.hypot(this.x, this.y, this.z); }
    norm() { const l = this.len() || 1; this.x /= l; this.y /= l; this.z /= l; return this; }
    clone() { return new Vec3(this.x, this.y, this.z); }

    // static であれば、Instanceしなくてもいいか
    // yaw:Left,Right ptich:up,down
    static fromYawPitch(yawDeg, pitchDeg) {
      const yaw = yawDeg * Math.PI / 180, pitch = pitchDeg * Math.PI / 180;
      const cos_yaw = Math.cos(yaw), sin_yaw = Math.sin(yaw);
      const cos_pitch = Math.cos(pitch), sin_pinch = Math.sin(pitch);
      // 前方: XZ 平面をヨー、Y はピッチ
      return new Vec3(sin_yaw * cos_pitch, -sin_pinch, cos_yaw * cos_pitch).norm();
    }
  }

  /* =========================
     ワールド（world[x][y][z]）
     ========================= */


  const __W = 48, __H = 24, __D = 48; // サイズ



  // 0=空気, 1=草土, 2=石, 3=木
  class worldBlock {
    constructor(width = 48, height = 24, depth = 48) {
      this.__W = width
      this.__H = height
      this.__D = depth
      this.worldXYZ = worldBlock.createWorld()
    }
    static createWorld(seed = Math.random()) {
      // 三次元配列アクセスの見た目を保ちつつ、内部は1D配列で高速化
      const data = new Uint8Array(__W * __H * __D);
      const idx = (x, y, z) => (y * __D + z) * __W + x;

      // y=0：地面（石）
      for (let x = 0; x < __W; x++) for (let z = 0; z < __D; z++) data[idx(x, 0, z)] = 2;

      // 簡易の高さマップ＋構造物
      const rng = worldBlock.mulberry32(Math.floor(seed * 0x7fffffff));
      // 起伏（草土）
      for (let x = 0; x < __W; x++) {
        for (let z = 0; z < __D; z++) {
          const h = 1 + Math.floor(5 * worldBlock.noise2d(x * 0.12, z * 0.12, rng));
          for (let y = 1; y < Math.min(__H, h + 1); y++) data[idx(x, y, z)] = 1;
        }
      }
      // 柱や壁（石/木）
      for (let i = 0; i < 220; i++) {
        const x = 2 + Math.floor(rng() * (__W - 4));
        const z = 2 + Math.floor(rng() * (__D - 4));
        const ht = 3 + Math.floor(rng() * 8);
        const id = (rng() < 0.7) ? 2 : 3;
        for (let y = 1; y < Math.min(__H, ht); y++) data[idx(x, y, z)] = id;
        // たまに横へ延ばす
        if (rng() < 0.3 && x + 1 < __W) for (let y = 1; y < Math.min(__H, ht - 1); y++) data[idx(x + 1, y, z)] = id;
        if (rng() < 0.3 && z + 1 < __D) for (let y = 1; y < Math.min(__H, ht - 1); y++) data[idx(x, y, z + 1)] = id;
      }
      // 空の広場
      for (let x = 18; x < 30; x++) for (let z = 18; z < 30; z++) for (let y = 1; y < 6; y++) data[idx(x, y, z)] = 0;

      // ラッパー：world[x][y][z] 風アクセスを提供
      const wrapperXYZ = [];
      for (let x = 0; x < __W; x++) {
        wrapperXYZ[x] = [];
        for (let y = 0; y < __H; y++) {
          wrapperXYZ[x][y] = [];
          for (let z = 0; z < __D; z++) {
            Object.defineProperty(wrapperXYZ[x][y], z, {
              get() { return data[idx(x, y, z)]; },
              set(v) { data[idx(x, y, z)] = v | 0; },
              enumerable: true
            });
          }
        }
      }
      wrapperXYZ._data = data; wrapperXYZ._idx = idx;
      return wrapperXYZ;
    }

    static noise2d(x, z, rng) {
      // 簡易な値ノイズ（勾配なし）：タイル状に乱数→双線形補間
      const xi = Math.floor(x), zi = Math.floor(z);
      const xf = x - xi, zf = z - zi;
      function hash(i, j) { // 位置依存の擬似乱数
        const seed = ((i * 73856093) ^ (j * 19349663)) >>> 0;
        const r = worldBlock.mulberry32(seed)();
        return r;
      }
      const v00 = hash(xi, zi), v10 = hash(xi + 1, zi), v01 = hash(xi, zi + 1), v11 = hash(xi + 1, zi + 1);
      const v0 = v00 + (v10 - v00) * xf;
      const v1 = v01 + (v11 - v01) * xf;
      return v0 + (v1 - v0) * zf;
    }

    static inBounds(x, y, z) { return x >= 0 && x < __W && y >= 0 && y < __H && z >= 0 && z < __D }

    static isSolid(x, y, z, worldXYZ) {
      return worldBlock.inBounds(x, y, z) ? worldXYZ[x][y][z] !== 0 : false;
    }

    static mulberry32(a) {
      return function () {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
  }


  class cameraRayCastVoxel {
    constructor(px = 10.5, py = 3.0, pz = 10.5, yaw = 0, pitch = 20, world = world__) {
      this.camPos = new Vec3(px, py, pz)
      this.yaw = yaw
      this.pitch = pitch
      this.worldXYZ = world.worldXYZ
    }

    update() {
      this.camPos.x = clamp(this.camPos.x, 0.01, __W - 0.01);
      this.camPos.y = clamp(this.camPos.y, 0.01, __H - 0.01);
      this.camPos.z = clamp(this.camPos.z, 0.01, __D - 0.01);

    }

    static raycastVoxel(origin, dir, maxDistance = 90, maxSteps = 1024, _worldXYZ) {
      /* =========================
       DDA レイキャスト（Amanatides & Woo）
       ========================= */
      /**
       * @param {Vec3} origin ワールド座標
       * @param {Vec3} dir    正規化方向
       * @param {number} maxDistance 最大距離
       * @param {number} maxSteps    ステップ上限
       * @returns { hit:boolean, t:number, vox?:{x,y,z}, normal?:{x,y,z}, id?:number }
       */
      let vx = Math.floor(origin.x), vy = Math.floor(origin.y), vz = Math.floor(origin.z);

      // 各軸の進行符号
      const stepX = dir.x > 0 ? 1 : (dir.x < 0 ? -1 : 0);
      const stepY = dir.y > 0 ? 1 : (dir.y < 0 ? -1 : 0);
      const stepZ = dir.z > 0 ? 1 : (dir.z < 0 ? -1 : 0);

      // Δt（1ボクセル進むのに必要な t 増分）
      const tDeltaX = stepX !== 0 ? Math.abs(1 / dir.x) : Infinity;
      const tDeltaY = stepY !== 0 ? Math.abs(1 / dir.y) : Infinity;
      const tDeltaZ = stepZ !== 0 ? Math.abs(1 / dir.z) : Infinity;

      // tMax: 次の格子境界までの t
      let tMaxX, tMaxY, tMaxZ;
      if (stepX > 0) tMaxX = (Math.floor(origin.x) + 1 - origin.x) * tDeltaX;
      else if (stepX < 0) tMaxX = (origin.x - Math.floor(origin.x)) * tDeltaX;
      else tMaxX = Infinity;

      if (stepY > 0) tMaxY = (Math.floor(origin.y) + 1 - origin.y) * tDeltaY;
      else if (stepY < 0) tMaxY = (origin.y - Math.floor(origin.y)) * tDeltaY;
      else tMaxY = Infinity;

      if (stepZ > 0) tMaxZ = (Math.floor(origin.z) + 1 - origin.z) * tDeltaZ;
      else if (stepZ < 0) tMaxZ = (origin.z - Math.floor(origin.z)) * tDeltaZ;
      else tMaxZ = Infinity;

      // 始点がブロック内→最初の境界を跨いでから判定（内部からの視点でも安定）
      let t = 0;
      let lastAxis = null;

      for (let i = 0; i < maxSteps; i++) {
        if (tMaxX < tMaxY) {
          if (tMaxX < tMaxZ) { vx += stepX; t = tMaxX; tMaxX += tDeltaX; lastAxis = 'x'; }
          else { vz += stepZ; t = tMaxZ; tMaxZ += tDeltaZ; lastAxis = 'z'; }
        } else {
          if (tMaxY < tMaxZ) { vy += stepY; t = tMaxY; tMaxY += tDeltaY; lastAxis = 'y'; }
          else { vz += stepZ; t = tMaxZ; tMaxZ += tDeltaZ; lastAxis = 'z'; }
        }
        if (t > maxDistance) break;
        if (!worldBlock.inBounds(vx, vy, vz)) return { hit: false, t };

        if (worldBlock.isSolid(vx, vy, vz, _worldXYZ)) {
          let nx = 0, ny = 0, nz = 0;
          if (lastAxis === 'x') nx = -stepX;
          else if (lastAxis === 'y') ny = -stepY;
          else nz = -stepZ;
          return { hit: true, t, vox: { x: vx, y: vy, z: vz }, normal: { x: nx, y: ny, z: nz }, id: _world[vx][vy][vz] };
        }
      }
      return { hit: false, t };
    }

    draw() {
      const Wc = canvas.width, Hc = canvas.height;
      const w = Math.floor(Wc / internalScale), h = Math.floor(Hc / internalScale);

      const _img = ctx.getImageData(0, 0, Wc, Hc); // 直接フル解像度を塗る（拡大補間なし）
      const data = _img.data;

      // カメラ基底ベクトル
      const dirForward = Vec3.fromYawPitch(_yaw, _pitch); // -Z基準ではなく、既に前方

      // スクリーン座標系（右・上）
      const worldUp = new Vec3(0, 1, 0);

      const dirRight = dirForward.cross(worldUp).norm();
      const dirUp = dirRight.cross(dirForward).norm();


      const fov = fovDeg * Math.PI / 180;
      const halfW = Math.tan(fov / 2);
      const aspect = w / h;

      // 画面の各ピクセルにレイ
      const t0 = performance.now();
      for (let py = 0; py < h; py++) {
        const vy = (1 - 2 * (py + 0.5) / h) * halfW; // [-halfW, halfW]
        for (let px = 0; px < w; px++) {
          const vx = (2 * (px + 0.5) / w - 1) * halfW * aspect;

          // レイ方向
          const dir = new Vec3(
            dirForward.x + dirRight.x * vx + dirUp.x * vy,
            dirForward.y + dirRight.y * vx + dirUp.y * vy,
            dirForward.z + dirRight.z * vx + dirUp.z * vy
          ).norm();

          const result = cameraRayCastVoxel.raycastVoxel(_camPos, dir, maxDistance, maxSteps, _world);

          let r, g, b;
          if (result.hit) {
            // 面法線
            const n = result.normal;
            // 色
            let col = getBlockColor(result.id, n);
            // 照明（ランバート）
            const ndl = Math.max(0, -(n.x * lightDir.x + n.y * lightDir.y + n.z * lightDir.z));
            let lit = ambient + (1 - ambient) * ndl;
            // 距離フォグ
            const fogT = clamp(result.t / maxDistance, 0, 1);
            const sky = [
              mix(skyHzn[0], skyTop[0], 0.5 - 0.5 * dir.y), // 視線が上なら空色を強く
              mix(skyHzn[1], skyTop[1], 0.5 - 0.5 * dir.y),
              mix(skyHzn[2], skyTop[2], 0.5 - 0.5 * dir.y)
            ];

            if (showNormals) {
              // 法線可視化モード
              col = [(n.x * 0.5 + 0.5), (n.y * 0.5 + 0.5), (n.z * 0.5 + 0.5)];
              lit = 1.0;
            }

            r = mix(sky[0], col[0] * lit * exposure, (1 - fogT));
            g = mix(sky[1], col[1] * lit * exposure, (1 - fogT));
            b = mix(sky[2], col[2] * lit * exposure, (1 - fogT));
          } else {
            // スカイ
            const t = 0.5 - 0.5 * dir.y; // 上ほど skyTop、下ほど skyHzn
            r = mix(skyHzn[0], skyTop[0], t);
            g = mix(skyHzn[1], skyTop[1], t);
            b = mix(skyHzn[2], skyTop[2], t);
          }

          // 書き込み（内部縮小→スケール描画：最近傍）
          // ここでは直接フル解像度に nearest 拡大して塗る
          const x0 = px * internalScale | 0, y0 = py * internalScale | 0;
          for (let oy = 0; oy < internalScale; oy++) {
            let off = ((y0 + oy) * Wc + x0) * 4;
            for (let ox = 0; ox < internalScale; ox++) {
              data[off] = Math.max(0, Math.min(255, (r * 255) | 0));
              data[off + 1] = Math.max(0, Math.min(255, (g * 255) | 0));
              data[off + 2] = Math.max(0, Math.min(255, (b * 255) | 0));
              data[off + 3] = 255;
              off += 4;
            }
          }
        }
      }

      const t1 = performance.now();
      ctx.putImageData(_img, 0, 0);

      const dt = (t1 - t0);
      statsEl.textContent = `
        FPS: ${(1000 / dt).toFixed(1)} | 
        render=${dt.toFixed(1)}ms | ${Math.floor(canvas.width / internalScale)}x${Math.floor(canvas.height / internalScale)} (scale ${internalScale}x)
  pos=(${_camPos.x.toFixed(2)}, ${_camPos.y.toFixed(2)}, ${_camPos.z.toFixed(2)}) 
  yaw=${_yaw.toFixed(1)} 
  pitch=${_pitch.toFixed(1)}`;
    }

  }


  const world__ = new worldBlock(48, 24, 28)

  // ここはややこしいな、引用されているのでどうすれば断ち切れるのか
  let _world = world__.worldXYZ


  /* =========================
     レンダラー（ソフトウェア・レイキャスト）
     ========================= */
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
  const statsEl = document.getElementById('stats');
  const infoEl = document.getElementById('info');

  let internalScale = 6; // 解像度縮小（1=フル, 2=1/2, 4=1/4）
  let fovDeg = 16;
  let maxDistance = 90;
  let maxSteps = 512;
  let exposure = 1.10;
  let showNormals = false;

  // block ID data
  function getBlockColor(id, normal) {
    // ブロックごとのベース色（sRGB→linearっぽく扱う簡易）
    let c;
    switch (id) {
      case 1: // 草土
        // 上面っぽく少し緑を強める
        const g = 0.38 + 0.22 * clamp(normal.y, 0, 1);
        c = [0.18, g, 0.12]; break;
      case 2: // 石
        c = [0.48, 0.50, 0.52]; break;
      case 3: // 木
        c = [0.40, 0.28, 0.14]; break;
      default:
        c = [0.8, 0.0, 0.8];
    }
    return c;
  }

  // shader parameter
  const skyTop = [0.60, 0.78, 0.98];  // 空（上）
  const skyHzn = [0.85, 0.92, 1.00];  // 空（地平）
  const lightDir = new Vec3(0.6, -0.8, 0.2).norm(); // 太陽光
  const ambient = 0.18;


  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function mix(a, b, t) { return a + (b - a) * t; }


  const crv = new cameraRayCastVoxel(10.5, 3.0, 10.5, 0, -20, world__)
  let _camPos = crv.camPos;
  let _yaw = crv.yaw, _pitch = crv.pitch;

  let keyState = new Map();
  let dragging = false, lastMouse = null;

  /* =========================
     入力とUI
     ========================= */
  const scaleEl = document.getElementById('scale');
  const fovEl = document.getElementById('fov');
  const maxDistEl = document.getElementById('maxDist');
  const maxStepsEl = document.getElementById('maxSteps');
  const exposureEl = document.getElementById('exposure');
  const regenBtn = document.getElementById('regen');
  const toggleWireBtn = document.getElementById('toggleWire');

  scaleEl.addEventListener('input', () => internalScale = parseInt(scaleEl.value));
  fovEl.addEventListener('input', () => fovDeg = parseFloat(fovEl.value));
  maxDistEl.addEventListener('input', () => maxDistance = parseFloat(maxDistEl.value));
  maxStepsEl.addEventListener('input', () => maxSteps = parseInt(maxStepsEl.value));
  exposureEl.addEventListener('input', () => exposure = Math.max(0.01, parseInt(exposureEl.value) / 100));
  regenBtn.addEventListener('click', () => { _world = worldBlock.createWorld(); });
  toggleWireBtn.addEventListener('click', () => { showNormals = !showNormals; });

  // これもすごい簡潔だよね
  window.addEventListener('keydown', e => { keyState.set(e.code, true); });
  window.addEventListener('keyup', e => { keyState.set(e.code, false); });

  canvas.addEventListener('mousedown', e => { dragging = true; lastMouse = { x: e.clientX, y: e.clientY }; });
  window.addEventListener('mouseup', () => { dragging = false; lastMouse = null; });

  // この使い方もすごい参考になる
  window.addEventListener('mousemove', e => {
    if (!dragging) return;
    if (!lastMouse) { lastMouse = { x: e.clientX, y: e.clientY }; return; }
    const dx = e.clientX - lastMouse.x;
    const dy = e.clientY - lastMouse.y;
    lastMouse = { x: e.clientX, y: e.clientY };
    const sens = 0.2;
    _yaw = (_yaw + dx * sens);
    _pitch = clamp(_pitch + dy * sens, -89.5, 89.5);
  });

  /* =========================
     メインループ
     ========================= */
  function update(dt) {
    // 入力処理
    const speed = (keyState.get('ShiftLeft') || keyState.get('ShiftRight')) ? 12 : 5;
    const step = speed * dt;

    const worldUp = new Vec3(0, 1, 0);
    const forward = Vec3.fromYawPitch(_yaw, 0); // 水平の前方
    const right = forward.cross(worldUp).norm();

    //.clone.mul ... sugoi
    if (keyState.get('KeyW')) _camPos.add(forward.clone().mul(step));
    if (keyState.get('KeyS')) _camPos.add(forward.clone().mul(-step));
    if (keyState.get('KeyA')) _camPos.add(right.clone().mul(-step));
    if (keyState.get('KeyD')) _camPos.add(right.clone().mul(step));
    if (keyState.get('Space')) _camPos.y += step;
    if (keyState.get('KeyC')) _camPos.y -= step;

    // camera.update
    // ワールド内に留める
    crv.update()
  }



  function draw() {
    infoEl.textContent =
      `W,H,D = ${__W}, ${__H}, ${__D}
内部データ: Uint8Array(${__W * __H * __D}) / world[x][y][z] ラッパー
DDA: tMax/tDelta で 1ボクセルずつ進行
光源 = (${lightDir.x.toFixed(2)}, ${lightDir.y.toFixed(2)}, ${lightDir.z.toFixed(2)}), 
ambient=${ambient}
fog距離 = ${maxDistance}, 
steps上限=${maxSteps}, 
exposure=${exposure.toFixed(2)}
操作: WASD/Space/C + マウスドラッグ + Shift(ダッシュ)`;

  }


  let lastTime = performance.now();

  function gameLoop() {
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;
    update(dt);

    crv.draw();

    draw()


    requestAnimationFrame(gameLoop);
  }

  gameLoop();
</script>