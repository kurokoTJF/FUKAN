<div class=container>
    <div class=left-column>
        <p id="content"></p>
        <p>idle infinite counter</p>

    </div>
    <div class=right-column>
        <canvas></canvas>
    </div>

</div>

<p>
    <button class="b1"> </button>
    <button class="b1" onmousedown="keyPress('up')">↑</button>
    <button class="b1"> </button>
</p>
<p>
    <button class="b1" onmousedown="keyPress('left')">←</button>
    <button class="b1" onmousedown="keyPress('down')">↓</button>
    <button class="b1" onmousedown="keyPress('right')">→</button>
    <button class="b1"> </button>
    <button onmousedown="keyPress('atk')">attack</button>
    <button onmousedown="keyPress('switch')">swtich</button>

</p>

<div>
    <p>
        <button onmousedown="keyPress('add_sword')">add sword</button>
        <button onmousedown="keyPress('select')">select</button>
        <button onmousedown="keyPress('pause')">pause</button>
        <button onmousedown="keyPress('use_chip')">use the chip</button>
    </p>
</div>
<button onmousedown="keyPress('test_injured')">test_injured </button>

<button onmousedown="keyPress('test')">add control counter</button>
<button onmousedown="clearLog()">clear log </button>

<p>
<div id="state"></div>

<div id="chips"></div>
<div id="counters"></div>
<div id="log"></div>
</p>

<style>
    .b1 {
        width: 40px;
        height: 20px;
    }

    .container {
        display: flex;
    }

    .left-column {
        font-size: 10px;
        width: 30%;
        background-color: #f0f0f0;
        padding: 10px;
    }

    .right-column {
        width: 70%;
        background-color: #8f8f8f;
        padding: 10px;
    }
</style>


<script id="data">
    const ModelHData =
    {
        name: "ModelH",
        element: "thunder",
        hp: 80,
        initialState: 'idle',

        state: {
            idle: {
                duration: 202,
                transition: {
                    atk: 'attack1',
                    onEnd: 'idle'
                },
                sprite_info: {}
            },
            attack1: {
                duration: 20,
                steps:
                    [
                        { time: 30, action: (target) => target.showMSG('count 100') },
                        { time: 70, action: (target) => target.showMSG('count 300') },
                    ],
                transition: {
                    atk: 'attack2',
                    onEnd: 'idle'
                }
            },
            attack2: {
                duration: 80,
                transition: {
                    onEnd: 'idle',
                    atk: 'injured'
                }
            },

            injured: {
                duration: 30,
                transition: {
                    onEnd: 'idle',
                    atk: 'attack1'
                }
            },


        },
        spriteCollection: {
            test: {
                path: "https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/red/enchant.png",
                length: 8,
            },
            move: {
                path:
                    'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4867.png',
                length: 8,
                flip: true,
            },
            idle: {
                path:
                    'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4865.png',
                length: 4,
                flip: true,
            },
            attack1: {
                path: 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4863.png',
                length: 4,
            },
            attack2: {
                path: 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4866.png',
                length: 12,
                flip: true,
            },
            injured: {
                path: 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4873.png'
                ,
                length: 5,
                flip: true,
            }
        }

    }

    const ModelHData2 =
    {
        name: "ModelH",
        element: "thunder",
        hp: 80,
        initialState: 'idle',

        state: {
            idle: {
                duration: 202,
                transition: {
                    atk: 'attack1',
                    onEnd: 'idle'
                },
                sprite_info: {}
            },
            attack1: {
                duration: 20,
                steps:
                    [
                        { time: 30, action: (target) => target.showMSG('count 100') },
                        { time: 70, action: (target) => target.showMSG('count 300') },
                    ],
                transition: {
                    atk: 'attack2',
                    onEnd: 'idle'
                }
            },
            attack2: {
                duration: 80,
                transition: {
                    onEnd: 'idle',
                    atk: 'injured'
                }
            },

            injured: {
                duration: 30,
                transition: {
                    onEnd: 'idle',
                    atk: 'attack1'
                }
            },


        },
        spriteFolder: 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/',

        spriteCollection: {
            test: {
                path: "https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/red/enchant.png",
                length: 8,
            },
            move: {
                path:
                    'IMG_4867.png',
                length: 8,
                flip: true,
            },
            idle: {
                path:
                    'IMG_4865.png',
                length: 4,
                flip: true,
            },
            attack1: {
                path: 'IMG_4863.png',
                length: 4,
            },
            attack2: {
                path: 'IMG_4866.png',
                length: 12,
                flip: true,
            },
            injured: {
                path: 'IMG_4873.png'
                ,
                length: 5,
                flip: true,
            }
        }

    }

    const ModelPData =
    {
        name: "ModelP",
        element: "ICE?",
        hp: 120,
        initialState: 'idle',

        state: {
            idle: {
                duration: 202,
                transition: {
                    atk: 'attack1',
                    onEnd: 'idle'
                },
                sprite_info: {}
            },
            attack1: {
                duration: 100,
                steps:
                    [
                        { time: 30, action: (target) => target.showMSG('count 100') },
                        { time: 70, action: (target) => target.showMSG('count 300') },
                    ],
                transition: {
                    atk: 'attack2',
                    onEnd: 'idle'
                }
            },
            attack2: {
                duration: 120,
                transition: {
                    onEnd: 'idle',
                    atk: 'injured'
                }
            },

            injured: {
                duration: 30,
                transition: {
                    onEnd: 'idle',
                    atk: 'attack1'
                }
            },


        },
        spriteFolder: 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/',
        spriteCollection: {

            move: {
                path: 'IMG_4898.png',
                rect: { w: 40, h: 64 },
                length: 8,
                flip: true,
            },
            idle: {
                path: 'IMG_4899.png'
                , rect: { w: 44, h: 50 },
                length: 4,
                flip: true,
            },
            attack1: {
                path: 'IMG_4897.png'
                ,
                rect: { w: 44, h: 56 },
                length: 12,
                flip: true,
            },
            attack2: {
                path: 'IMG_4894.png'
                ,
                rect: { w: 100, h: 64 },
                length: 5,
                flip: true,
            },
            injured: {
                path: 'IMG_4873.png'
                ,
                rect: { w: 45, h: 50 },
                length: 5,
                flip: true,
            }
        }

    }

</script>

<script id="functions Engine">
    keyPress = function (key) {
        keys[key].pressed = true
    }

    const keys = new Proxy({}, {
        get(target, prop) {
            if (!(prop in target)) {
                target[prop] = { press: false, pressed: false };
            }
            return target[prop];
        }
    });
    const rawUrl = "https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/workspace/Counter/Ideas.txt";

    function showHTML(MSG, ID) {
        document.getElementById(ID).innerText = MSG
    }


    function log(msg) {
        document.getElementById("log").innerText += msg + "\n_"
    }
    function showChips(msg) {
        document.getElementById("chips").innerText = "[battle chips]:" + "\n_" + msg
    }
    function showCounters(msg) {
        document.getElementById("counters").innerText = "[Counters]:" + "\n_" + msg
    }
    function clearLog() {
        document.getElementById('log').innerText = "[my console]:\n"
    }
    clearLog()
    showChips("no chips")


    class ImageLoader {
        constructor(url) {
            this.loaded = false
            this.img = new Image()
            this.img.src = url
            this.img.onload = () => {
                this.loaded = true
            }
        }
        load(url) {
            this.loaded = false
            this.img.src = url
            this.img.onload = () => {
                this.loaded = true
            }
        }
    }


    class Counter {
        constructor({
            endTime = 100,
            name = "",
            end = false,
            target = undefined,
            msg = "__",
            processCall = null,
            endCall = () => { },
            gen_list = false,
            qte = false,
            qteCall = false,
        } = {}) {
            this.time = 0
            this.endTime = endTime
            this.end = end
            this.target = target
            this.processCall = processCall
            this.msg = msg
            this.endCall = endCall
            this.gen_list = gen_list
            this.qteCall = qteCall
        }
        start() { }

        setEnd() {
            this.end = true
        }
        _isEnd() {
            return this.end
        }

        #endMethod() {
            console.log(this.msg + " " + this.endTime + " counter end")
            this.end = true
            this.endCall()
        }

        progress() {
            return this.time / this.endTime
        }

        update() {
            if (this.time < this.endTime) {
                this.time++
                if (this.processCall) this.processCall()

            } else this.#endMethod()
        }
    }


</script>

<script id="class">
    // classes.js
    // difficult to split files
    const CharID = {
        Player: 0,
        Enemy: 1,
        Actor: 2,
    }

    class PolygonRenderer {
        constructor() {
            console.log('polygon renderer online')
        }


        // get x,y,z in screen space
        project(v, angle = 0.5) {
            // Y軸回転
            const cos = Math.cos(angle), sin = Math.sin(angle);
            const x = v.x * cos - v.z * sin;
            const z = v.x * sin + v.z * cos + 9; // zをずらして奥へ
            const y = v.y - 2;

            // to screen space
            return {
                x: x / z * 400 + canvas.width / 2,
                y: -y / z * 400 + canvas.height / 2,
                z: z
            };
        }

        // x,y と　３つの頂点情報で　座標のWeightを求める
        getBarycentric(x, y, p0, p1, p2) {
            //やめとけ
            // console.log('doing math')
            const det = (p1.y - p2.y) * (p0.x - p2.x) + (p2.x - p1.x) * (p0.y - p2.y);
            const w0 = ((p1.y - p2.y) * (x - p2.x) + (p2.x - p1.x) * (y - p2.y)) / det;
            const w1 = ((p2.y - p0.y) * (x - p2.x) + (p0.x - p2.x) * (y - p2.y)) / det;
            const w2 = 1 - w0 - w1;
            return [w0, w1, w2];
        }

        render2(_vertices, _faces, _colors, _uv, angle, ctx, sampleuv = false) {
            //ctx.clearRect(0, 0, ctx.width, ctx.height);

            // 投影した頂点
            const projected = _vertices.map(v => this.project(v, angle));

            // 各三角形に z（平均深度）を与えてソート
            const triangles = _faces.map((_face, i) => {
                // _face は[vertex_id0,vertex_id1,vertex_id2]
                // そのvertex_idを実際の頂点情報に置き換える
                const combined = projected.map((v, i) => ({
                    x: v.x,
                    y: v.y,
                    z: v.z,
                    u: _uv[i].u,
                    v: _uv[i].v
                }));
                const [a, b, c] = _face.map(idx => combined[idx]);
                const depth = (a.z + b.z + c.z) / 3;

                // return 一つの三角形が必要なデータを組み立てして返す
                return { a, b, c, color: _colors[i], depth };
            }).sort((t1, t2) => t2.depth - t1.depth); // 奥から描画


            if (!sampleuv) {
                for (const tri of triangles) {
                    // uv sampling!

                    // 
                    const output = ctx.createImageData(500, 500);
                    const outData = output.data;

                    // Screen Spaceでバウンディングボックスを計算する
                    const triangle = [tri.a, tri.b, tri.c]
                    const xs = triangle.map(p => p.x);
                    const ys = triangle.map(p => p.y);
                    const minX = Math.floor(Math.min(...xs));
                    const maxX = Math.ceil(Math.max(...xs));
                    const minY = Math.floor(Math.min(...ys));
                    const maxY = Math.ceil(Math.max(...ys));

                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            const [w0, w1, w2] = this.getBarycentric(x, y, triangle[0], triangle[1], triangle[2]);//(u,v,p0,p1,p2)
                            if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
                                const outIdx = (y * 500 + x) * 4;
                                outData[outIdx + 0] = 255;
                                outData[outIdx + 1] = 255;
                                outData[outIdx + 2] = 255;
                                outData[outIdx + 3] = 255;
                            }
                        }
                    }

                    for (let i = 0; i < projected.length; i++) {
                        const p = projected[i]
                        ctx.fillStyle = 'black';
                        ctx.fillRect(p.x - 7, p.y - 7, 14, 14)
                        ctx.font = '14px sans-serif'
                        ctx.textBaseline = 'middle'
                        ctx.fillStyle = 'white'
                        ctx.textAlign = 'center'
                        ctx.fillText(i, p.x, p.y)
                    }

                    return
                }

            } else {
                for (const tri of triangles) {
                    // uv sampling!
                    if (imageLoaded) {
                        // texture を一回描いてからじゃないとgetImageDataができない
                        const tempCanvas = document.createElement("canvas");
                        const tempCtx = tempCanvas.getContext("2d");
                        tempCanvas.width = image.width;
                        tempCanvas.height = image.height;
                        tempCtx.drawImage(image, 0, 0);
                        const imageData = tempCtx.getImageData(0, 0, image.width, image.height);
                        const texData = imageData.data;
                        const texWidth = imageData.width;
                        const texHeight = imageData.height;

                        // 
                        const output = ctx.createImageData(500, 500);
                        const outData = output.data;


                        // Screen Spaceでバウンディングボックスを計算する
                        const triangle = [tri.a, tri.b, tri.c]
                        const xs = triangle.map(p => p.x);
                        const ys = triangle.map(p => p.y);
                        const minX = Math.floor(Math.min(...xs));
                        const maxX = Math.ceil(Math.max(...xs));
                        const minY = Math.floor(Math.min(...ys));
                        const maxY = Math.ceil(Math.max(...ys));

                        for (let y = minY; y <= maxY; y++) {
                            for (let x = minX; x <= maxX; x++) {
                                const [w0, w1, w2] = this.getBarycentric(x, y, triangle[0], triangle[1], triangle[2]);//(u,v,p0,p1,p2)
                                if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
                                    const u = triangle[0].u * w0 + triangle[1].u * w1 + triangle[2].u * w2;
                                    const v = triangle[0].v * w0 + triangle[1].v * w1 + triangle[2].v * w2;
                                    // あらかじめ三角形の各頂点に z, u/z, v/z を持たせておく
                                    const _u = (w0 * (triangle[0].u / triangle[0].z) + w1 * (triangle[1].u / triangle[1].z) + w2 * (triangle[2].u / triangle[2].z));
                                    const _v = (w0 * (triangle[0].v / triangle[0].z) + w1 * (triangle[1].v / triangle[1].z) + w2 * (triangle[2].v / triangle[2].z));
                                    const w = (w0 / triangle[0].z + w1 / triangle[1].z + w2 / triangle[2].z);

                                    // 最後に割り戻す
                                    const correctedU = _u / w;
                                    const correctedV = _v / w;

                                    const texX = Math.floor(correctedU * texWidth);
                                    const texY = Math.floor(correctedV * texHeight);
                                    const idx = (texY * texWidth + texX) * 4;

                                    const r = texData[idx];
                                    const g = texData[idx + 1];
                                    const b = texData[idx + 2];
                                    const a = texData[idx + 3];

                                    ctx.fillStyle = `rgb(${r},${g},${b},${a})`;
                                    const outIdx = (y * 500 + x) * 4;
                                    outData[outIdx + 0] = r;
                                    outData[outIdx + 1] = g;
                                    outData[outIdx + 2] = b;
                                    outData[outIdx + 3] = a;
                                }
                            }
                        }

                        createImageBitmap(output).then(bitmap => {
                            ctx.drawImage(bitmap, 0, 0);
                            //この中に入れて置かないと、JSの描画の順番が狂う
                            for (let i = 0; i < projected.length; i++) {
                                const p = projected[i]
                                ctx.fillStyle = 'black';
                                ctx.fillRect(p.x - 7, p.y - 7, 14, 14)
                                ctx.font = '14px sans-serif'
                                ctx.textBaseline = 'middle'
                                ctx.fillStyle = 'white'
                                ctx.textAlign = 'center'
                                ctx.fillText(i, p.x, p.y)
                            }
                        });

                    }

                }
            }

            // vertex index overlay

        }

        render() {
            this.render2(vertices2, faces2, colors2, uv2, R_angle, c, true);
            this.render2(player.vertices, player.faces, player.color, player.uv, R_angle, c, true);

        }
    }




    class GroudState {
        constructor() {

        }

        handleInput(target) {
            log('ground state')
        }
    }

    class injuredState {
        constructor() {

        }

        handleInput(target) {

        }

        enter(target) {
            GM.Mugshot.load('https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4876.png')
            let c = GM.addCounter({
                endTime: 100,
                endCall: () => {
                    GM.Mugshot.load('https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4877.png')
                    target.cst(target.constructor.idle)
                }
            })

            target.switchCounter(c)
        }
    }

    class IdleState extends GroudState {
        constructor() {
            super()
        }

        handleInput(target) {
            if (keys.test_injured.pressed) {
                target.HP -= 10
                return target.cst(target.constructor.injured)
            }
            if (keys.atk.pressed) {
                return target.cst(target.constructor.attack)
            }
            if (keys.use_chip.pressed) {
                if (target.startUseChip2()) {
                    return target.cst(target.constructor.skill)
                }
            }

            if (keys.down.pressed) {
                if (target.startMove(0, 1)) {
                    return target.cst(target.constructor.moving)
                }
            }


            if (keys.up.pressed) {
                if (target.startMove(0, -1)) {
                    return target.cst(target.constructor.moving)
                }
            }
            if (keys.left.pressed) {
                if (target.startMove(-1, 0)) {
                    return target.cst(target.constructor.moving)
                }
            }
            if (keys.right.pressed) {
                if (target.startMove(1, 0)) {
                    return target.cst(target.constructor.moving)
                }
            }

            return target.constructor.idle

        }

        enter(target) {

            let c = GM.addCounter({
                endTime: 300,
                msg: 'player2 idle loop counter',
            })
            c.processCall = () => {
                if (c.time == c.endTime)
                    c.time = 0
            }

            target.switchCounter(c)

        }
    }

    class MovingState {
        constructor() {

        }
        handleInput(target) {
        }
        enter(target) {

            let c = GM.addCounter({
                endTime: target.moveGridStop,
                msg: "[GM]player moving",
            })
            c.processCall = () => {
                if (c.time == target.moveGridStop / 2) {
                    target._moveGrid();
                }
                else if (c.time == target.moveGridStop) {
                    target.cst(target.constructor.idle)
                }
            }
            target.switchCounter(c)

        }
    }

    class SkillState {
        constructor() { }
        handleInput(target) { }
        enter(target) {
            log('[Player2] enter skill')

            let c = GM.addCounter({
                endTime: 100,
                msg: 'player2 skill counter',
                endCall: () => {
                    target.cst(target.constructor.idle)
                }
            })
            c.processCall = () => {
                if (keys.use_chip.pressed)
                    if (c.time > 50 && c.time < 90) {
                        GM.addSPCounter()
                        log("PERFECT!")
                        target.cst(target.constructor.attack)
                    }
            }

            target.switchCounter(c)
        }
    }

    class AttackState {
        constructor() {
            //log('attack online')
        }
        handleInput(target) {

        }
        enter(target) {
            target.resetCounter0()
            let c = GM.addCounter({
                endTime: 40,
                msg: target.ID + ' attacking',
                processCall: () => { },
                endCall: () => { log('end atk'); target.cst(Player2.idle); enemy.HP -= 2; }
            })
            c.processCall = () => {
                if (target.ID != CharID.Player) return
                if (keys.atk.pressed && c.time > c.endTime / 2)
                    c.time = 0
            }
            target.counter = c

        }
    }

    class Player2 {
        static idle = new IdleState()
        static idleCounter = new Counter({
            endTime: 40,
            msg: 'player2 static idle counter',
            processCall: () => {
                if (this.time == this.endTime) {
                    this.time = 0
                }
            }
        })
        static moving = new MovingState()
        static skill = new SkillState()
        static attack = new AttackState()
        static injured = new injuredState()

        constructor() {
            console.log("player2 online")
            this.counter = null
            this.position = { x: 1, y: 2 }
            this.deltaPosition = { x: 0, y: 0 }
            this.HP = 100
            this.ID = CharID.Player
            this.stance = 100
            this.state = {
                moving: false,
                usingChip: false,
                buffed: false,
                idle: false,
                attack: false,
            }

            this.moveGridStop = 20
            this.chipName = ""
            //this.position.y=10

            this.st = Player2.idle
            this.st.enter(this)

            this.renderer = new MovieRenderer(this)

            this.local_vertices = [
                { x: -3, y: 1.5, z: 2.5 },
                { x: -3, y: 0, z: 2.5 },
                { x: -2, y: 0, z: 2.5 },
                { x: -2, y: 1.5, z: 2.5 }
            ]
            this.vertices = [{ x: -3, y: 1.5, z: 2.5 },
            { x: -3, y: 0, z: 2.5 },
            { x: -2, y: 0, z: 2.5 },
            { x: -2, y: 1.5, z: 2.5 }]
            this.uv = [
                { u: 0, v: 0 },
                { u: 0, v: 1 },
                { u: 1, v: 1 },
                { u: 1, v: 0 }
            ]
            this.faces = [[0, 1, 2], [0, 2, 3]]
            this.color = ['white', 'white']
        }

        update_vertices() {
            this.vertices = this.local_vertices.map(v => ({
                x: v.x + this.position.x - 1,
                y: v.y,
                z: v.z - this.position.y + 1
            }))
        }

        resetCounter0() {
            //log('reset counter')
            if (this.counter) { this.counter.end = true }
        }

        switchCounter(c) {
            if (this.counter) this.counter.setEnd()
            if (c) this.counter = c
        }
        cst(_state) {
            this.st = _state
            this.st.enter(this)
            return _state
        }


        startMove(_x, _y) {
            if (
                this.position.x + _x < 1 ||
                this.position.x + _x > 3 ||
                this.position.y + _y < 1 ||
                this.position.y + _y > 3
            )
                return false
            this.deltaPosition = { x: _x, y: _y }
            return true
        }
        _moveGrid(_x, _y) {
            this.position.x += _x
            this.position.y += _y
        }
        _moveGrid() {
            this.position.x += this.deltaPosition.x
            this.position.y += this.deltaPosition.y
        }




        startUseChip() {
            if (chip_selected.length < 1) { console.log("no chip selected"); return; }

            // enter
            if (this.cst('usingChip')) {

                // use the first chip
                this.chipName = chip_selected[0].name
                chip_selected.splice(0, 1)
                this.counter = GM.addCounter({
                    endTime: 100,
                    msg: "[GM]player using chip",
                    endCall: () => this._endUseChip(),
                    _gen_list: [
                        {
                            time: 40,
                            call: () =>
                                GM.addCounter({
                                    endTime: 30,
                                    msg: "qte counting...",
                                    endCall: () => this.HP -= 25,
                                    _qteCall: () => {
                                        this.state["buffed"] = true
                                        GM.addSPCounter()
                                        enemy.HP -= 20
                                        log("PERFECT!")
                                    },
                                }),
                        },
                    ],
                })
            }
        }
        _endUseChip() {
            this.est('usingChip')
            this.resetCounter0()
        }

        startUseChip2() {
            if (chip_selected.length < 1) { console.log("no chip selected"); return false; }
            return true
            // enter
            if (this.cst('usingChip')) {

                // use the first chip
                this.chipName = chip_selected[0].name
                chip_selected.splice(0, 1)
                this.counter = GM.addCounter({
                    endTime: 100,
                    msg: "[GM]player using chip",
                    endCall: () => this._endUseChip(),
                    _gen_list: [
                        {
                            time: 40,
                            call: () =>
                                GM.addCounter({
                                    endTime: 30,
                                    msg: "qte counting...",
                                    endCall: () => this.HP -= 25,
                                    _qteCall: () => {
                                        this.state["buffed"] = true
                                        GM.addSPCounter()
                                        enemy.HP -= 20
                                        log("PERFECT!")
                                    },
                                }),
                        },
                    ],
                })
            }
        }
        endAttack() {
            log('[player2]end attack')


        }


        startAtk() {
        }

        _handleInput() {

        }


        update() {
            //this.update_vertices()
            if (this.ID == CharID.Enemy) return
            //key event
            //Counterの更新はこの時点で済んでる
            this._handleInput()
            if (this.ID == CharID.Player) {
                const st = this.st.handleInput(this)
                if (st) this.st = st
            }
            //change the postion
            if (this.position.y > 3) this.position.y = 3
            else if (this.position.y < 1) this.position.y = 1
            if (this.position.x > 3) this.position.x = 3
            else if (this.position.x < 1) this.position.x = 1

            // back to idle

        }

        draw() {
            if (this.counter) {
                this.renderer.draw()
            }

            const temp_draw = () =>
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40,
                    20,
                    tileSize,
                )
            const temp_print = (msg) =>
                c.fillText(
                    msg,
                    10 + ((this.position.x - 1) * canvas.width) / 6,
                    (this.position.y * canvas.height) / 6 + 40 + 10,
                )
            const temp_draw_gauge = (_counter) => {
                c.fillStyle = "rgba(0,0,0,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40 + tileSize,
                    tileSize,
                    5,
                )
                c.fillStyle = "rgb(255, 255, 255)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40 + tileSize,
                    (_counter.time / _counter.endTime) * tileSize,
                    5,
                )
            }
            const temp_draw_gauge2 = (_current, _max) => {
                c.fillStyle = "rgba(0,0,0,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 10,
                    tileSize,
                    5,
                )
                c.fillStyle = "rgba(255,0,0,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 10,
                    (_current / _max) * tileSize,
                    5,
                )
            }

            temp_draw_gauge2(this.HP, 100)
            if (this.state["buffed"]) {
                c.fillStyle = "rgb(251, 255, 0)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 20,
                    tileSize,
                    5,
                )
            }


            if (this.ID == CharID.Enemy) {
                c.fillStyle = "rgba(255,0,255,1)"
                temp_draw()

            }

            if (this.state["usingChip"]) {
                c.fillStyle = "rgb(255, 255, 255)"
                temp_print("using chips")
            } else if (this.state["moving"]) {
                c.fillStyle = "rgba(255,255,255,1)"
                temp_print("moving")
            } else if (this.state['attack']) {
                c.fillStyle = "rgba(255,255,255,1)"
                temp_print("attack")
            } else {
                c.fillStyle = "rgba(255,255,255,1)"
                temp_print("idle")
            }


            if (this.counter) {
                temp_draw_gauge(this.counter)
            }
        }
    }



    function createStateFromData(stateName, data) {
        return {
            name: stateName,
            enter(target) {
                console.log('entering ' + stateName)
                const _counter = GM.addCounter({
                    msg: '[' + stateName + ']',
                    endTime: data.duration,
                    processCall: () => {
                        for (const step of data.steps || [])
                            if (_counter.time === step.time)
                                step.action(target)
                    },
                    endCall: () => {
                        const nextStateName = data.transition?.onEnd;
                        if (nextStateName) {
                            target.cst(nextStateName)
                        }
                    }
                })

                // counter must be end
                if (target.counter) target.counter = null
                target.counter = _counter
            },
            update(target) {
                //console.log('updating ' + stateName)
                if (data.transition) {
                    for (const key in data.transition) {
                        if (key === 'onEnd') continue
                        if (keys[key]?.pressed) {
                            const next = data.transition[key]
                            target.cst(next)
                            return
                        }
                    }
                }
            }
        }
    }

    function loadCharacterData(data) {
        const states = {}
        for (const stateName in data.state) {
            states[stateName] = createStateFromData(stateName, data.state[stateName])
        }

        return {
            states,
            initialState: states[data.initialState],
            hp: data.hp,
            spriteCollection: { f: data.spriteFolder, p: data.spriteCollection }
        }
    }



    class Player {
        constructor(data) {
            console.log('state machine data version online')
            const loaded = loadCharacterData(data)
            this.states = loaded.states
            this.state = loaded.initialState
            this.state.enter(this)

            this.position = { x: 2, y: 1 }
            this.renderer = new MovieRenderer2(this, loaded.spriteCollection)
            this.HP = loaded.hp

        }



        cst(stateName) {
            this.counter.setEnd()
            this.state = this.states[stateName]
            this.state.enter(this)

        }

        showMSG(msg) {
            log("[MSG] " + msg)
        }

        observeUpdate(subject) {
            for (const n of subject.notification) {
                if (n.content == 'test') log('got it!!')
            }
        }

        observeUpdate(subject, content, owner) {
            if (content == 'test') log('got it!!!!')
        }



        update() {
            //if (this.ID == CharID.Player)
            if (this.state && this.state.update)
                this.state.update(this)

            if (this.position.y > 3) this.position.y = 3
            else if (this.position.y < 1) this.position.y = 1
            if (this.position.x > 3) this.position.x = 3
            else if (this.position.x < 1) this.position.x = 1
        }

        draw() {
            if (this.counter) {
                this.renderer.draw()
            }

            const temp_draw = () =>
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40,
                    20,
                    tileSize,
                )
            const temp_print = (msg) =>
                c.fillText(
                    msg,
                    10 + ((this.position.x - 1) * canvas.width) / 6,
                    (this.position.y * canvas.height) / 6 + 40 + 10,
                )
            const temp_draw_gauge = (_counter) => {
                c.fillStyle = "rgba(127,127,127,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40 + tileSize,
                    tileSize,
                    5,
                )
                c.fillStyle = "rgb(255, 255, 255)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40 + tileSize,
                    (_counter.time / _counter.endTime) * tileSize,
                    5,
                )
            }
            const temp_draw_gauge2 = (_current, _max) => {
                c.fillStyle = "rgba(128,128,128,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 10,
                    tileSize,
                    5,
                )
                c.fillStyle = "rgba(255,0,0,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 10,
                    (_current / _max) * tileSize,
                    5,
                )
            }

            temp_draw_gauge2(this.HP, 100)
            if (this.state["buffed"]) {
                c.fillStyle = "rgb(251, 255, 0)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 20,
                    tileSize,
                    5,
                )
            }


            if (this.ID == CharID.Enemy) {
                c.fillStyle = "rgba(255,0,255,1)"
                temp_draw()

            }


            c.fillStyle = "rgb(255, 255, 255)"
            temp_print(this.state.name)


            if (this.counter) {
                temp_draw_gauge(this.counter)
            }
        }
    }




    class GMBattle {
        constructor() {
            this.name = 'battle'
        }
        handleInput(t) {
            //log('gm battle')
            if (t.state["dialog"]) {
                if (keys.atk.pressed) {
                    t.state["dialog"] = false
                }
            }

            if (!t.state['pause']) {
                if (keys.select.pressed) {
                    return t.cst(t.constructor.select)
                }
            }

            if (keys.pause.pressed) {
                if (t.state["pause"]) t.state["pause"] = false
                else t.state["pause"] = true
            }

            if (keys.switch.pressed){
                t.notify('test',t)
                characters.pop()
                player3 = charL
                characters.push(player3)
            }





            if (keys.test.pressed) {
                const c = t.addCounter({
                    endTime: 300,
                })
                c.processCall = () => {
                    // プレイヤーキャラを使って制御のテストする
                    // 懐かしいな。ムービーゲーの可能性を見つけたあの午後の雰囲気を思い出す
                    if (c.time == 1) {
                        player2_2.position.x = player_2.position.x
                        player2_2.position.y = player_2.position.y
                        characters.push(player2_2)
                    } else if (c.time == 30) {
                        if (player2_2.startMove(0, 1))
                            player2_2.cst(Player2.moving)
                    } else if (c.time == 80) {
                        player2_2.cst(Player2.attack)
                    } else if (c.time == 100) {
                        enemy.HP -= 30
                    } else if (c.time == 200) {
                        characters.pop()

                    }
                }
            }
        }

        enter(t) {
            log('now fight!')
        }

    }

    class GMBattleWin {
        constructor() {
            this.name = 'win!'
        }
    }

    class GMTitle {
        constructor() {
            this.name = 'title'
        }
        handleInput(t) {
            if (keys.select.pressed) {
                t.cst(t.constructor.battle)
            }
        }
    }
    class GMPause {

    }
    class GMDialog {

    }
    class GMSelect {
        constructor() {
            this.name = 'select'
            this.counter = null
        }
        handleInput(t) {
            if (keys.select.pressed) {
                return t.cst(t.constructor.battle)
            }

            if (keys.add_sword.pressed) {
                chip_selected.push(chip_list.sword)
            }

        }
        enter(t) {
            log('select chips!')
            const c = t.addCounter_select({
                endTime: 10,
                endCall: () => { log('select transition end') },
            })
            this.counter = c
        }

        update(t) { }
        draw(t) {
            let h = this.counter.time / this.counter.endTime
            c.fillStyle = "rgba(200,230,250,1)"
            c.fillRect(20 * h, 20 * h, canvas.width / 3 * h, canvas.height / 2)
            if (t.PET_chip.loaded) {
                c.drawImage(t.PET_chip.img, 30 * h, 30 * h, t.PET_chip.img.width * h, t.PET_chip.img.height)
            }
        }
    }

    class GameManager2 {
        static battle = new GMBattle()
        static title = new GMTitle()
        static dialog = new GMDialog()
        static pause = new GMPause()
        static select = new GMSelect()
        static battle_win = new GMBattleWin()
        constructor() {
            this.st = GameManager2.battle
            console.log("game manager online")
            this.isPaused = false
            this.chips = []
            this.counters = []
            this.counters_select = []
            this.notification = []
            this.observers = []
            this.dominantCounter = null
            this.state = {
                pause: false,
                title: false,
                world: false,
                dialog: false,
                battle: true,
                battle_win: false,
            }

            this.PET_chip = new ImageLoader('https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4874.png')
            this.Mugshot = new ImageLoader('https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4877.png')

        }


        _showCounters() {
            let _table = ""
            for (let _c of this.counters) {
                _table += _c.msg + ":" + _c.time + "/" + _c.endTime + "\n"
            } for (let _c of this.counters_select) {
                _table += _c.msg + ":" + _c.time + "/" + _c.endTime + "\n"
            }
            showCounters(_table)
        }

        #showChips() {
            let _table = ""
            for (let chip of chip_selected) {
                _table += chip.name + ", "
            }
            showChips(_table)
        }

        _draw_Darken() {
            c.fillStyle = "rgba(0,0,0,0.5)"
            c.fillRect(0, 0, canvas.width, canvas.height)
        }

        notify() {
            for (const ob of this.observers) {
                ob.observeUpdate(this)
            }
        }

        notify(content, sender) {
            for (const ob of this.observers) {
                ob.observeUpdate(this, content, sender)
            }
        }


        cst(_state) {
            this.st = _state
            this.st.enter(this)
            return _state
        }


        addSPCounter() {
            let _c = new Counter({
                endTime: 100,
            })

            _c.processCall = () => {
                let _t = _c.time
                if (_c.time == 1) PP.state["darken"] = true
                if (_c.time == 10) if (_c.time == 40) log("player animation")
                if (_c.time == 100) {
                    log("over")
                    PP.state["darken"] = false
                }

                if (_t < 10) {
                    PP.fillStyle = `rgba(255,255,255,${Math.min(_t * 0.1, 1) * 0.5})`
                } else if (_t < 90) {
                    PP.fillStyle = "rgba(255,255,255,0.5)"
                } else {
                    PP.fillStyle = `rgba(255,255,255,${0.5 - (_t - 90) * 0.1 * 0.5})`
                }
            }
            GM.dominantCounter = _c
        }

        addCounter({
            msg = "[untitled]",
            endTime = 10,
            processCall = null,
            endCall = () => {
                this.end = true
            },

        } = {}) {
            let _temp = new Counter({
                endTime: endTime,
                msg: msg,
                processCall: processCall,
                endCall: endCall,
            })
            this.counters.push(_temp)
            return _temp
        }

        addCounter_select({
            endTime = 10,
            msg = "_untitled_counter",
            processCall = null,
            endCall = () => {
                this.end = true
            },
            _gen_list = null,
            _qteCall = null,
        } = {}) {
            console.log("add counter for: " + msg)
            let _temp = new Counter({
                endTime: endTime,
                msg: msg,
                processCall: processCall,
                endCall: endCall,
                gen_list: _gen_list,
                qteCall: _qteCall,
            })
            this.counters_select.push(_temp)
            return _temp
        }

        #print_state() {
            c.fillStyle = "rgba(255,255,255,255)"
            c.fillText(this.st.name, 10, 10)
            //log(this.st.name)
        }

        #draw() {
            if (this.st == this.constructor.title) {
                c.fillStyle = "rgba(0,0,0,1)"
                c.fillRect(0, 0, canvas.width, canvas.height)
                c.fillStyle = "rgba(255,255,255,1)"
                c.fillText("press select key to start", 10, canvas.height / 2)
                return
            }
            if (this.st == this.constructor.battle || this.st == this.constructor.select) {
                c.fillStyle = "rgba(0,0,0,1)"
                c.fillRect(0, 0, canvas.width, canvas.height)
                c.fillStyle = "rgba(255,255,255,1)"
                if (this.Mugshot.loaded)
                    c.drawImage(this.Mugshot.img, 0, 24, 48, 24)
                else { c.fillStyle = 'red'; c.fillRect(0, 24, 48, 24); }
            }

            if (this.state['battle_win']) {
                c.fillStyle = "rgba(200,230,250,1)"
                c.fillRect(0, 0, canvas.width, canvas.height)
                c.fillStyle = "rgba(0,20,0,1)"
                c.fillText("you win!", 10, canvas.height / 2)
                return
            }



            // draw floor
            const _draw_floor = () => {
                c.fillStyle = "rgba(220,220,220,1)"
                c.fillRect(0, canvas.height / 2, canvas.width, canvas.height)

                c.strokeStyle = "purple"
                c.lineWidth = 5
                c.beginPath() // パスの開始
                c.moveTo(0, canvas.height / 2) // 開始点（x:50, y:50）
                c.lineTo(0, canvas.height)
                c.lineTo(canvas.width, canvas.height) // 終点（x:250, y:100）
                c.lineTo(canvas.width, canvas.height / 2)
                c.lineTo(0, canvas.height / 2)
                for (let i = 1; i < 3; i++) {
                    c.moveTo(0, (canvas.height / 6) * i + canvas.height / 2)
                    c.lineTo(canvas.width, (canvas.height / 6) * i + canvas.height / 2)
                }
                for (let i = 1; i < 6; i++) {
                    c.moveTo((canvas.width / 6) * i, canvas.height / 2)
                    c.lineTo((canvas.width / 6) * i, canvas.height)
                }
                c.stroke()
            }
            _draw_floor()

            if (this.state["pause"]) {
                this._draw_Darken()
            }

            this._showCounters()
            this.#showChips()


            if (this.state["dialog"]) {
                if (imgLoaded) {
                    c.drawImage(img, 0, 0, 30, 30)
                }
                c.fillStyle = "rgba(100,100,100,1)"
                c.fillRect(
                    10,
                    (canvas.height / 4) * 3,
                    canvas.width - 20,
                    canvas.height / 5,
                )
            }

            PP.draw()
            for (let _p of characters) {
                _p.draw()
                //log('draw characters')
            }

            if (this.st == this.constructor.select) {
                this.st.draw(this)
            }

            this.#print_state()
        }

        #update_counters() {
            if (this.st == this.constructor.select) {
                for (let _c of this.counters_select) {
                    _c.update()
                }
                this.counters_select = this.counters_select.filter((_c) => _c.end == false)

                return
            }

            if (this.dominantCounter) {
                this.dominantCounter.update()
                if (this.dominantCounter.end) this.dominantCounter = null
                return
            }
            for (let _c of this.counters) {
                _c.update()
            }
            this.counters = this.counters.filter((_c) => _c.end == false)
        }

        update() {
            const s = this.st.handleInput(this)
            if (s) this.st = s

            if (this.state["title"]) {
            } else if (this.state["pause"]) {
                //     console.log('paused')
            } else {
                if (this.st == this.constructor.battle) {
                    this.#update_counters()
                    for (let p of characters) {
                        p.update()
                    }
                    if (this.state['battle']) {
                        if (enemy.HP <= 0) { this.state['battle_win'] = true; this.state['battle'] = false }
                    }
                    if (this.state['battle_win']) { }
                }
                if (this.st == this.constructor.select) {
                    this.#update_counters()

                }



            }

            for (let _key in keys) keys[_key].pressed = false

            //console.log(message+counter)
            this.#draw()
        }
    }

    class PostProcessor {
        constructor() {
            this.state = {
                darken: false,
            }
            this.fillStyle = "rgba(0, 0, 0,1)"
        }
        draw() {
            if (this.state["darken"]) {
                //log(this.fillStyle)
                c.fillStyle = this.fillStyle
                c.fillRect(0, 0, canvas.width, canvas.height)

                this.down_saturation()
                c.fillStyle = "rgb(255, 255, 255)"
                c.fillText("auto proccessing...", canvas.width / 2, canvas.height / 2)
                c.save()
                let fontSize = 64
                c.font = `${fontSize}px Arial`
                c.fillStyle = "rgb(255, 211, 17)"
                c.fillText("WIPEOUT!", 0, canvas.height / 2)
                c.restore()
            }
        }

        down_saturation() {
            // 彩度を0%にして再描画
            const offCanvas = document.createElement("canvas")
            offCanvas.width = canvas.width
            offCanvas.height = canvas.height
            const offCtx = offCanvas.getContext("2d")

            // 一旦現在の canvas をオフスクリーンにコピー
            offCtx.drawImage(canvas, 0, 0)

            // 彩度を下げて再描画
            c.clearRect(0, 0, canvas.width, canvas.height)
            c.filter = "saturate(20%)"
            c.drawImage(offCanvas, 0, 0)
            c.filter = "none" // 忘れずに戻す
        }
    }



    // only render
    class MovieRenderer {
        constructor(master) {
            this.master = master
            this.drawposition = { x: 0, y: 0 }

            this.spriteName = ''
            this.spriteImage = new Image()
            this.spriteLoad = false
            this.spriteFlip = false
            this.spriteCollection = ModelHData.spriteCollection
            this.length = 1 // numbers of frames
            this.currentFrame = 0
            this.cropbox = {}
            this.sprite = {
                width: 0,
                height: 0
            }
        }

        #updateSpriteInfo(_name) {
            if (this.spriteName == _name) return
            this.spriteFlip = false
            this.spriteLoad = false
            this.spriteName = _name
            let s = this.spriteCollection[_name]
            if (s.flip) this.spriteFlip = true
            this.spriteImage.src = s.path
            this.length = 1
            this.sprite = {
                width: 0,
                height: 0
            }
            this.spriteImage.onload = () => {
                this.spriteLoad = true
                this.length = this.spriteCollection[_name].length
                this.sprite = {
                    width: this.spriteImage.width / this.length,
                    height: this.spriteImage.height
                }
            }
        }

        // master state, main counter
        #update() {

            if (this.master.st == this.master.constructor.idle) {
                this.#updateSpriteInfo('idle')
                //log('player_2 render idle')
            } else if (this.master.st == this.master.constructor.attack) {
                this.#updateSpriteInfo('attack2')
                //log('render attack')
            } else if (this.master.st == this.master.constructor.moving) {
                this.#updateSpriteInfo('move')
                //log('render attack')
            } else if (this.master.st == this.master.constructor.skill) {
                this.#updateSpriteInfo('attack1')
                //log('render attack')
            } else if (this.master.st == this.master.constructor.injured) {
                this.#updateSpriteInfo('injured')
                //log('render attack')
            } else {
                this.spriteName = ''
                this.spriteImage = null
                log('no shit to render')
                return
            }


            let mc = this.master.counter
            let mp = this.master.position
            this.drawposition.x = ((mp.x - 1) * canvas.width) / 6 + 10
            this.drawposition.y = (mp.y * canvas.height) / 6 + 40


            let FrameBuffer = mc.endTime / this.length
            this.currentFrame = Math.floor(mc.time / FrameBuffer)
            this.currentFrame %= this.length // loop
        }

        // draw position + Current Frame
        draw() {
            this.#update()

            const cropbox = {
                position: {
                    x: this.sprite.width * this.currentFrame,
                    y: 0,
                },
                width: this.sprite.width,
                height: this.sprite.height,
            }

            if (this.spriteImage) {
                if (!this.spriteLoad) return
                if (!this.spriteFlip) {
                    c.drawImage(
                        this.spriteImage,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        this.drawposition.x,
                        this.drawposition.y,
                        this.sprite.width,
                        this.sprite.height,
                    )
                } else {
                    c.save()
                    c.scale(-1, 1);
                    let _temp = -this.sprite.width
                    c.drawImage(
                        this.spriteImage,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        -this.drawposition.x + _temp,
                        this.drawposition.y,
                        this.sprite.width,
                        this.sprite.height,
                    )
                    c.restore()
                }

            }

            c.fillStyle = 'rgba(0,0,0,1)'
            c.fillText(this.currentFrame, this.drawposition.x, this.drawposition.y + 20, 24)
        }
    }

    class MovieRenderer2 {
        constructor(master, spriteCollection) {
            this.master = master
            this.drawposition = { x: 0, y: 0 }
            this.spriteCollection = spriteCollection
            this.spriteName = ''
            this.damiSprite = new Image()
            this.spriteImage = this.damiSprite
            this.spriteLoad = false
            this.spriteFlip = false
            this.length = 1 // numbers of frames
            this.currentFrame = 0
            this.cropbox = {}
            this.sprite = {
                width: 0,
                height: 0
            }
        }

        #updateSpriteInfo(_name) {
            if (!this.spriteCollection.p[_name]) return false
            if (this.spriteName == _name) return true
            this.spriteFlip = false
            this.spriteLoad = false
            this.spriteName = _name
            let s = this.spriteCollection.p[_name]
            if (s.flip) this.spriteFlip = true
            if (!this.spriteImage) this.spriteImage = this.damiSprite
            this.spriteImage.src = this.spriteCollection.f + s.path
            console.log('path: ' + ModelPData.spriteFolder)
            console.log('path: ' + this.spriteCollection.f)

            this.length = 1
            this.sprite = {
                width: 0,
                height: 0
            }
            this.spriteImage.onload = () => {
                this.spriteLoad = true
                this.length = this.spriteCollection.p[_name].length
                this.sprite = {
                    width: this.spriteImage.width / this.length,
                    height: this.spriteImage.height
                }
            }

            return true
        }

        // master state, main counter
        #update() {
            if (this.#updateSpriteInfo(this.master.state.name)) { }
            else {
                this.spriteName = ''
                this.spriteImage = null
                log('no shit to render')
                return
            }


            let mc = this.master.counter
            let mp = this.master.position
            this.drawposition.x = ((mp.x - 1) * canvas.width) / 6 + 10
            this.drawposition.y = (mp.y * canvas.height) / 6 + 40


            let FrameBuffer = mc.endTime / this.length
            this.currentFrame = Math.floor(mc.time / FrameBuffer)
            this.currentFrame %= this.length // loop
        }

        // draw position + Current Frame
        draw() {
            this.#update()

            const cropbox = {
                position: {
                    x: this.sprite.width * this.currentFrame,
                    y: 0,
                },
                width: this.sprite.width,
                height: this.sprite.height,
            }

            if (this.spriteImage) {
                if (!this.spriteLoad) return
                if (!this.spriteFlip) {
                    c.drawImage(
                        this.spriteImage,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        this.drawposition.x,
                        this.drawposition.y,
                        this.sprite.width,
                        this.sprite.height,
                    )
                } else {
                    c.save()
                    c.scale(-1, 1);
                    let _temp = -this.sprite.width
                    c.drawImage(
                        this.spriteImage,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        -this.drawposition.x + _temp,
                        this.drawposition.y,
                        this.sprite.width,
                        this.sprite.height,
                    )
                    c.restore()
                }

            }

            c.fillStyle = 'rgba(127,127,127,1)'
            c.fillText(this.currentFrame, this.drawposition.x, this.drawposition.y + 20, 24)
        }
    }

    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    //
    //      utility_setup.js
    //
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////

    // maybe put these things into a class
    const chip_list = {
        sword: { name: "sword" },
        wide_sword: { name: "wide_sword" },
        long_sword: { name: "long_sword" },
    }

    var chip_selected = []

    for (let _c of chip_selected) {
        log(_c.name)
    }

    //////////////////////////////
    //////////////////////////////
    //                          //
    //      main.js
    //                          //
    //////////////////////////////
    //////////////////////////////

    const canvas = document.querySelector("canvas")
    const c = canvas.getContext("2d", { willReadFrequently: true })
    canvas.width = 300
    canvas.height = 200
    const tileSize = 50

    const GM = new GameManager2()
    let counter = 0
    let player_2 = new Player2()
    let enemy = new Player2()
    let player2_2 = new Player2()
    enemy.ID = CharID.Enemy
    player2_2.ID = CharID.Actor

    const charH = new Player(ModelHData2)
    const charL = new Player(ModelPData)
    let player3 = charH

    let characters = []
    characters.push(player_2)
    characters.push(enemy)
    characters.push(player3)

    enemy.position = { x: 5, y: 2 }
    const PP = new PostProcessor()



    let imageLoaded = false
    let image = new Image()
    image.crossOrigin = "anonymous";//これ入れても行けないケースがいるらしい
    image.src = 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/battle_floor.png'

    image.onload = () => {
        imageLoaded = true
    }



    let R_angle = 0;

    const Renderer = new PolygonRenderer()
    GM.observers.push(player3)

    function update() {

        //polygon renderer,描画順などがめんどくさいので、あとにする
        // R_angle += 0.001
        //Renderer.render()


        GM.update()
        //GM.notify('tests', GM)

        requestAnimationFrame(update)


    }

    update()
</script>
