<canvas></canvas>

<p>
    <button class="b1"> </button>
    <button class="b1" onmousedown="keyPress('up')">↑</button>
    <button class="b1"> </button>
</p>
<p>
    <button class="b1" onmousedown="keyPress('left')">←</button>
    <button class="b1" onmousedown="keyPress('down')">↓</button>
    <button class="b1" onmousedown="keyPress('right')">→</button>
    <button class="b1"> </button>
    <button onmousedown="keyPress('atk')">attack</button>
    <button onmousedown="keyPress('ssss')">ssss</button>
    <button onmousedown="keyPress('toModelL')">toModelL</button>
    <button onmousedown="keyPress('toModelH')">toModelH</button>

</p>

<div>
    <p>
        <button onmousedown="keyPress('add_sword')">add sword</button>
        <button onmousedown="keyPress('select')">select</button>
        <button onmousedown="keyPress('pause')">pause</button>
        <button onmousedown="keyPress('use_chip')">use the chip</button>
    </p>
</div>
<button onmousedown="keyPress('test_injured')">test_injured </button>

<button onmousedown="keyPress('test')">add control counter</button>
<button onmousedown="clearLog()">clear log </button>

<p>
<div id="position"></div>

<div id="chips"></div>
<div id="counters"></div>
<div id="log"></div>
</p>

<style>
    .b1 {
        width: 40px;
        height: 20px;
    }

    .container {
        display: flex;
    }

    .left-column {
        font-size: 10px;
        width: 30%;
        background-color: #f0f0f0;
        padding: 10px;
    }

    .right-column {
        width: 70%;
        background-color: #8f8f8f;
        padding: 10px;
    }
</style>


<script id="data">
   
    const ModelHData2 =
    {
        name: "ModelH",
        element: "thunder",
        hp: 80,
        initialState: 'idle',

        state: {
            idle: {
                duration: 202,
                transition: {
                    onMove: 'move',
                    atk: 'attack1',
                    onEnd: 'idle'
                },
                sprite_info: {},
                on: {
                    onMove: {
                        nextState: 'move'
                    },
                    onEnd: {
                        nextState: 'idle'
                    },
                    atk: {
                        nextState: 'attack1'
                    },

                },
            },
            move: {
                duration: 30,
                steps: [
                    { time: 15, action: (target) => GM.notify('movable', GM) }
                ],
                transition: {
                    onEnd: 'idle'
                },
                on: {

                    onEnd: {
                        nextState: 'attack1'
                    },

                },
            },

            inStage: {
                duration: 30,
                transition: {
                    onEnd: 'idle'
                },
            },
            outStage: {
                duration: 30,
                transition: {
                    onEnd: 'idle'
                },
            },
            attack1: {
                duration: 20,
                steps:
                    [
                        { time: 30, action: (target) => target.showMSG('count 100') },
                        { time: 70, action: (target) => target.showMSG('count 300') },
                    ],
                transition: {
                    atk: 'attack2',
                    onEnd: 'idle'
                },
                on: {
                    onEnd: {
                        nextState: 'idle'
                    },
                    atk: {
                        nextState: 'attack2'
                    },

                },
            },
            attack2: {
                duration: 80,
                transition: {
                    onEnd: 'idle',
                    atk: 'injured'
                },

                on: {
                    onEnd: {
                        nextState: 'idle'
                    },
                    atk: {
                        nextState: 'idle'
                    },

                },
            },

            injured: {
                duration: 30,
                transition: {
                    onEnd: 'idle',
                    atk: 'attack1'
                },
                invisible: true

            },


        },
        spriteFolder: 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/',

        spriteCollection: {
            test: {
                path: "https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/red/enchant.png",
                length: 8,
            },
            move: {
                path:
                    'IMG_4867.png',
                length: 8,
                flip: true,
            },
            idle: {
                path:
                    'IMG_4865.png',
                length: 4,
                flip: true,
            },
            inStage: {
                path: 'IMG_4866.png',
                length: 12,
                flip: true,
            },
            outStage: {
                path: 'IMG_4901.png',
                length: 8,
                flip: true,
            },
            attack1: {
                path: 'IMG_4863.png',
                length: 4,
            },
            attack2: {
                path: 'IMG_4866.png',
                length: 12,
                flip: true,
            },
            injured: {
                path: 'IMG_4873.png'
                ,
                length: 5,
                flip: true,
            }
        }

    }
    const ModelHData_eventDrived =
    {
        name: "ModelH",
        element: "thunder",
        hp: 80,
        initialState: 'idle',

        state: {
            idle: {
                duration: 202,
                sprite: {
                    path: 'IMG_4865.png',
                    length: 4,
                    flip: true,
                },
                on: {
                    onMove: {
                        nextState: 'move'
                    },
                    onEnd: {
                        nextState: 'idle'
                    },
                    atk: {
                        nextState: 'attack1'
                    },

                },
            },
            move: {
                duration: 30,
                sprite: {
                    path:
                        'IMG_4867.png',
                    length: 8,
                    flip: true,
                },
                steps: [
                    { time: 15, action: (target) => { console.log('pushed'); target.pushEvent('movable'); } }
                ],

                on: {
                    movable: true,
                    onEnd: {
                        nextState: 'idle'
                    },

                },

            },

            inStage: {
                duration: 30,
                on: {
                    onEnd: {
                        nextState: 'idle'
                    },

                },
                sprite: {
                    path: 'IMG_4866.png',
                    length: 12,
                    flip: true,
                },
            },
            outStage: {
                duration: 30,
                on: {
                    onEnd: {
                        nextState: 'idle'
                    },

                },
                sprite: {
                    path: 'IMG_4901.png',
                    length: 8,
                    flip: true,
                },
            },
            attack1: {
                duration: 20,
                steps:
                    [
                        { time: 30, action: (target) => target.showMSG('count 100') },
                        { time: 70, action: (target) => target.showMSG('count 300') },
                    ],

                on: {
                    onEnd: {
                        nextState: 'idle'
                    },
                    atk: {
                        nextState: 'attack2'
                    },

                },
                sprite: {
                    path: 'IMG_4863.png',
                    length: 4,
                },
            },
            attack2: {
                duration: 80,


                on: {
                    onEnd: {
                        nextState: 'idle'
                    },
                    atk: {
                        nextState: 'idle'
                    },

                },
                sprite: {
                    path: 'IMG_4866.png',
                    length: 12,
                    flip: true,
                },
            },

            injured: {
                duration: 30,
                transition: {
                    onEnd: 'idle',
                    atk: 'attack1'
                },
                on: {
                    onEnd: {
                        nextState: 'idle'
                    },

                },
                sprite: {
                    path: 'IMG_4873.png'
                    ,
                    length: 5,
                    flip: true,
                },
                invisible: true

            },


        },
        spriteFolder: 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/',

    }
    const ModelLData =
    {
        name: "ModelL",
        element: "ICE?",
        hp: 120,
        initialState: 'idle',

        state: {
            idle: {
                duration: 202,
                transition: {
                    atk: 'attack1',
                    onEnd: 'idle',
                    onMove: 'move',
                },
            },
            move: {
                duration: 30,
                steps: [
                    { time: 15, action: (target) => GM.notify('movable', GM) }
                ],
                transition: {
                    onEnd: 'idle'
                },
            },
            inStage: {
                duration: 60,
                transition: {
                    onEnd: 'idle'
                },
            },

            attack1: {
                duration: 100,
                steps:
                    [
                        { time: 30, action: (target) => target.showMSG('count 100') },
                        { time: 70, action: (target) => target.showMSG('count 300') },
                    ],
                transition: {
                    atk: 'attack2',
                    onEnd: 'idle'
                }
            },
            attack2: {
                duration: 120,
                transition: {
                    onEnd: 'idle',
                    atk: 'injured'
                }
            },

            injured: {
                duration: 30,
                transition: {
                    onEnd: 'idle',
                    atk: 'attack1'
                },
                invisible: true

            },


        },
        spriteFolder: 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/',
        spriteCollection: {

            move: {
                path: 'IMG_4898.png',
                rect: { w: 40, h: 64 },
                length: 7,
                flip: true,
            },
            idle: {
                path: 'IMG_4899.png'
                , rect: { w: 44, h: 50 },
                length: 4,
                flip: true,
            },
            inStage: {
                path: 'IMG_4894.png'
                ,
                rect: { w: 100, h: 64 },
                length: 5,
                flip: true,
            },
            attack1: {
                path: 'IMG_4897.png'
                ,
                rect: { w: 44, h: 56 },
                length: 12,
                flip: true,
            },
            attack2: {
                path: 'IMG_4894.png'
                ,
                rect: { w: 100, h: 64 },
                length: 5,
                flip: true,
            },
            injured: {
                path: 'IMG_4873.png'
                ,
                rect: { w: 45, h: 50 },
                length: 5,
                flip: true,
            }
        }

    }

</script>

<script id="functions Engine">
    keyPress = function (key) {
        keys[key].pressed = true
    }

    const keys = new Proxy({}, {
        get(target, prop) {
            if (!(prop in target)) {
                target[prop] = { press: false, pressed: false };
            }
            return target[prop];
        }
    });

    function showHTML(MSG, ID) {
        document.getElementById(ID).innerText = MSG
    }


    function log(msg) {
        document.getElementById("log").innerText += msg + "\n_"
    }
    function showChips(msg) {
        document.getElementById("chips").innerText = "[battle chips]:" + "\n_" + msg
    }
    function showCounters(msg) {
        document.getElementById("counters").innerText = "[Counters]:" + "\n_" + msg
    }
    function clearLog() {
        document.getElementById('log').innerText = "[my console]:\n"
    }
    clearLog()
    showChips("no chips")


    class ImageLoader {
        constructor(url) {
            this.loaded = false
            this.img = new Image()
            this.img.src = url
            this.img.onload = () => {
                this.loaded = true
            }
        }
        load(url) {
            this.loaded = false
            this.img.src = url
            this.img.onload = () => {
                this.loaded = true
            }
        }
    }


    class Counter {
        constructor({
            endTime = 100,
            name = "",
            end = false,
            target = undefined,
            msg = "__",
            processCall = null,
            endCall = () => { },
            gen_list = false,
            qte = false,
            qteCall = false,
        } = {}) {
            this.time = 0
            this.endTime = endTime
            this.end = end
            this.target = target
            this.processCall = processCall
            this.msg = msg
            this.endCall = endCall
            this.gen_list = gen_list
            this.qteCall = qteCall
        }
        start() { }

        setEnd() {
            this.end = true
        }
        _isEnd() {
            return this.end
        }

        #endMethod() {
            //console.log(this.msg + " " + this.endTime + " counter end")
            this.end = true
            this.endCall()
        }

        progress() {
            return this.time / this.endTime
        }

        update() {
            if (this.time < this.endTime) {
                this.time++
                if (this.processCall) this.processCall()

            } else this.#endMethod()
        }
    }


</script>

<script id="class">
    // classes.js
    // difficult to split files
    const CharID = {
        Player: 0,
        Enemy: 1,
        Actor: 2,
    }




    function createStateFromData(stateName, data) {
        return {
            name: stateName,
            enter(target) {
                const _counter = GM.addCounter({
                    msg: '[' + stateName + ']',
                    endTime: data.duration,
                    processCall: () => {
                        for (const step of data.steps || [])
                            if (_counter.time === step.time)
                                step.action(target)
                    },
                    endCall: () => {
                        const nextStateName = data.transition?.onEnd;
                        if (nextStateName) {
                            target.cst(nextStateName)
                        }
                    }
                })

                // counter must be end
                if (target.counter) target.counter = null
                target.counter = _counter
            },
            update(target) {
                //console.log('updating ' + stateName)
                if (data.transition) {
                    for (const key in data.transition) {
                        if (key === 'onEnd') continue
                        if (key === 'invisible') continue
                        if (target.Tag.hitByThisShit === true && !data.invisible && target.Tag.invisible === false) {
                            target.cst('injured')
                            target.Tag.invisible = true
                        }
                        //ここからはUser Inputによる状態遷移
                        // なので
                        if (target.Tag['isActor']) return
                        if (key === 'onMove') {
                            if (keys.down.pressed) {
                                // check direction
                                if (target.setDeltaPosition(0, 1))
                                    target.cst(data.transition['onMove'])
                            }
                            if (keys.up.pressed) {
                                if (target.setDeltaPosition(0, -1))
                                    target.cst(data.transition['onMove'])
                            }
                            if (keys.left.pressed) {
                                if (target.setDeltaPosition(-1, 0))
                                    target.cst(data.transition['onMove'])
                            }
                            if (keys.right.pressed) {
                                if (target.setDeltaPosition(1, 0))
                                    target.cst(data.transition['onMove'])
                            }

                            continue
                        }
                        if (keys[key]?.pressed) {
                            const next = data.transition[key]
                            target.cst(next)
                            return
                        }
                    }
                }
            }
        }
    }

    function loadCharacterData(data) {
        const states = {}
        for (const stateName in data.state) {
            states[stateName] = createStateFromData(stateName, data.state[stateName])
        }

        return {
            states,
            initialState: states[data.initialState],
            hp: data.hp,
            spriteCollection: { f: data.spriteFolder, p: data.spriteCollection }
        }
    }



    class Player {
        constructor(data) {
            const loaded = loadCharacterData(data)
            this.states = loaded.states
            this.state = loaded.initialState
            console.log('Player state machine initialized')
            this.state.enter(this)

            this.ID = CharID.Player
            this.position = { x: 2, y: 1 }
            this.deltaPosition = { x: 0, y: 0 }
            this.renderer = new MovieRenderer2(this, loaded.spriteCollection)
            this.HP = loaded.hp

            // 使い捨て外部リクエスト、自由に追加できる。
            // 確認するたびにfalseにリセットされる
            this.request = new Proxy({}, {
                get: (target, prop) => {
                    const value = target[prop];
                    target[prop] = false; // 読んだら自動で false にする
                    return value ?? false;
                }
            });

            // 未定義状態。自由に書き込める。デフォルト状態はfalse
            this.Tag = new Proxy({}, {
                get(target, prop) {
                    return prop in target ? target[prop] : false;
                }
            })

        }



        cst(stateName) {
            this.counter.setEnd()
            this.state = this.states[stateName]
            this.state.enter(this)

        }

        showMSG(msg) {
            log("[MSG] " + msg)
        }

        // shift+alt+A
        /* observeUpdate(subject) {
            for (const n of subject.notification) {
                if (n.content == 'test') log('got it!!')
            }
        } */

        observeUpdate(subject, content, owner) {
            if (content == 'test') log('got it!!!!')
            if (content === 'movable') {
                this.request['movable'] = true
            }
        }


        setDeltaPosition(_x, _y) {
            if (
                this.position.x + _x < 1 ||
                this.position.x + _x > 3 ||
                this.position.y + _y < 1 ||
                this.position.y + _y > 3
            )
                return false
            this.deltaPosition = { x: _x, y: _y }
            return true
        }


        update() {
            // apply checked delta
            if (this.request['movable']) {
                this.position.x += this.deltaPosition.x
                this.position.y += this.deltaPosition.y
                this.deltaPosition = { x: 0, y: 0 }
            }


            // get new delta
            if (this.ID == CharID.Player) {
                if (this.state && this.state.update)
                    this.state.update(this)

                //
                if (this.position.y > 3) this.position.y = 3
                else if (this.position.y < 1) this.position.y = 1
                if (this.position.x > 3) this.position.x = 3
                else if (this.position.x < 1) this.position.x = 1
            }
        }

        draw() {
            if (this.counter) {
                this.renderer.draw()
            }

            const temp_draw = () =>
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40,
                    20,
                    tileSize,
                )
            const temp_print = (msg) =>
                c.fillText(
                    msg,
                    10 + ((this.position.x - 1) * canvas.width) / 6,
                    (this.position.y * canvas.height) / 6 + 40 + 10,
                )
            const temp_draw_gauge = (_counter) => {
                c.fillStyle = "rgba(127,127,127,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40 + tileSize,
                    tileSize,
                    5,
                )
                c.fillStyle = "rgb(255, 255, 255)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40 + tileSize,
                    (_counter.time / _counter.endTime) * tileSize,
                    5,
                )
            }
            const temp_draw_gauge2 = (_current, _max) => {
                c.fillStyle = "rgba(128,128,128,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 10,
                    tileSize,
                    5,
                )
                c.fillStyle = "rgba(255,0,0,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 10,
                    (_current / _max) * tileSize,
                    5,
                )
            }

            temp_draw_gauge2(this.HP, 100)
            if (this.state["buffed"]) {
                c.fillStyle = "rgb(251, 255, 0)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 20,
                    tileSize,
                    5,
                )
            }


            if (this.ID == CharID.Enemy) {
                c.fillStyle = "rgba(255,0,255,1)"
                temp_draw()

            }


            c.fillStyle = "rgb(255, 255, 255)"
            temp_print(this.state.name)


            if (this.counter) {
                temp_draw_gauge(this.counter)
            }
        }
    }






    class StateOfPlayer {
        constructor() {
            this.handlers = {}
            this.Tag = new Proxy({}, {
                get(target, prop) {
                    return prop in target ? target[prop] : false;
                }
            })
            this.on('getHurt', (target) => {
                target.state = new ImportedState('injured', target.data.state['injured'])
                target.state.enter(target)
            })
        }
        // 対応するeventとハンドラーを導入
        on(event, handler) {
            this.handlers[event] = handler
        }

        onRequest(eventName, target, ...args) {
            const handler = this.handlers[eventName]
            if (handler) handler(target, ...args)
        }

        update(target) {
            // 通常経過処理。ここに集約
            if (target.Tag.hitByThisShit === true && target.Tag.invisible === false) {
                target.Tag.invisible = true
                target.pushEvent('getHurt')
                log('noooo')
            }
        }

        enter(target) {
            console.log('entered!')
        }
    }

    class ImportedState extends StateOfPlayer {
        constructor(sname, data) {
            super()
            this.stateData = data
            this.name = sname
            log(sname)
            for (const [eName, def] of Object.entries(data.on || {})) {

                if (eName == 'movable') {
                    this.on('movable', (target) => {
                        console.log('movable')
                        target.position.x += target.deltaPosition.x
                        target.position.y += target.deltaPosition.y
                    })
                    continue
                }
                if (eName == 'onMove') {
                    this.Tag.onMove = true
                }
                this.on(eName, (target, eData) => {
                    if (def.log) log(target.name + ' ' + def.log)
                    if (def.nextState) {
                        target.cst(def.nextState)
                    }
                })


            }
        }

        update(target) {
            super.update(target)
            if (this.Tag.onMove) {
                if (keys.down.pressed) {
                    // check direction
                    if (target.setDeltaPosition(0, 1))
                        target.pushEvent('onMove')
                }
                if (keys.up.pressed) {
                    if (target.setDeltaPosition(0, -1))
                        target.pushEvent('onMove')
                }
                if (keys.left.pressed) {
                    if (target.setDeltaPosition(-1, 0))
                        target.pushEvent('onMove')
                }
                if (keys.right.pressed) {
                    if (target.setDeltaPosition(1, 0))
                        console.log('pushed')
                    target.pushEvent('onMove')
                }

            }
        }

        enter(target) {
            const _counter = GM.addCounter({
                msg: '[' + this.name + ']',
                endTime: this.stateData.duration,
                processCall: () => {
                    for (const step of this.stateData.steps || [])
                        if (_counter.time === step.time)
                            step.action(target)
                },
                endCall: () => {
                    target.pushEvent('onEnd')
                }
            })

            // counter must be end
            if (target.counter) target.counter.setEnd()
            target.counter = _counter
        }
    }
    class PlayerFromData {
        constructor(data) {
            this.data = data
            this.name = data.name
            this.HP = data.hp

            this.counter = new Counter({
                endTime: 100,
            })
            const initialState = data.state[data.initialState]
            this.state = new ImportedState(data.initialState, initialState)
            this.state.enter(this)
            this.eventQueue = []
            console.log('Player event drived state machine from data initialized')

            this.state.enter(this)

            this.position = { x: 1, y: 1 }
            this.movable = false
            this.deltaPosition = { x: 0, y: 0 }


            this.renderer = new MovieRenderer(this)

            // 使い捨て外部リクエスト、自由に追加できる。
            // 確認するたびにfalseにリセットされる
            this.request = new Proxy({}, {
                get: (target, prop) => {
                    const value = target[prop];
                    target[prop] = false; // 読んだら自動で false にする
                    return value ?? false;
                }
            });

            // 未定義状態。自由に書き込める。デフォルト状態はfalse
            this.Tag = new Proxy({}, {
                get(target, prop) {
                    return prop in target ? target[prop] : false;
                }
            })

        }



        cst(stateName) {
            this.state = new ImportedState(stateName, this.data.state[stateName])

            this.counter.setEnd()
            this.state.enter(this)

        }

        showMSG(msg) {
            log("[MSG] " + msg)
        }

        // shift+alt+A
        /* observeUpdate(subject) {
            for (const n of subject.notification) {
                if (n.content == 'test') log('got it!!')
            }
        } */

        observeUpdate(subject, content, owner) {
            if (content == 'test') log('got it!!!!')
            if (content === 'movable') {
                this.request['movable'] = true
            }
        }


        setDeltaPosition(_x, _y) {
            if (
                this.position.x + _x < 1 ||
                this.position.x + _x > 3 ||
                this.position.y + _y < 1 ||
                this.position.y + _y > 3
            )
                return false
            this.deltaPosition = { x: _x, y: _y }
            return true
        }



        pushEvent(eName, ...args) {
            this.eventQueue.push([eName, ...args])
        }

        update() {
            // apply checked delta
            // get new delta
            //if (this.ID == CharID.Player)
            for (const [ev, ...args] of this.eventQueue)
                this.state.onRequest(ev, this, ...args)
            this.eventQueue = []
            this.state.update(this)

            //

        }

        draw() {
            if (this.counter) {
                this.renderer.draw()
            }

            const temp_draw = () =>
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40,
                    20,
                    tileSize,
                )
            const temp_print = (msg) =>
                c.fillText(
                    msg,
                    10 + ((this.position.x - 1) * canvas.width) / 6,
                    (this.position.y * canvas.height) / 6 + 40 + 10,
                )
            const temp_draw_gauge = (_counter) => {
                c.fillStyle = "rgba(127,127,127,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40 + tileSize,
                    tileSize,
                    5,
                )
                c.fillStyle = "rgb(255, 255, 255)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40 + tileSize,
                    (_counter.time / _counter.endTime) * tileSize,
                    5,
                )
            }
            const temp_draw_gauge2 = (_current, _max) => {
                c.fillStyle = "rgba(128,128,128,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 10,
                    tileSize,
                    5,
                )
                c.fillStyle = "rgba(255,0,0,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 10,
                    (_current / _max) * tileSize,
                    5,
                )
            }

            temp_draw_gauge2(this.HP, 100)
            if (this.state["buffed"]) {
                c.fillStyle = "rgb(251, 255, 0)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 20,
                    tileSize,
                    5,
                )
            }


            if (this.ID == CharID.Enemy) {
                c.fillStyle = "rgba(255,0,255,1)"
                temp_draw()

            }


            c.fillStyle = "rgb(255, 255, 255)"
            temp_print(this.state.name)


            if (this.counter) {
                temp_draw_gauge(this.counter)
            }
        }
    }

    class Tile {
        constructor() {
            console.log('tile online')
            this.position = { x: 2, y: 2 }
        }

        update() {
            //hit test
            for (const p of characters) {
                if (p.position.x === this.position.x)
                    if (p.position.y === this.position.y) {
                        if (p.Tag.hitByThisShit === false && p.Tag.invisible === false) {
                            console.log('hit!')
                            p.Tag.hitByThisShit = true

                        }
                        return
                    }

            }

        }

        draw() {
            const h = canvas.height
            const w = canvas.width
            c.fillStyle = 'rgba(255,255,0,1)'
            c.fillRect(0 + w / 6 * (this.position.x - 1), h / 2 + h / 6 * (this.position.y - 1), w / 6, h / 6)

        }


    }



    class GMBattle {
        constructor() {
            this.name = 'battle'
        }
        handleInput(t) {
            //log('gm battle')
            if (t.Tag.dialog) {
                if (keys.atk.pressed) {
                    t.Tag.dialog = false
                }
            }

            if (!t.Tag.pause) {
                if (keys.select.pressed) {
                    return t.cst(t.constructor.select)
                }
            }

            if (keys.pause.pressed) {
                if (t.Tag.pause) t.Tag.pause = false
                else t.Tag.pause = true
            }

            // swtich character
            if (keys.toModelL.pressed) {
                if (active_player === charL) return
                if (GM.Tag.switch === false) {
                    GM.Tag.switch = true
                    //console.log('from:' + active_player.position.x + ' ' + active_player.position.x)
                    GM.switchCharacterMovie(charL)
                }


            }
            if (keys.toModelH.pressed) {
                if (active_player === charH) return
                active_player = GM.switchCharacter(active_player, charH)

            }





            if (keys.test.pressed) {
                const c = t.addCounter({
                    endTime: 300,
                })
                c.processCall = () => {
                    // プレイヤーキャラを使って制御のテストする
                    // 懐かしいな。ムービーゲーの可能性を見つけたあの午後の雰囲気を思い出す
                    if (c.time == 1) {
                        player2_2.position.x = player_2.position.x
                        player2_2.position.y = player_2.position.y
                        characters.push(player2_2)
                    } else if (c.time == 30) {
                        if (player2_2.startMove(0, 1))
                            player2_2.cst(Player2.moving)
                    } else if (c.time == 80) {
                        player2_2.cst(Player2.attack)
                    } else if (c.time == 100) {
                        enemy.HP -= 30
                    } else if (c.time == 200) {
                        characters.pop()

                    }
                }
            }
        }

        enter(t) {
            log('now fight!')
        }

    }

    class GMBattleWin {
        constructor() {
            this.name = 'win!'
        }
    }

    class GMTitle {
        constructor() {
            this.name = 'title'
        }
        handleInput(t) {
            if (keys.select.pressed) {
                t.cst(t.constructor.battle)
            }
        }
    }
    class GMDialog {

    }
    class GMSelect {
        constructor() {
            this.name = 'select'
            this.counter = null
        }
        handleInput(t) {
            if (keys.select.pressed) {
                return t.cst(t.constructor.battle)
            }

            if (keys.add_sword.pressed) {
                chip_selected.push(chip_list.sword)
            }

        }
        enter(t) {
            log('select chips!')
            const c = t.addCounter_select({
                endTime: 10,
                endCall: () => { log('select transition end') },
            })
            this.counter = c
        }

        update(t) { }
        draw(t) {
            let h = this.counter.time / this.counter.endTime
            c.fillStyle = "rgba(200,230,250,1)"
            c.fillRect(20 * h, 20 * h, canvas.width / 3 * h, canvas.height / 2)
            if (t.PET_chip.loaded) {
                c.drawImage(t.PET_chip.img, 30 * h, 30 * h, t.PET_chip.img.width * h, t.PET_chip.img.height)
            }
        }
    }

    class GameManager2 {
        static battle = new GMBattle()
        static title = new GMTitle()
        static dialog = new GMDialog()
        static select = new GMSelect()
        static battle_win = new GMBattleWin()

        constructor() {
            this.st = GameManager2.battle
            console.log("game manager online")
            this.isPaused = false
            this.chips = []
            this.counters = []
            this.counters_select = []
            this.notification = []
            this.observers = []
            this.dominantCounter = null



            this.request = new Proxy({}, {
                get: (target, prop) => {
                    const value = target[prop];
                    target[prop] = false; // 読んだら自動で false にする
                    return value ?? false;
                }
            });
            this.Tag = new Proxy({ battle: true }, {
                get(target, prop) {
                    return prop in target ? target[prop] : false;
                }
            })
            this.PET_chip = new ImageLoader('https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4874.png')
            this.Mugshot = new ImageLoader('https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4877.png')

        }


        _showCounters() {
            let _table = ""
            for (let _c of this.counters) {
                _table += _c.msg + ":" + _c.time + "/" + _c.endTime + "\n"
            } for (let _c of this.counters_select) {
                _table += _c.msg + ":" + _c.time + "/" + _c.endTime + "\n"
            }
            showCounters(_table)
        }

        #showChips() {
            let _table = ""
            for (let chip of chip_selected) {
                _table += chip.name + ", "
            }
            showChips(_table)
        }

        _draw_Darken() {
            c.fillStyle = "rgba(0,0,0,0.5)"
            c.fillRect(0, 0, canvas.width, canvas.height)
        }

        /*
        notify() {
            for (const ob of this.observers) {
                ob.observeUpdate(this)
            }
        }
            */

        notify(content, sender) {
            for (const ob of this.observers) {
                ob.observeUpdate(this, content, sender)
            }
        }

        switchCharacterMovie(next) {
            const c = GM.addCounter({
                endTime: 100,
                processCall: () => {
                    //active outTro

                    if (c.time == 1) {
                        active_player.Tag.isActor = true
                        active_player.Tag.greyout = true
                        active_player.cst('outStage')

                        next.position.x = active_player.position.x
                        next.position.y = active_player.position.y
                        characters.push(next)
                        next.cst('attack1')
                    } else if (c.time == 30) {
                        characters = characters.filter(item => item !== active_player);
                        this.observers = this.observers.filter(item => item !== active_player);
                    } else if (c.time == 50) {


                    }

                },
                endCall: () => {
                    active_player = GM.switchCharacter(active_player, next)
                    GM.Tag.switch = false

                }
            })
        }
        switchCharacter(current, next) {

            next.position.x = current.position.x
            next.position.y = current.position.y

            characters = characters.filter(item => item !== current);
            this.observers = this.observers.filter(item => item !== current);


            if (!characters.find(item => item === next))
                characters.push(next)
            if (!this.observers.find(item => item === next))
                this.observers.push(next)

            next.Tag.isActor = false
            next.Tag.greyout = false
            return next
        }


        cst(_state) {
            this.st = _state
            this.st.enter(this)
            return _state
        }


        addSPCounter() {
            let _c = new Counter({
                endTime: 100,
            })

            _c.processCall = () => {
                let _t = _c.time
                if (_c.time == 1) PP.state["darken"] = true
                if (_c.time == 10) if (_c.time == 40) log("player animation")
                if (_c.time == 100) {
                    log("over")
                    PP.state["darken"] = false
                }

                if (_t < 10) {
                    PP.fillStyle = `rgba(255,255,255,${Math.min(_t * 0.1, 1) * 0.5})`
                } else if (_t < 90) {
                    PP.fillStyle = "rgba(255,255,255,0.5)"
                } else {
                    PP.fillStyle = `rgba(255,255,255,${0.5 - (_t - 90) * 0.1 * 0.5})`
                }
            }
            GM.dominantCounter = _c
        }

        addCounter({
            msg = "[untitled]",
            endTime = 10,
            processCall = null,
            endCall = () => {
                this.end = true
            },

        } = {}) {
            let _temp = new Counter({
                endTime: endTime,
                msg: msg,
                processCall: processCall,
                endCall: endCall,
            })
            this.counters.push(_temp)
            return _temp
        }

        addCounter_select({
            endTime = 10,
            msg = "_untitled_counter",
            processCall = null,
            endCall = () => {
                this.end = true
            },
            _gen_list = null,
            _qteCall = null,
        } = {}) {
            console.log("add counter for: " + msg)
            let _temp = new Counter({
                endTime: endTime,
                msg: msg,
                processCall: processCall,
                endCall: endCall,
                gen_list: _gen_list,
                qteCall: _qteCall,
            })
            this.counters_select.push(_temp)
            return _temp
        }

        #print_state() {
            c.fillStyle = "rgba(255,255,255,255)"
            c.fillText(this.st.name, 10, 10)
            //log(this.st.name)
        }

        #draw() {
            if (this.st == this.constructor.title) {
                c.fillStyle = "rgba(0,0,0,1)"
                c.fillRect(0, 0, canvas.width, canvas.height)
                c.fillStyle = "rgba(255,255,255,1)"
                c.fillText("press select key to start", 10, canvas.height / 2)
                return
            }
            if (this.st == this.constructor.battle || this.st == this.constructor.select) {
                c.fillStyle = "rgba(0,0,0,1)"
                c.fillRect(0, 0, canvas.width, canvas.height)
                c.fillStyle = "rgba(255,255,255,1)"
                if (this.Mugshot.loaded)
                    c.drawImage(this.Mugshot.img, 0, 24, 48, 24)
                else { c.fillStyle = 'red'; c.fillRect(0, 24, 48, 24); }
            }

            if (this.Tag.battle_win) {
                c.fillStyle = "rgba(200,230,250,1)"
                c.fillRect(0, 0, canvas.width, canvas.height)
                c.fillStyle = "rgba(0,20,0,1)"
                c.fillText("you win!", 10, canvas.height / 2)
                return
            }



            // draw floor
            const _draw_floor = () => {
                c.fillStyle = "rgba(220,220,220,1)"
                c.fillRect(0, canvas.height / 2, canvas.width, canvas.height)

                c.strokeStyle = "purple"
                c.lineWidth = 5
                c.beginPath() // パスの開始
                c.moveTo(0, canvas.height / 2) // 開始点（x:50, y:50）
                c.lineTo(0, canvas.height)
                c.lineTo(canvas.width, canvas.height) // 終点（x:250, y:100）
                c.lineTo(canvas.width, canvas.height / 2)
                c.lineTo(0, canvas.height / 2)
                for (let i = 1; i < 3; i++) {
                    c.moveTo(0, (canvas.height / 6) * i + canvas.height / 2)
                    c.lineTo(canvas.width, (canvas.height / 6) * i + canvas.height / 2)
                }
                for (let i = 1; i < 6; i++) {
                    c.moveTo((canvas.width / 6) * i, canvas.height / 2)
                    c.lineTo((canvas.width / 6) * i, canvas.height)
                }
                c.stroke()
            }
            _draw_floor()

            if (this.Tag.pause) {
                this._draw_Darken()
            }

            this._showCounters()
            this.#showChips()


            if (this.Tag.dialog) {
                if (imgLoaded) {
                    c.drawImage(img, 0, 0, 30, 30)
                }
                c.fillStyle = "rgba(100,100,100,1)"
                c.fillRect(
                    10,
                    (canvas.height / 4) * 3,
                    canvas.width - 20,
                    canvas.height / 5,
                )
            }

            PP.draw()
            for (let _p of characters) {
                _p.draw()
                //log('draw characters')
            }


            if (this.st == this.constructor.select) {
                this.st.draw(this)
            }

            this.#print_state()
        }

        #update_counters() {
            if (this.st == this.constructor.select) {
                for (let _c of this.counters_select) {
                    _c.update()
                }
                this.counters_select = this.counters_select.filter((_c) => _c.end == false)

                return
            }

            if (this.dominantCounter) {
                this.dominantCounter.update()
                if (this.dominantCounter.end) this.dominantCounter = null
                return
            }
            for (let _c of this.counters) {
                _c.update()
            }
            this.counters = this.counters.filter((_c) => _c.end == false)
        }

        update() {
            const s = this.st.handleInput(this)
            if (s) this.st = s


            if (this.Tag.title) {
            } else if (this.Tag.pause) {
                //     console.log('paused')
            } else {
                if (this.st == this.constructor.battle) {
                    this.#update_counters()
                    for (let p of characters) {
                        p.update()
                    }
                    if (this.Tag.battle) {
                        if (enemy.HP <= 0) { this.Tag.battle_win = true; this.Tag.battle = false }
                    }
                    if (this.Tag.battle_win) { }
                }
                if (this.st == this.constructor.select) {
                    this.#update_counters()

                }



            }

            for (let _key in keys) keys[_key].pressed = false

            //console.log(message+counter)
            this.#draw()
        }
    }

    class PostProcessor {
        constructor() {
            this.state = {
                darken: false,
            }
            this.fillStyle = "rgba(0, 0, 0,1)"
        }
        draw() {
            if (this.state["darken"]) {
                //log(this.fillStyle)
                c.fillStyle = this.fillStyle
                c.fillRect(0, 0, canvas.width, canvas.height)

                this.down_saturation()
                c.fillStyle = "rgb(255, 255, 255)"
                c.fillText("auto proccessing...", canvas.width / 2, canvas.height / 2)
                c.save()
                let fontSize = 64
                c.font = `${fontSize}px Arial`
                c.fillStyle = "rgb(255, 211, 17)"
                c.fillText("WIPEOUT!", 0, canvas.height / 2)
                c.restore()
            }
        }

        down_saturation() {
            // 彩度を0%にして再描画
            const offCanvas = document.createElement("canvas")
            offCanvas.width = canvas.width
            offCanvas.height = canvas.height
            const offCtx = offCanvas.getContext("2d")

            // 一旦現在の canvas をオフスクリーンにコピー
            offCtx.drawImage(canvas, 0, 0)

            // 彩度を下げて再描画
            c.clearRect(0, 0, canvas.width, canvas.height)
            c.filter = "saturate(20%)"
            c.drawImage(offCanvas, 0, 0)
            c.filter = "none" // 忘れずに戻す
        }
    }



    // only render
    class MovieRenderer {


        constructor(master) {
            this.master = master
            this.drawposition = { x: 0, y: 0 }
            this.spriteName = ''
            this.damiSprite = new Image()
            this.spriteImage = this.damiSprite
            this.spriteLoad = false
            this.spriteFlip = false
            this.length = 1 // numbers of frames
            this.currentFrame = 0
            this.cropbox = {}
            this.sprite = {
                width: 0,
                height: 0
            }
        }

        #updateSpriteInfo(_name) {
            if (!this.master.data.state[_name].sprite) {
                log('not found sprite name')
                return false
            }
            if (this.spriteName == _name) return true
            let s = this.master.data.state[_name].sprite

            this.spriteFlip = false
            this.spriteLoad = false
            this.spriteName = _name
            if (s.flip) this.spriteFlip = true
            if (!this.spriteImage) this.spriteImage = this.damiSprite
            this.spriteImage.src = this.master.data.spriteFolder+s.path

            this.length = 1
            this.sprite = {
                width: 0,
                height: 0
            }
            this.spriteImage.onload = () => {
                this.spriteLoad = true
                this.length = s.length
                this.sprite = {
                    width: this.spriteImage.width / this.length,
                    height: this.spriteImage.height
                }
            }

            return true
        }

        // master state, main counter
        #update() {
            if (this.#updateSpriteInfo(this.master.state.name)) { }
            else {
                this.spriteName = ''
                this.spriteImage = null
                log('no shit to render')
                return
            }


            let mc = this.master.counter
            let mp = this.master.position
            this.drawposition.x = ((mp.x - 1) * canvas.width) / 6 + 10
            this.drawposition.y = (mp.y * canvas.height) / 6 + 40


            let FrameBuffer = mc.endTime / this.length
            this.currentFrame = Math.floor(mc.time / FrameBuffer)
            this.currentFrame %= this.length // loop
        }

        // draw position + Current Frame
        draw() {
            this.#update()

            const cropbox = {
                position: {
                    x: this.sprite.width * this.currentFrame,
                    y: 0,
                },
                width: this.sprite.width,
                height: this.sprite.height,
            }

            if (this.spriteImage) {
                if (!this.spriteLoad) return
                if (!this.spriteFlip) {
                    c.drawImage(
                        this.spriteImage,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        this.drawposition.x,
                        this.drawposition.y,
                        this.sprite.width,
                        this.sprite.height,
                    )
                } else {
                    c.save()
                    c.scale(-1, 1);
                    let _temp = -this.sprite.width
                    if (this.master.Tag.greyout)
                        c.filter = "saturate(0%)";  // 彩度を0%にしてグレースケールっぽく
                    else if (this.master.Tag.invisible)
                        c.filter = 'brightness(200%)'
                    c.drawImage(
                        this.spriteImage,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        -this.drawposition.x + _temp,
                        this.drawposition.y,
                        this.sprite.width,
                        this.sprite.height,
                    )

                    c.restore()
                    c.filter = 'none'
                }

            }

            c.fillStyle = 'rgba(127,127,127,1)'
            c.fillText(this.currentFrame, this.drawposition.x, this.drawposition.y + 20, 24)
        }
    }

    class MovieRenderer2 {
        constructor(master, spriteCollection) {
            this.master = master
            this.drawposition = { x: 0, y: 0 }
            this.spriteCollection = spriteCollection
            this.spriteName = ''
            this.damiSprite = new Image()
            this.spriteImage = this.damiSprite
            this.spriteLoad = false
            this.spriteFlip = false
            this.length = 1 // numbers of frames
            this.currentFrame = 0
            this.cropbox = {}
            this.sprite = {
                width: 0,
                height: 0
            }
        }

        #updateSpriteInfo(_name) {
            if (!this.spriteCollection.p[_name]) {
                log('not found sprite name')
                return false
            }
            if (this.spriteName == _name) return true
            let s = this.spriteCollection.p[_name]

            this.spriteFlip = false
            this.spriteLoad = false
            this.spriteName = _name
            if (s.flip) this.spriteFlip = true
            if (!this.spriteImage) this.spriteImage = this.damiSprite
            this.spriteImage.src = this.spriteCollection.f + s.path

            this.length = 1
            this.sprite = {
                width: 0,
                height: 0
            }
            this.spriteImage.onload = () => {
                this.spriteLoad = true
                this.length = this.spriteCollection.p[_name].length
                this.sprite = {
                    width: this.spriteImage.width / this.length,
                    height: this.spriteImage.height
                }
            }

            return true
        }

        // master state, main counter
        #update() {
            if (this.#updateSpriteInfo(this.master.state.name)) { }
            else {
                this.spriteName = ''
                this.spriteImage = null
                log('no shit to render')
                return
            }


            let mc = this.master.counter
            let mp = this.master.position
            this.drawposition.x = ((mp.x - 1) * canvas.width) / 6 + 10
            this.drawposition.y = (mp.y * canvas.height) / 6 + 40


            let FrameBuffer = mc.endTime / this.length
            this.currentFrame = Math.floor(mc.time / FrameBuffer)
            this.currentFrame %= this.length // loop
        }

        // draw position + Current Frame
        draw() {
            this.#update()

            const cropbox = {
                position: {
                    x: this.sprite.width * this.currentFrame,
                    y: 0,
                },
                width: this.sprite.width,
                height: this.sprite.height,
            }

            if (this.spriteImage) {
                if (!this.spriteLoad) return
                if (!this.spriteFlip) {
                    c.drawImage(
                        this.spriteImage,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        this.drawposition.x,
                        this.drawposition.y,
                        this.sprite.width,
                        this.sprite.height,
                    )
                } else {
                    c.save()
                    c.scale(-1, 1);
                    let _temp = -this.sprite.width
                    if (this.master.Tag.greyout)
                        c.filter = "saturate(0%)";  // 彩度を0%にしてグレースケールっぽく
                    else if (this.master.Tag.invisible)
                        c.filter = 'brightness(200%)'
                    c.drawImage(
                        this.spriteImage,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        -this.drawposition.x + _temp,
                        this.drawposition.y,
                        this.sprite.width,
                        this.sprite.height,
                    )

                    c.restore()
                    c.filter = 'none'
                }

            }

            c.fillStyle = 'rgba(127,127,127,1)'
            c.fillText(this.currentFrame, this.drawposition.x, this.drawposition.y + 20, 24)
        }
    }

    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    //
    //      utility_setup.js
    //
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////

    // maybe put these things into a class
    const chip_list = {
        sword: { name: "sword" },
        wide_sword: { name: "wide_sword" },
        long_sword: { name: "long_sword" },
    }

    var chip_selected = []

    for (let _c of chip_selected) {
        log(_c.name)
    }

    //////////////////////////////
    //////////////////////////////
    //                          //
    //      main.js
    //                          //
    //////////////////////////////
    //////////////////////////////

    const canvas = document.querySelector("canvas")
    const c = canvas.getContext("2d", { willReadFrequently: true })
    canvas.width = 300
    canvas.height = 200
    const tileSize = 50

    const GM = new GameManager2()
    const PP = new PostProcessor()
    //let counter = 0

    let enemy = new Player(ModelHData2)
    enemy.ID = CharID.Enemy
    enemy.position = { x: 5, y: 2 }

    let player2_2 = new Player(ModelHData2)
    player2_2.ID = CharID.Actor

    const charH = new PlayerFromData(ModelHData_eventDrived)
    const charL = new Player(ModelLData)
    let active_player = charH

    let data_player = new PlayerFromData(ModelHData_eventDrived)

    let characters = []
    // actor test!
    //characters.push(player_2) 
    characters.push(enemy)
    characters.push(active_player)
    //characters.push(data_player)

    let terrain = []
    testTile = new Tile()
    terrain.push(testTile)



    GM.observers.push(active_player)

    function update() {

        //polygon renderer,描画順などがめんどくさいので、あとにする
        // R_angle += 0.001
        //Renderer.render()

        if (keys.atk.pressed) {
            active_player.pushEvent('atk')
        }



        GM.update()
        //GM.notify('tests', GM)
        for (const t of terrain) {
            t.update()
            t.draw()
        }

        showHTML('active_player: ' + active_player.position.x + '' + active_player.position.y + ',charH: ' + charH.position.x + '' + charH.position.y + ',charL: ' + charL.position.x + '' + charL.position.y, 'position')

        requestAnimationFrame(update)


    }

    update()
</script>
