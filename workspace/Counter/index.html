<div class=container>
  <div class=left-column>
    <p id="content"></p>
    <p>idle infinite counter</p>

  </div>
  <div class=right-column>
    <canvas></canvas>
  </div>

</div>

<p>
  <button class="b1"> </button>
  <button class="b1" onmousedown="keyPress('up')">↑</button>
  <button class="b1"> </button>
</p>
<p>
  <button class="b1" onmousedown="keyPress('left')">←</button>
  <button class="b1" onmousedown="keyPress('down')">↓</button>
  <button class="b1" onmousedown="keyPress('right')">→</button>
  <button class="b1"> </button>
  <button onmousedown="keyPress('atk')">attack</button>
  <button onmousedown="keyPress('test')">add control counter</button>
</p>

<div>
  <p>
    <button onmousedown="keyPress('add_sword')">add sword</button>
    <button onmousedown="keyPress('select')">pause and select</button>
    <button onmousedown="keyPress('use_chip')">use the chip</button>
  </p>
</div>
<button onmousedown="keyPress('test')">Timing </button>
<button onmousedown="clearLog()">clear log </button>

<p>
<div id="chips"></div>
<div id="counters"></div>
<div id="log"></div>
</p>

<style>
  .b1 {
    width: 40px;
    height: 20px;
  }

  .container {
    display: flex;
  }

  .left-column {
    font-size: 10px;
    width: 30%;
    background-color: #f0f0f0;
    padding: 10px;
  }

  .right-column {
    width: 70%;
    background-color: #8f8f8f;
    padding: 10px;
  }
</style>

<script>
  keyPress = function (key) {
        keys[key].pressed = true
    }

    var keys = {
        up: { press: false, pressed: false },
        down: { press: false, pressed: false },
        left: { press: false, pressed: false },
        right: { press: false, pressed: false },
        select: { press: false, pressed: false },
        use_chip: { press: false, pressed: false },
        atk: { press: false, pressed: false },
        add_sword: { press: false, pressed: false },
        test: { press: false, pressed: false },
    }
    const rawUrl = "https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/workspace/Counter/Ideas.txt";


    const CharID = {
        Player: 0,
        Enemy: 1,
        Actor:2,
    }

    /*
    fetch(rawUrl)
        .then(response => response.text())
        .then(data => {
            document.getElementById("content2").textContent = data;
        })
        .catch(error => {
            document.getElementById("content2").textContent = "読み込み失敗: " + error;
        });
    */
    function log(msg) {
        document.getElementById("log").innerText += msg + "\n_"
    }
    function showChips(msg) {
        document.getElementById("chips").innerText = "[battle chips]:" + "\n_" + msg
    }
    function showCounters(msg) {
        document.getElementById("counters").innerText = "[Counters]:" + "\n_" + msg
    }
    function clearLog() {
        document.getElementById('log').innerText = "[my console]:\n"
    }
    clearLog()
    showChips("no chips")
</script>

<script>
  // classes.js
    // difficult to split files

    
    class PolygonRenderer {
        constructor() {
            console.log('polygon renderer online')
        }


        // get x,y,z in screen space
        project(v, angle = 0.5) {
            // Y軸回転
            const cos = Math.cos(angle), sin = Math.sin(angle);
            const x = v.x * cos - v.z * sin;
            const z = v.x * sin + v.z * cos + 9; // zをずらして奥へ
            const y = v.y - 2;

            // to screen space
            return {
                x: x / z * 400 + canvas.width / 2,
                y: -y / z * 400 + canvas.height / 2,
                z: z
            };
        }

        // x,y と　３つの頂点情報で　座標のWeightを求める
        getBarycentric(x, y, p0, p1, p2) {
            //やめとけ
            // console.log('doing math')
            const det = (p1.y - p2.y) * (p0.x - p2.x) + (p2.x - p1.x) * (p0.y - p2.y);
            const w0 = ((p1.y - p2.y) * (x - p2.x) + (p2.x - p1.x) * (y - p2.y)) / det;
            const w1 = ((p2.y - p0.y) * (x - p2.x) + (p0.x - p2.x) * (y - p2.y)) / det;
            const w2 = 1 - w0 - w1;
            return [w0, w1, w2];
        }

        render2(_vertices, _faces, _colors, _uv, angle, ctx, sampleuv = false) {
            //ctx.clearRect(0, 0, ctx.width, ctx.height);

            // 投影した頂点
            const projected = _vertices.map(v => this.project(v, angle));

            // 各三角形に z（平均深度）を与えてソート
            const triangles = _faces.map((_face, i) => {
                // _face は[vertex_id0,vertex_id1,vertex_id2]
                // そのvertex_idを実際の頂点情報に置き換える
                const combined = projected.map((v, i) => ({
                    x: v.x,
                    y: v.y,
                    z: v.z,
                    u: _uv[i].u,
                    v: _uv[i].v
                }));
                const [a, b, c] = _face.map(idx => combined[idx]);
                const depth = (a.z + b.z + c.z) / 3;

                // return 一つの三角形が必要なデータを組み立てして返す
                return { a, b, c, color: _colors[i], depth };
            }).sort((t1, t2) => t2.depth - t1.depth); // 奥から描画


            if (!sampleuv) {
                for (const tri of triangles) {
                    // uv sampling!

                    // 
                    const output = ctx.createImageData(500, 500);
                    const outData = output.data;

                    // Screen Spaceでバウンディングボックスを計算する
                    const triangle = [tri.a, tri.b, tri.c]
                    const xs = triangle.map(p => p.x);
                    const ys = triangle.map(p => p.y);
                    const minX = Math.floor(Math.min(...xs));
                    const maxX = Math.ceil(Math.max(...xs));
                    const minY = Math.floor(Math.min(...ys));
                    const maxY = Math.ceil(Math.max(...ys));

                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            const [w0, w1, w2] = this.getBarycentric(x, y, triangle[0], triangle[1], triangle[2]);//(u,v,p0,p1,p2)
                            if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
                                const outIdx = (y * 500 + x) * 4;
                                outData[outIdx + 0] = 255;
                                outData[outIdx + 1] = 255;
                                outData[outIdx + 2] = 255;
                                outData[outIdx + 3] = 255;
                            }
                        }
                    }

                    for (let i = 0; i < projected.length; i++) {
                        const p = projected[i]
                        ctx.fillStyle = 'black';
                        ctx.fillRect(p.x - 7, p.y - 7, 14, 14)
                        ctx.font = '14px sans-serif'
                        ctx.textBaseline = 'middle'
                        ctx.fillStyle = 'white'
                        ctx.textAlign = 'center'
                        ctx.fillText(i, p.x, p.y)
                    }

                    return
                }

            } else {
                for (const tri of triangles) {
                    // uv sampling!
                    if (imageLoaded) {
                        // texture を一回描いてからじゃないとgetImageDataができない
                        const tempCanvas = document.createElement("canvas");
                        const tempCtx = tempCanvas.getContext("2d");
                        tempCanvas.width = image.width;
                        tempCanvas.height = image.height;
                        tempCtx.drawImage(image, 0, 0);
                        const imageData = tempCtx.getImageData(0, 0, image.width, image.height);
                        const texData = imageData.data;
                        const texWidth = imageData.width;
                        const texHeight = imageData.height;

                        // 
                        const output = ctx.createImageData(500, 500);
                        const outData = output.data;


                        // Screen Spaceでバウンディングボックスを計算する
                        const triangle = [tri.a, tri.b, tri.c]
                        const xs = triangle.map(p => p.x);
                        const ys = triangle.map(p => p.y);
                        const minX = Math.floor(Math.min(...xs));
                        const maxX = Math.ceil(Math.max(...xs));
                        const minY = Math.floor(Math.min(...ys));
                        const maxY = Math.ceil(Math.max(...ys));

                        for (let y = minY; y <= maxY; y++) {
                            for (let x = minX; x <= maxX; x++) {
                                const [w0, w1, w2] = this.getBarycentric(x, y, triangle[0], triangle[1], triangle[2]);//(u,v,p0,p1,p2)
                                if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
                                    const u = triangle[0].u * w0 + triangle[1].u * w1 + triangle[2].u * w2;
                                    const v = triangle[0].v * w0 + triangle[1].v * w1 + triangle[2].v * w2;
                                    // あらかじめ三角形の各頂点に z, u/z, v/z を持たせておく
                                    const _u = (w0 * (triangle[0].u / triangle[0].z) + w1 * (triangle[1].u / triangle[1].z) + w2 * (triangle[2].u / triangle[2].z));
                                    const _v = (w0 * (triangle[0].v / triangle[0].z) + w1 * (triangle[1].v / triangle[1].z) + w2 * (triangle[2].v / triangle[2].z));
                                    const w = (w0 / triangle[0].z + w1 / triangle[1].z + w2 / triangle[2].z);

                                    // 最後に割り戻す
                                    const correctedU = _u / w;
                                    const correctedV = _v / w;

                                    const texX = Math.floor(correctedU * texWidth);
                                    const texY = Math.floor(correctedV * texHeight);
                                    const idx = (texY * texWidth + texX) * 4;

                                    const r = texData[idx];
                                    const g = texData[idx + 1];
                                    const b = texData[idx + 2];
                                    const a = texData[idx + 3];

                                    ctx.fillStyle = `rgb(${r},${g},${b},${a})`;
                                    const outIdx = (y * 500 + x) * 4;
                                    outData[outIdx + 0] = r;
                                    outData[outIdx + 1] = g;
                                    outData[outIdx + 2] = b;
                                    outData[outIdx + 3] = a;
                                }
                            }
                        }

                        createImageBitmap(output).then(bitmap => {
                            ctx.drawImage(bitmap, 0, 0);
                            //この中に入れて置かないと、JSの描画の順番が狂う
                            for (let i = 0; i < projected.length; i++) {
                                const p = projected[i]
                                ctx.fillStyle = 'black';
                                ctx.fillRect(p.x - 7, p.y - 7, 14, 14)
                                ctx.font = '14px sans-serif'
                                ctx.textBaseline = 'middle'
                                ctx.fillStyle = 'white'
                                ctx.textAlign = 'center'
                                ctx.fillText(i, p.x, p.y)
                            }
                        });

                    }

                }
            }

            // vertex index overlay

        }

        render() {
            this.render2(vertices2, faces2, colors2, uv2, R_angle, c, true);
            this.render2(player.vertices, player.faces, player.color, player.uv, R_angle, c, true);

        }
    }


    class Player {
        constructor() {
            console.log("player online")
            this.position = { x: 1, y: 1 }
            this.HP = 100
            this.ID = CharID.Player
            this.stance = 100
            this.isFree = true
            this.state = {
                moving: false,
                usingChip: false,
                buffed: false,
                idle: false,
                attack: false,
            }

            this.moveGridStop = 20
            this.chipName = ""
            //this.position.y=10
            this.counter = null
            this.renderer = new MovieRenderer(this)

            this.local_vertices = [
                { x: -3, y: 1.5, z: 2.5 },
                { x: -3, y: 0, z: 2.5 },
                { x: -2, y: 0, z: 2.5 },
                { x: -2, y: 1.5, z: 2.5 }
            ]
            this.vertices = [{ x: -3, y: 1.5, z: 2.5 },
            { x: -3, y: 0, z: 2.5 },
            { x: -2, y: 0, z: 2.5 },
            { x: -2, y: 1.5, z: 2.5 }]
            this.uv = [
                { u: 0, v: 0 },
                { u: 0, v: 1 },
                { u: 1, v: 1 },
                { u: 1, v: 0 }
            ]
            this.faces = [[0, 1, 2], [0, 2, 3]]
            this.color = ['white', 'white']
        }

        update_vertices() {
            this.vertices = this.local_vertices.map(v => ({
                x: v.x + this.position.x - 1,
                y: v.y,
                z: v.z - this.position.y + 1
            }))
        }

        cst(_state) {
            if (!this.state[_state]) { this.state[_state] = true; return true; }

            return false
        }

        est(state) {
            if (this.state[state]) { this.state[state] = false; return true; }
            return false
        }

        startMove(_x, _y) {
            if (!this.state['idle']) return
            log('move!')
            if (
                this.position.x + _x < 1 ||
                this.position.x + _x > 3 ||
                this.position.y + _y < 1 ||
                this.position.y + _y > 3
            )
                return
            if (this.cst('moving')) {
                let c = GM._addCounterGen({
                    _endtime: this.moveGridStop,
                    _msg: "[GM]player moving",
                    _endCall: () => { },
                })
                c.processCall = () => {
                    if (c.time == this.moveGridStop / 2) { this._moveGrid(_x, _y); }
                    else if (c.time == this.moveGridStop) { this.est('moving'); c.end = true; this.counter = null; }
                }
                this.counter = c
            }
        }
        _moveGrid(_x, _y) {
            this.position.x += _x
            this.position.y += _y
        }

        resetCounter0() {
            //log('reset counter')
            if (this.counter) { this.counter.end = true; this.counter = null; }
        }

        startUseChip() {
            if (chip_selected.length < 1) { console.log("no chip selected"); return; }
            if (this.cst('usingChip')) {

                // use the first chip
                this.chipName = chip_selected[0].name
                chip_selected.splice(0, 1)
                //this.counter = GM._addCounter(40, "[GM]player using chip", () => this._endUseChip())
                this.counter = GM._addCounterGen({
                    _endtime: 100,
                    _msg: "[GM]player using chip",
                    _endCall: () => this._endUseChip(),
                    _gen_list: [
                        {
                            time: 40,
                            call: () =>
                                GM._addCounterGen({
                                    _endtime: 30,
                                    _msg: "qte counting...",
                                    _endCall: () => this.HP -= 25,
                                    _qteCall: () => {
                                        this.state["buffed"] = true
                                        GM.addSPCounter()
                                        enemy.HP -= 20
                                        log("PERFECT!")
                                    },
                                }),
                        },
                    ],
                })
            }
        }
        _endUseChip() {
            this.est('usingChip')
            this.resetCounter0()
        }

        endAttack() {
            this.est('attack')
            this.resetCounter0()

        }
        startAtk() {
            if (!this.state['idle']) return
            if (this.cst('attack')) {
                this.resetCounter0()
                let c = GM._addCounterGen({
                    _endtime: 40,
                    _msg: this.ID+' attaking',
                    _processCall: () => { },
                    _endCall: () => { log('end atk'); this.endAttack(); enemy.HP -= 2; }
                })
                c.processCall = () => {
                    if(this.ID != CharID.Player) return
                    if (keys.atk.pressed && c.time > c.end_time / 2)
                        c.time = 0
                }
                this.counter = c
            }
        }

        _handleInput() {
            if (this.ID != CharID.Player) return
            if (!this.state['idle']) return
            if (keys.atk.pressed) { this.startAtk(); }
            if (keys.use_chip.pressed) this.startUseChip()

            if (keys.down.pressed) this.startMove(0, 1)
            if (keys.up.pressed) this.startMove(0, -1)
            if (keys.left.pressed) this.startMove(-1, 0)
            if (keys.right.pressed) this.startMove(1, 0)


        }


        update() {
            this.update_vertices()
            if (this.ID == CharID.Enemy) return


            //key event
            //Counterの更新はこの時点で済んでる
            this._handleInput()
            //change the postion
            if (this.position.y > 3) this.position.y = 3
            else if (this.position.y < 1) this.position.y = 1
            if (this.position.x > 3) this.position.x = 3
            else if (this.position.x < 1) this.position.x = 1

            // back to idle
            let _state_true = 0
            for (let s in this.state) {
                if (this.state[s])
                    if (!['buffed', 'idle'].includes(s)) {
                        _state_true++;
                        //console.log('current state: ' + s);
                    }
            }
            if (_state_true == 0) {
                if (this.cst('idle')) {
                    this.resetCounter0()
                    let c = GM._addCounterGen({
                        _endtime: 40,
                        _endCall: () => log('idle loop'),
                    })
                    c.processCall = () => {
                        if (!this.state['idle']) { c.setEnd(); return }
                        if (c.time == c.end_time) {
                            c.time = 0
                        }
                    }
                    this.counter = c
                    console.log(_state_true + ' back to idle')
                }
            } else {
                if (this.est('idle')) {
                    console.log(_state_true + ' end idle')
                }
            }

        }

        draw() {
            const temp_draw = () =>
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40,
                    20,
                    tileSize,
                )
            const temp_print = (msg) =>
                c.fillText(
                    msg,
                    10 + ((this.position.x - 1) * canvas.width) / 6,
                    (this.position.y * canvas.height) / 6 + 40 + 10,
                )
            const temp_draw_gauge = (_counter) => {
                c.fillStyle = "rgba(0,0,0,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40 + tileSize,
                    tileSize,
                    5,
                )
                c.fillStyle = "rgb(255, 255, 255)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 40 + tileSize,
                    (_counter.time / _counter.end_time) * tileSize,
                    5,
                )
            }
            const temp_draw_gauge2 = (_current, _max) => {
                c.fillStyle = "rgba(0,0,0,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 10,
                    tileSize,
                    5,
                )
                c.fillStyle = "rgba(255,0,0,1)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 10,
                    (_current / _max) * tileSize,
                    5,
                )
            }

            temp_draw_gauge2(this.HP, 100)
            if (this.state["buffed"]) {
                c.fillStyle = "rgb(251, 255, 0)"
                c.fillRect(
                    ((this.position.x - 1) * canvas.width) / 6 + 10,
                    (this.position.y * canvas.height) / 6 + 20,
                    tileSize,
                    5,
                )
            }


            if (this.ID == CharID.Enemy) {
                c.fillStyle = "rgba(255,0,255,1)"
                temp_draw()

            }

            if (this.state["usingChip"]) {
                c.fillStyle = "rgb(255, 255, 255)"
                temp_print("using chips")
            } else if (this.state["moving"]) {
                c.fillStyle = "rgba(255,255,255,1)"
                temp_print("moving")
            } else if (this.state['attack']) {
                c.fillStyle = "rgba(255,255,255,1)"
                temp_print("attack")
            } else {
                c.fillStyle = "rgba(255,255,255,1)"
                temp_print("idle")
            }

            if (this.counter) {
                temp_draw_gauge(this.counter)
                this.renderer.draw()
            }
        }
    }

    // only render
    class MovieRenderer {
        constructor(master) {
            console.log("movie renderer online")
            this.master = master
            this.drawposition = { x: 0, y: 0 }

            this.spriteName = ''
            this.spriteImage = new Image()
            this.spriteLoad = false
            this.spriteFlip = false
            this.spriteCollection = {
                test: {
                    path: "https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/red/enchant.png",
                    rect: { w: 56, h: 56 },
                    length: 8,
                },
                move: {
                    path:
                        'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4867.png',
                    rect: { w: 40, h: 64 },
                    length: 8,
                    flip: true,
                },
                idle: {
                    path:
                        'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4865.png'
                    , rect: { w: 44, h: 50 },
                    length: 4,
                    flip: true,
                },
                attack1: {
                    path: 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4863.png'
                    ,
                    rect: { w: 44, h: 56 },
                    length: 4,
                },
                attack2: {
                    path: 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/IMG_4866.png'
                    ,
                    rect: { w: 100, h: 64 },
                    length: 12,
                    flip: true,
                }
            }
            this.length = 1 // numbers of frames
            this.currentFrame = 0
            this.cropbox = {}
            this.sprite = {
                width: 0,
                height: 0
            }
        }

        #updateSpriteInfo(_name) {
            if (this.spriteName == _name) return
            this.spriteFlip = false
            this.spriteLoad = false
            this.spriteName = _name
            let s = this.spriteCollection[_name]
            if (s.flip) this.spriteFlip = true
            this.spriteImage.src = s.path
            this.spriteImage.onload = () => {
                this.spriteLoad = true
            }
            this.length = this.spriteCollection[_name].length
            this.sprite = {
                width: this.spriteCollection[_name].rect.w,
                height: this.spriteCollection[_name].rect.h
            }
        }

        #update() {
            if (this.master.state['usingChip']) {
                this.#updateSpriteInfo('test')
            } else if (this.master.state['moving']) {
                this.#updateSpriteInfo('move')

            } else if (this.master.state['attack']) {
                this.#updateSpriteInfo('attack2')
            } else if (this.master.state['idle']) {
                this.#updateSpriteInfo('idle')
            } else {
                this.spriteImage = null
                return
            }

            let mc = this.master.counter
            let mp = this.master.position
            this.drawposition.x = ((mp.x - 1) * canvas.width) / 6 + 10
            this.drawposition.y = (mp.y * canvas.height) / 6 + 40


            let FrameBuffer = mc.end_time / this.length
            this.currentFrame = Math.floor(mc.time / FrameBuffer)
            this.currentFrame %= this.length // loop
        }

        // draw position + Current Frame
        draw() {
            this.#update()

            const cropbox = {
                position: {
                    x: this.sprite.width * this.currentFrame,
                    y: 0,
                },
                width: this.sprite.width,
                height: this.sprite.height,
            }

            if (this.spriteImage) {
                if (!this.spriteLoad) return
                if (!this.spriteFlip) {
                    c.drawImage(
                        this.spriteImage,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        this.drawposition.x,
                        this.drawposition.y,
                        this.sprite.width,
                        this.sprite.height,
                    )
                } else {
                    c.save()
                    c.scale(-1, 1);
                    let _temp = -this.sprite.width
                    c.drawImage(
                        this.spriteImage,
                        cropbox.position.x,
                        cropbox.position.y,
                        cropbox.width,
                        cropbox.height,

                        -this.drawposition.x + _temp,
                        this.drawposition.y,
                        this.sprite.width,
                        this.sprite.height,
                    )
                    c.restore()
                }

            }

            c.fillStyle = 'rgba(0,0,0,1)'
            c.fillText(this.currentFrame, this.drawposition.x, this.drawposition.y + 20, 24)
        }
    }

    class GameManager {
        constructor() {
            console.log("game manager online")
            this.isPaused = false
            this.chips = []
            this.counters = []
            this.dominantCounter = null
            this.state = {
                pause: false,
                title: false,
                world: false,
                dialog: false,
                battle: true,
                battle_win: false,
            }
        }

        useChip() { }

        _showCounters() {
            let _table = ""
            for (let _c of this.counters) {
                _table += _c.msg + ":" + _c.time + "/" + _c.end_time + "\n"
            }
            showCounters(_table)
        }

        #showChips() {
            let _table = ""
            for (let chip of chip_selected) {
                _table += chip.name + ", "
            }
            showChips(_table)
        }

        _draw_Darken() {
            c.fillStyle = "rgba(0,0,0,0.5)"
            c.fillRect(0, 0, canvas.width, canvas.height)
        }

        _handleInput() {
            if (this.state["title"]) {
                if (keys.select.pressed) {
                    this.state["title"] = false
                }
                return
            } else if (this.state["dialog"]) {
                if (keys.select.pressed) {
                    this.state["dialog"] = false
                }
            } else {
                if (keys.select.pressed) {
                    if (this.state["pause"]) this.state["pause"] = false
                    else this.state["pause"] = true
                }

                if (keys.add_sword.pressed) {
                    if (this.state["pause"]) chip_selected.push(chip_list.sword)
                }

                if (keys.test.pressed) {
                    const c = this._addCounterGen({
                        _endtime: 300,
                        _processCall: () => {
                        }
                    })
                    c.processCall = () => {
                        // プレイヤーキャラを使って制御のテストする
						            // 懐かしいな。ムービーゲーの可能性を見つけたあの午後の雰囲気を思い出す
                        if(c.time == 1){
                          characters.push(player2)
                        }else if (c.time == 30) {
                            player2.startMove(0, 1)
                        } else if (c.time == 80) {
                            player2.startAtk()
                        } else if (c.time == 100){
                            enemy.HP -=30
                        }else if (c.time == 200){
                            characters.pop()

                        }
                    }
                }
            }
        }

        addSPCounter() {
            let _c = new Counter({
                _endtime: 100,
            })

            _c.processCall = () => {
                let _t = _c.time
                if (_c.time == 1) PP.state["darken"] = true
                if (_c.time == 10) if (_c.time == 40) log("player animation")
                if (_c.time == 100) {
                    log("over")
                    PP.state["darken"] = false
                }

                if (_t < 10) {
                    PP.fillStyle = `rgba(255,255,255,${Math.min(_t * 0.1, 1) * 0.5})`
                } else if (_t < 90) {
                    PP.fillStyle = "rgba(255,255,255,0.5)"
                } else {
                    PP.fillStyle = `rgba(255,255,255,${0.5 - (_t - 90) * 0.1 * 0.5})`
                }
            }
            GM.dominantCounter = _c
        }

        _addCounterGen({
            _endtime = 10,
            _msg = "_untitled_counter",
            _processCall = null,
            _endCall = () => {
                this.end = true
            },
            _gen_list = null,
            _qteCall = null,
        } = {}) {
            console.log("add time" + _msg)
            let _temp = new Counter({
                endtime: _endtime,
                msg: _msg,
                processCall: _processCall,
                endCall: _endCall,
                gen_list: _gen_list,
                qteCall: _qteCall,
            })
            this.counters.push(_temp)
            return _temp
        }

        #print_state() {
            c.fillStyle = "rgba(255,255,255,1)"
            c.fillText("pause and select", 10, 10)
        }

        #draw() {
            
            if (this.state["title"]) {
                c.fillStyle = "rgba(0,0,0,1)"
                c.fillRect(0, 0, canvas.width, canvas.height)
                c.fillStyle = "rgba(255,255,255,1)"
                c.fillText("press select key to start", 10, canvas.height / 2)
                return
            }

            if (this.state['battle_win']) {
                c.fillStyle = "rgba(255,255,255,1)"
                c.fillRect(0, 0, canvas.width, canvas.height)
                c.fillStyle = "rgba(0,20,0,1)"
                c.fillText("you win!", 10, canvas.height / 2)
                return
            }
            c.fillStyle = "rgba(200,230,250,1)"
            c.fillRect(0, 0, canvas.width, canvas.height)

            c.fillStyle = "rgba(200,200,200,1)"
            c.fillRect(0, canvas.height / 2, canvas.width, canvas.height)

            c.strokeStyle = "blue"
            c.lineWidth = 5
            c.beginPath() // パスの開始
            c.moveTo(0, canvas.height / 2) // 開始点（x:50, y:50）
            c.lineTo(0, canvas.height)
            c.lineTo(canvas.width, canvas.height) // 終点（x:250, y:100）
            c.lineTo(canvas.width, canvas.height / 2)
            c.lineTo(0, canvas.height / 2)
            for (let i = 1; i < 3; i++) {
                c.moveTo(0, (canvas.height / 6) * i + canvas.height / 2)
                c.lineTo(canvas.width, (canvas.height / 6) * i + canvas.height / 2)
            }
            for (let i = 1; i < 6; i++) {
                c.moveTo((canvas.width / 6) * i, canvas.height / 2)
                c.lineTo((canvas.width / 6) * i, canvas.height)
            }
            c.stroke()

            if (this.state["pause"]) {
                this._draw_Darken()
                this.#print_state()
            } else {
            }
            this._showCounters()
            this.#showChips()
            this.#print_state()

            if (this.state["dialog"]) {
                if (imgLoaded) {
                    c.drawImage(img, 0, 0, 30, 30)
                }
                c.fillStyle = "rgba(100,100,100,1)"
                c.fillRect(
                    10,
                    (canvas.height / 4) * 3,
                    canvas.width - 20,
                    canvas.height / 5,
                )
            }
            PP.draw()

            for(let _p of characters){
              _p.draw()
              //log('draw characters')
            }
        }
        #update_counters() {
            if (this.dominantCounter) {
                this.dominantCounter.update()
                if (this.dominantCounter.end) this.dominantCounter = null
                return
            }
            for (let _c of this.counters) {
                _c.update()
            }
            this.counters = this.counters.filter((_c) => _c.end == false)
        }

        update() {
            this._handleInput()

            if (this.state["title"]) {
            } else if (this.state["pause"]) {
                //     console.log('paused')
            } else {
                this.#update_counters()
                for(let p of characters){
                  p.update()
                }
                if (this.state['battle']) {
                    if (enemy.HP <= 0) { this.state['battle_win'] = true; this.state['battle'] = false }
                }
                if (this.state['battle_win']) { }

            }

            for (let _key in keys) keys[_key].pressed = false

            //console.log(message+counter)
            this.#draw()
        }
    }

    class PostProcessor {
        constructor() {
            this.state = {
                darken: false,
            }
            this.fillStyle = "rgba(0, 0, 0,1)"
        }
        draw() {
            if (this.state["darken"]) {
                //log(this.fillStyle)
                c.fillStyle = this.fillStyle
                c.fillRect(0, 0, canvas.width, canvas.height)

                this.down_saturation()
                c.fillStyle = "rgb(255, 255, 255)"
                c.fillText("auto proccessing...", canvas.width / 2, canvas.height / 2)
                c.save()
                let fontSize = 64
                c.font = `${fontSize}px Arial`
                c.fillStyle = "rgb(255, 211, 17)"
                c.fillText("WIPEOUT!", 0, canvas.height / 2)
                c.restore()
            }
        }

        down_saturation() {
            // 彩度を0%にして再描画
            const offCanvas = document.createElement("canvas")
            offCanvas.width = canvas.width
            offCanvas.height = canvas.height
            const offCtx = offCanvas.getContext("2d")

            // 一旦現在の canvas をオフスクリーンにコピー
            offCtx.drawImage(canvas, 0, 0)

            // 彩度を下げて再描画
            c.clearRect(0, 0, canvas.width, canvas.height)
            c.filter = "saturate(20%)"
            c.drawImage(offCanvas, 0, 0)
            c.filter = "none" // 忘れずに戻す
        }
    }

    class Counter {
        constructor({
            endtime = 100,
            name = "",
            end = false,
            target = undefined,
            msg = "__",
            processCall = null,
            endCall = () => { },
            gen_list = false,
            qte = false,
            qteCall = false,
        } = {}) {
            this.time = 0
            this.end_time = endtime
            this.end = end
            this.target = target
            this.processCall = processCall
            this.msg = msg
            this.endCall = endCall
            this.gen_list = gen_list
            this.qteCall = qteCall
        }
        start() { }

        setEnd() {
            this.end = true
        }
        _isEnd() {
            return this.end
        }

        #endMethod() {
            console.log(this.msg + " " + this.end_time + " counter end")
            this.end = true
            this.endCall()
        }

        progress() {
            return this.time / this.end_time
        }

        update() {
            if (this.time < this.end_time) {
                this.time++
                if (this.processCall) { this.processCall() }
                if (this.gen_list) {
                    let _length = Object.keys(this.gen_list).length
                    for (let i = 0; i < _length; i++) {
                        const _time = this.gen_list[i].time
                        const _call = this.gen_list[i].call
                        if (this.time == _time) {
                            log("time: " + _time)
                            _call()
                        }
                    }
                }
                if (this.qteCall) {
                    if (keys.use_chip.pressed) {
                        this.end = true
                        this.qteCall()
                    }
                }
            } else this.#endMethod()
        }
    }

    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////
    //
    //      utility_setup.js
    //
    ////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////

    // maybe put these things into a class
    const chip_list = {
        sword: { name: "sword" },
        wide_sword: { name: "wide_sword" },
        long_sword: { name: "long_sword" },
    }

    var chip_selected = []

    for (let _c of chip_selected) {
        log(_c.name)
    }

    //////////////////////////////
    //////////////////////////////
    //                          //
    //      main.js
    //                          //
    //////////////////////////////
    //////////////////////////////

    const canvas = document.querySelector("canvas")
    const c = canvas.getContext("2d", { willReadFrequently: true })
    canvas.width = 300
    canvas.height = 200
    const tileSize = 50

    let counter = 0
    let player = new Player()
    let enemy = new Player()
    let player2 = new Player()
    enemy.ID = CharID.Enemy
    player2.ID = CharID.Actor
    let characters = []
    characters.push(player)
    characters.push(enemy)
    enemy.position = { x: 5, y: 2 }
    const PP = new PostProcessor()
    const GM = new GameManager()

    // for html

    const vertices2 = [
        { x: -3, y: 0, z: 3 },
        { x: -3, y: 0, z: 0 },
        { x: 3, y: 0, z: 0 },
        { x: 3, y: 0, z: 3 },
    ]

    // uv, v inversed
    const uv2 = [
        { u: 0, v: 0 },
        { u: 0, v: 1 },
        { u: 1, v: 1 },
        { u: 1, v: 0 },
    ]
    const faces2 = [
        [0, 1, 2], [0, 2, 3], // floor
    ]
    const colors2 = [
        "#999", "#999",
    ]


    let imageLoaded = false
    let image = new Image()
    image.crossOrigin = "anonymous";//これ入れても行けないケースがいるらしい
    image.src = 'https://raw.githubusercontent.com/kurokoTJF/FUKAN/refs/heads/main/Sprites/Char/battle_floor.png'

    image.onload = () => {
        imageLoaded = true
    }

    
  
    let R_angle = 0;

    const Renderer = new PolygonRenderer()

    function update() {
        //console.log(keys.down.pressed);

        //polygon renderer,描画順などがめんどくさいので、あとにする
        // R_angle += 0.001
        //Renderer.render()

        GM.update()
        requestAnimationFrame(update)
    }

    update()
</script>
